% arara: lualatex
% arara: bib2gls: {group: on} if missing("glstex") || changed(toFile("bib2gls.bib")) || found("log", "Warning: Glossary entry")
% arara: bibtex
% arara: lualatex if changed("glstex") || missing("toc")
% arara: bib2gls: {group: on}
% arara: lualatex 
% arara: lualatex if found ("log", "Rerun")
\documentclass[titlepage=false,fontsize=12pt,captions=tableheading]{scrreprt}

\usepackage[no-math]{fontspec}
\setmainfont{Linux Libertine O}

\newfontface\cyrillicmono{FreeMono}[Scale=MatchLowercase]
\newcommand{\textcyrillicmono}[1]{{\cyrillicmono #1}}

\usepackage[x11names]{xcolor}
\usepackage{upquote}
\usepackage{hologo}
\usepackage{pifont}
\usepackage{graphicx}
\usepackage{tcolorbox}
\usepackage{datetime2}
\usepackage{siunitx}
\usepackage[version=4]{mhchem}

\usepackage{xr-hyper}
\usepackage[hidelinks]{hyperref}
\usepackage[record,
 entrycounter,subentrycounter,%need to define counters for some examples
 nostyles,stylemods={bookindex},style=index]{glossaries-extra}

\setupglossaries{entrycounter=false,subentrycounter=false}

\definecolor{field}{named}{DarkSlateGray4}
\definecolor{cs}{named}{DarkSeaGreen4}
\definecolor{styopt}{named}{DarkOrchid4}
\definecolor{entry}{named}{SteelBlue4}
\definecolor{comment}{named}{gray}
\definecolor{attribute}{named}{Purple4}
\definecolor{style}{named}{Blue4}

\newcommand{\extstyopt}{\textsuperscript{\textdagger}}

\newcommand{\dhyphen}{%
 \texorpdfstring
 {\discretionary{}{}{}\texttt{-}}%
 {-}%
}

\renewrobustcmd{\-}{%
 \discretionary
 {{\rmfamily\char\ifnum\hyphenchar\font<0
  \defaulthyphenchar\else\hyphenchar\font\fi
 }}%
 {}{}%
}

\setabbreviationstyle[common]{short-nolong}
\setabbreviationstyle[markwordsexample]{long-hyphen-short-hyphen}
\glssetcategoryattribute{markwordsexample}{markwords}{true}
\GlsXtrEnableInitialTagging{taggingexample}{\itag}
\glssetcategoryattribute{discardperiodexample}{discardperiod}{true}
\glssetcategoryattribute{initialism}{insertdots}{true}
\glssetcategoryattribute{initialism}{discardperiod}{true}
\glssetcategoryattribute{initialism}{retainfirstuseperiod}{true}
\setabbreviationstyle[initialism]{short-long}
\setabbreviationstyle[abbrvtrans]{long-short-user}
\setabbreviationstyle[longshortem]{long-short-em}
\setabbreviationstyle[shortsc]{short-sc-nolong}

\newcommand{\bibglspassim}{}
\newcommand{\bibglsseealsosep}{\par\hangindent .75em\parindent .75em\relax}

\newcommand*{\csfmt}[1]{%
 \texorpdfstring
 {\csfmtfont{\char`\\ #1}}%
 {\string\\#1}%
}

\newcommand*{\csref}{\gls}

\newcommand{\texparserdefnote}{}

\newcommand*{\longargfmt}[1]{%
 \texorpdfstring{\texttt{\longswitch #1}}%
 {\string-\string-#1}%
}

\GlsXtrLoadResources[
 src={bib2gls},
 max-loc-diff=3,
 entry-type-aliases={
  exampleentry=entry,
  examplesymbol=symbol,
  exampleabbreviation=abbreviation
 },
 unknown-entry-alias={index},
 field-aliases={note=user2},
 symbol-sort-fallback={name},
 break-at={none},
 sort-replace={{,? +}{|},{\glshex2423}{ },
  {\string\\([a-zA-Z])}{\glscapturedgroup1},
  {([a-zA-Z])\string\.}{\glscapturedgroup1}}
]

\DTMsavetimestamp{creation}{2017-01-20T15:39:00Z}

\IfFileExists{../java/Bib2Gls.java}
{
  \DTMsavefilemoddate{moddate}{../java/Bib2Gls.java}
}
{
  \DTMsavenow{moddate}
}

\newcommand{\bibgls}{\appfmt{bib2gls}}

\newcommand*{\BibTeX}{\hologo{BibTeX}}
\newcommand*{\eTeX}{\hologo{eTeX}}
\newcommand*{\XeLaTeX}{\hologo{XeLaTeX}}
\newcommand*{\LuaLaTeX}{\hologo{LuaLaTeX}}
\newcommand*{\pdfLaTeX}{\hologo{pdfLaTeX}}

\newcommand*{\ctanfile}[2]{%
 \href{http://mirrors.ctan.org/macros/latex/contrib/#1/#2}{\nolinkurl{#2}}%
}

\newcommand{\hex}[1]{0x#1}

\newcommand{\qt}[1]{``#1''}

\newcommand{\qtt}[1]{\qt{\,\texttt{#1}\,}}

\newcommand{\incorrect}{\marginpar{\textcolor{red}{\ding{55}}}}
\newcommand{\correct}{\marginpar{\textcolor{green}{\ding{52}}}}

\newcounter{result}

\newenvironment{result}%
{%
 \renewcommand{\glslinkpresetkeys}{\setkeys{glslink}{hyper=false,local}}%
 \glsresetentrycounter
 \stepcounter{result}%
 \renewcommand{\GlsEntryCounterLabelPrefix}{glsentry\theresult-}%
 \begin{quotation}%
 \marginpar
  [\raisebox{-2.5ex}{\ding{43}}]%
  {\raisebox{-2.5ex}{\reflectbox{\ding{43}}}}%
 \ignorespaces
}
{\end{quotation}\ignorespacesafterend}

\newcommand{\dequals}{%
 \texorpdfstring
 {\discretionary{}{}{}\texttt{=}\discretionary{}{}{}}%
 {=}%
}

\newcommand{\dcomma}{%
 \texorpdfstring
 {\texttt{,}\discretionary{}{}{}}%
 {,}%
}

\newcommand{\dcolon}{%
 \texorpdfstring
 {\texttt{:}\discretionary{}{}{}}%
 {:}%
}

\pdfstringdefDisableCommands{%
  \def\dhyphen{-}%
  \def\dcolon{:}%
  \def\dcomma{,}%
  \def\dequals{,}%
  \let\-\empty
}

\newcommand*{\csfmtfont}[1]{\texttt{#1}}

\newcommand*{\appfmt}[1]{\texorpdfstring{\texttt{#1}}{#1}}
\newcommand*{\styfmt}[1]{\texorpdfstring{\textsf{#1}}{#1}}
\newcommand*{\envfmt}[1]{\texorpdfstring{\textsf{#1}}{#1}}
\newcommand*{\optfmt}[1]{\texorpdfstring{\texttt{#1}}{#1}}
\newcommand*{\csoptfmt}[1]{\texorpdfstring{\textcolor{cs}{\optfmt{#1}}}{#1}}
\newcommand*{\styoptfmt}[1]{\texorpdfstring{\textcolor{styopt}{\optfmt{#1}}}{#1}}
\newcommand*{\fieldfmt}[1]{\texorpdfstring{\texttt{\color{field}#1}}{#1}}
\newcommand*{\entryfmt}[1]{\texorpdfstring{\texttt{\color{entry}#1}}{#1}}
\newcommand*{\atentryfmt}[1]{\entryfmt{@#1}}
\newcommand*{\abbrstylefmt}[1]{\texorpdfstring{\textsf{\color{style}#1}}{#1}}
\newcommand*{\glostylefmt}[1]{\texorpdfstring{\textsf{#1}}{#1}}
\newcommand*{\catattrfmt}[1]{\texorpdfstring{\textsf{\color{attribute}#1}}{#1}}
\newcommand*{\counterfmt}[1]{\texorpdfstring{\textsf{#1}}{#1}}
\newcommand*{\filefmt}[1]{\texorpdfstring{\texttt{#1}}{#1}}
\newcommand*{\metafilefmt}[3]{%
  \filefmt{#1}\discretionary{}{}{}\meta{#2}\discretionary{}{}{}\filefmt{#3}%
}

\newcommand*{\extfmt}[1]{\filefmt{.#1}}%

\newcommand*{\argor}{\texorpdfstring{\protect\textbar}{|}}

\newrobustcmd*{\texmeta}[1]{{\normalfont\normalcolor$\langle$\emph{#1}$\rangle$}}

\newcommand*{\meta}[1]{%
 \texorpdfstring{\ifmmode\text{\texmeta{#1}}\else\texmeta{#1}\fi}{#1}%
}

\newcommand*{\oarg}[1]{\discretionary{}{}{}[#1]}
\newcommand*{\oargm}[1]{\oarg{\meta{#1}}}

\newcommand*{\marg}[1]{\texorpdfstring
 {\discretionary{}{}{}\char`\{#1\char`\} }%
 {\{#1\}}%
}

\newcommand*{\margm}[1]{\marg{\meta{#1}}}

\newcommand{\switcharg}{}
\newcommand{\switchalt}{}

\makeatletter
\newcommand{\code}[1]{\texorpdfstring{{\ttfamily\obeyspaces #1}}{#1}}
\newcommand{\setupcodeenvfmts}{%
   \def\cmd{\char`\\}%
   \def\comment##1{\mbox{\textcolor{comment}{\idx{commentchar}\ ##1}}}%
   \renewcommand*{\styfmt}[1]{##1}%
   \renewcommand*{\counterfmt}[1]{##1}%
   \renewcommand*{\catattrfmt}[1]{\textcolor{attribute}{##1}}%
   \renewcommand*{\abbrstylefmt}[1]{\textcolor{style}{##1}}%
   \renewcommand*{\csfmtfont}[1]{\textcolor{cs}{##1}}%
}
\newenvironment{codeenv}
 {%
   \renewcommand{\glslinkpresetkeys}{\setkeys{glslink}{noindex}}%
   \setupcodeenvfmts
    \begin{flushleft}\textcolor{lightgray}{\hrulefill}\par\nopagebreak
     \medskip\nopagebreak
     \ttfamily\obeylines\frenchspacing\@vobeyspaces}
 {\nopagebreak\textcolor{lightgray}{\hrulefill}%
  \end{flushleft}\ignorespacesafterend}

\newenvironment{codeenv*}
 {%
   \setupcodeenvfmts
   \begin{flushleft}\ttfamily\obeylines\frenchspacing\@vobeyspaces
   \parindent\z@\parfillskip\@flushglue\parskip\z@skip
 }
 {\end{flushleft}\ignorespacesafterend}

\makeatother

\newcommand{\primary}{\emph}
\newcommand{\primaryloc}[1]{\underline{\hyperbf{#1}}}

\newcommand{\pidx}[1][]{\gls[textformat=primary,format=primaryloc,#1]}
\newcommand{\pidxpl}[1][]{\glspl[textformat=primary,format=primaryloc,#1]}
\newcommand{\pIdx}[1][]{\Gls[textformat=primary,format=primaryloc,#1]}
\newcommand{\pIdxpl}[1][]{\Glspl[textformat=primary,format=primaryloc,#1]}

\newcommand{\idx}{\gls}
\newcommand{\idxpl}{\glspl}
\newcommand{\Idx}{\Gls}
\newcommand{\Idxpl}{\Glspl}

\glsxtrnewgls{ext.}{\ext}

\newcommand*{\iext}[1]{%
 \glsxtrtitleorpdforheading{\idx{ext.#1}}{.#1}{\extfmt{#1}}%
}

\newcommand{\sty}{\gls}

\newcommand*{\isty}[1]{%
  \texorpdfstring{\idx{#1}}{#1}%
}

\newcommand*{\env}[1]{%
  \texorpdfstring{\idx{env.#1}}{#1}%
}

\newcommand*{\abbrstyle}[2][]{%
  \texorpdfstring{\idx[#1]{abbrstyle.#2}}{#2}%
}

\newcommand*{\glostyle}[1]{%
  \texorpdfstring{\idx{glostyle.#1}}{#1}%
}

\newcommand*{\catattr}[1]{%
  \texorpdfstring{\idx{catattr.#1}}{#1}%
}

\newcommand*{\counter}[1]{%
  \texorpdfstring{\idx{ctr.#1}}{#1}%
}

\newcommand*{\styopt}[2][]{%
  \texorpdfstring%
  {%
    \gls{styopt.#2}\styoptfmt{\ifblank{#1}{}{\dequals\marg{#1}}}%
  }%
  {#2\ifblank{#1}{}{=#1}}%
}

\newcommand*{\keyvallist}{%
 \texorpdfstring
 {key\dequals value list}%
 {key=value list}%
}

\newcommand{\nosecformatdef}[1]{%
  \begin{definition}
   \gls[format=primaryloc]{#1}%
   \glsentryuseri{#1}%
  \end{definition}\ignorespaces
}

\newcommand*{\cs}{\gls}

\newcommand*{\ics}[1][]{\cs[noindex=false,#1]}

\newcommand*{\icswithargs}[2][]{\cs{#2}\glsentryuseri{#2}}

\newcommand*{\postdeschook}[2][]{%
 \glslink[#1]{idx.glsxtrpostdesccategory}{\csfmt{glsxtrpostdesc#2}}}

\newcommand*{\postlinkhook}[2][]{%
 \glslink[#1]{idx.glsxtrpostlinkcategory}{\csfmt{glsxtrpostlink#2}}}


\glsxtrnewgls{file.}{\exfile}

\newcommand*{\csopt}[2][]{\gencsopt{#1}{opt}{#2}}%
\newcommand*{\glsopt}[2][]{\gencsopt{#1}{gls}{#2}}%
\newcommand*{\glsaddopt}[2][]{\gencsopt{#1}{glsadd}{#2}}%
\newcommand*{\printglossopt}[2][]{\gencsopt{#1}{printgloss}{#2}}%

\newcommand*{\gencsopt}[3]{%
  \texorpdfstring%
  {%
    \gls{#2.#3}%
    \csoptfmt{\ifblank{#1}{}{\dequals\marg{#1}}}%
  }%
  {#3\ifblank{#1}{}{=#1}}%
}

\newcommand*{\field}[1]{%
 \texorpdfstring
 {\gls{field.#1}}%
 {#1}%
}

\newcommand*{\atentry}[2][]{%
 \texorpdfstring
 {\gls[#1]{entry.#2}}%
 {#2}%
}

\newrobustcmd{\longswitch}{\string-{}\string-}

\newcommand*{\shortargfmt}[1]{%
 \texorpdfstring{\texttt{\string-#1}}%
 {\string-#1}%
}

\newcommand*{\longarg}[1]{%
  \texorpdfstring
  {\gls{switch.#1}}%
  {\string-\string-#1}%
}

\definecolor{defbackground}{rgb}{1,1,0.75}

\newsavebox\borderedboxcontents
\newlength\borderedboxwidth

\newenvironment{definition}%
{%
  \setlength{\fboxsep}{4pt}\setlength{\fboxrule}{1.25pt}%
  \begin{lrbox}{\borderedboxcontents}%
   \setlength\borderedboxwidth\linewidth
   \addtolength\borderedboxwidth{-2\fboxrule}%
   \addtolength\borderedboxwidth{-2\fboxsep}%
   \begin{minipage}{\borderedboxwidth}
   \flushleft\ttfamily\ignorespaces
}%
{%
   \end{minipage}%
  \end{lrbox}\par\medskip\noindent
  \fcolorbox{black}{defbackground}{\usebox\borderedboxcontents}%
  \medskip\par\noindent
  \ignorespacesafterend
}

\newtcolorbox{important}{colback=red!5!white,colframe=red}

\newcommand*{\sectionref}[1]{section~\ref{#1}}
\newcommand*{\Sectionref}[1]{Section~\ref{#1}}

\newcommand{\doglossaryentry}[1]{%
  \glsxtrglossentry{#1} & \glsentrydesc{#1}\glspostdescription\\%
}
\newcounter{localglossary}
\newenvironment{localglossary}
{%
  \stepcounter{localglossary}%
  \renewcommand{\glolinkprefix}{\thelocalglossary.}%
  \GlsXtrStartUnsetBuffering*
}
{%
  \par
  \begin{tabular}{ll}
  \GlsXtrForUnsetBufferedList\doglossaryentry
  \end{tabular}
  \GlsXtrStopUnsetBuffering
  \par
}
\pagestyle{headings}

\newcommand{\glossarytitle}{Index}
\let\orgbibcite\bibcite
\renewcommand{\bibcite}[2]{}
\externaldocument{bib2gls}
\let\bibcite\orgbibcite

\newcommand{\addr}[1]{\\\href{https://www.#1/}{\nolinkurl{#1}}}
\title{\styfmt{glossaries-extra} and \bibgls: An Introductory Guide}
\author{Nicola Talbot\addr{dickimaw-books.com}}
\date{\DTMusedate{moddate}}

\makeatletter
\begingroup
 \renewcommand{\addr}[1]{}
 \let\texorpdfstring\@secondoftwo
 \DTMsetstyle{pdf}
 \protected@edef\x{\endgroup
   \noexpand\hypersetup{%
     pdfinfo={
       Title={\@title},
       Author={\@author},
       CreationDate={\DTMuse{creation}},
       ModDate={\DTMuse{moddate}},
     }%
   }%
 }\x

\makeatother

\begin{document}
\maketitle
\pagenumbering{alph}
\thispagestyle{empty}

\begin{abstract}
This document is an introductory guide to \bibgls\ and the
\sty{glossaries-extra} package to help you get started. For
further information, including more complex commands and settings,
see the main \bibgls\ user manual (\filefmt{bib2gls.pdf},
in the same directory as this document),
the \isty{glossaries-extra} user manual,
(distributed with the \sty{glossaries-extra}
package~\cite{glossaries-extra})
and the \isty{glossaries} user manual
(distributed with the \sty{glossaries} package~\cite{glossaries}).
See also the gallery~\cite{gallery} for examples.

The \sty{glossaries} package is the \emph{base} package. The 
\sty{glossaries-extra} package internally loads the \sty{glossaries} package 
and extends it, providing extra options or modifying the base
commands to increase flexibility. If you want to use \bibgls, you
must load \sty{glossaries-extra}, which provides the interface
required by \bibgls.
This document doesn't cover the other indexing methods described in
the base package. If you get an undefined control sequence or
unknown option error when trying out any of the examples here, check
that you are using the latest versions of \sty{glossaries},
\sty{glossaries-extra} and \bibgls.
\end{abstract}

\clearpage
\pagenumbering{roman}
\tableofcontents

\clearpage
\pagenumbering{arabic}

\chapter{Introduction}
\label{sec:beginintro}

The \sty{glossaries} package provides a way of defining terms,
notation or abbreviations that can then be used in the document.
This ensures consistent naming and formatting. (With the help of the
\sty{hyperref} package, it's also possible to create hyperlinks from
the reference to a place in the document that provides a definition
of the term, but more about that later.) Each entry (term,
notation or abbreviation) is defined using:
\nosecformatdef{newglossaryentry}
Here's a simple example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\ics{usepackage}\marg{glossaries}
\strut
\gls{newglossaryentry}\marg{duck}\comment{label}
\marg{\comment{ information about this term:}
  \field{name}=\marg{duck},\comment{ display name}
  \field{description}=\marg{a waterbird with webbed feet}\comment{description}
}
\strut
\gls{newglossaryentry}\marg{goose}\comment{ label}
\marg{\comment{information about this term:}
  \field{name}=\marg{goose},\comment{display name}
  \field{plural}=\marg{geese},\comment{plural form}
  \field{description}=\marg{a large waterbird with a long neck, short legs,
   webbed feet and a short broad bill}
}
\strut
\cmd{begin}\marg{document}
The pond contained a \gls{gls}\marg{duck} (\gls{glsentrydesc}\marg{duck}) and 
a \gls{gls}\marg{goose} (\gls{glsentrydesc}\marg{goose}). \gls{Glspl}\marg{duck} and 
\gls{glspl}\marg{goose} are fowl.
\cmd{end}\marg{document}
\end{codeenv}
The resulting text is:
\begin{result}
The pond contained a \gls{ex1.duck} (\glsentrydesc{ex1.duck}) and 
a \gls{ex1.goose} (\glsentrydesc{ex1.goose}). \Glspl{ex1.duck} and
\glspl{ex1.goose} are fowl.
\end{result}
For convenience, the text produced by commands such as \cs{gls} is called the 
\pidx{link-text} (even if there are no hyperlinks).

The first argument of \gls{newglossaryentry} is a label that
uniquely identifies the term (see \sectionref{sec:labels}). The
second argument is a comma-separated list of
\meta{setting}\dequals\meta{value} assignments.  Each \meta{setting}
is referred to as a \qt{key} in the \isty{glossaries} manual or as a
\qt{field} in the \bibgls\ manual. A list of the available base keys
can be found in the \isty{glossaries} user manual.  The
\isty{glossaries-extra} package provides some additional keys that
are described in the \sty{glossaries-extra} manual. The \bibgls\
user manual summarises all keys (fields) in \sectionref{sec:fields}.

The term \qt{field} not only includes the keys that may be used with
\gls{newglossaryentry} but also internal labels (which may or may
not have a corresponding key) that are used to store information.
Note that there are some fields that may be used in the document
that are considered internal fields by \bibgls\ because the field
value is typically set as a by-product of the way that \bibgls\
works. If these fields are set manually then you may get unexpected
results as this can break \bibgls's normal operation.

\begin{important}
If the field value contains commas or equal signs the value must be grouped
to hide those characters from the \meta{key}\dequals\meta{value} parser.
When using \bibgls, the field value must be delimited according to
the \ext{bib} file format.
\end{important}

The two main keys are \field{name} and \field{description}. The
\field{name} identifies how the term should be displayed in the
glossary (see \sectionref{sec:displaygloss}). It also provides the
default singular term, if not explicitly given. The default plural
is obtained by appending \qt{s} to the singular form. If this isn't
correct (as with \qt{geese}), then the plural form can be specified
with the \field{plural} key.

The description (set with the \field{description} key) is usually
only displayed in the glossary, but you can display it in the text
using:
\nosecformatdef{glsentrydesc}
as in the above example. This simply expands to the value of the
\field{description} field (or does nothing if there's no entry
associated with the given label).

The main command used to reference a term is:
\nosecformatdef{gls}
In the above example, \gls{gls} just displays the singular form, but you
can provide alternative text to use the first time a term is
referenced (see \sectionref{sec:firstuse}). The plural form is obtained with
the \pidx{variant} command:
\nosecformatdef{glspl}
There are other \idxpl{variant} of \gls{gls} that perform
\glslink{case-change}{case-changing}.
If you want to start a sentence with an entry then you can use:
\nosecformatdef{Gls}
for the singular form and
\nosecformatdef{Glspl}
for the plural form. For all capitals, use:
\nosecformatdef{GLS}
for the singular form and
\nosecformatdef{GLSpl}
for the plural form. Any mention of \gls{gls} and its
\idxpl{variant} in this guide or in the user manuals means that the
comments applied to \gls{gls} also apply to the plural and
case-changing versions.

The \meta{insert} optional argument is provided to insert additional material.
For example:
\begin{codeenv}
The \gls{gls}\marg{goose} liked the \gls{gls}\marg{duck}['s] hat.
\end{codeenv}
which produces (assuming the above definitions):
\begin{result}
The \gls{ex1.goose} liked the \gls{ex1.duck}['s] hat.
\end{result}
In some cases, there may not be a noticeable difference between the
above and the following:
\begin{codeenv}
The \gls{gls}\marg{goose} liked the \gls{gls}\marg{duck}'s hat.
\end{codeenv}
It depends on other settings, such as whether or not hyperlinks have
been enabled. (The inserted material is commonly moved inside the
hyperlink.) Take care if you need a literal open square bracket
following \code{\cs{gls}\margm{label}} as you need to prevent it from being
interpreted as the optional \meta{insert} argument. For example:
\begin{codeenv}
The \gls{gls}\marg{goose} liked the \gls{gls}\marg{duck}\marg{['s]} hat.
\end{codeenv}
which now produces:
\begin{result}
The \gls{ex1.goose} liked the \gls{ex1.duck}{['s]} hat.
\end{result}
An alternative in this case could be to define:
\begin{codeenv}
\cmd{newcommand}*\marg{\cmd{missing}}[1]\marg{[\gls*{param}1]}
\end{codeenv}
and then use:
\begin{codeenv}
The \gls{gls}\marg{goose} liked the \gls{gls}\marg{duck}\cmd{missing}\marg{'s} hat.
\end{codeenv}
This conveniently hides the open square bracket from \cs{gls}.

\begin{important}
Commands like \gls{gls} are \idx{robust}. Commands like
\gls{glsentrydesc} are \idx{expandable}. (See \sectionref{sec:robust}.)
If you want the entry to appear in a PDF bookmark, you need to use an 
expandable command to reference it.
\end{important}

There are some helper commands that internally use
\gls{newglossaryentry}, such as \cs{newabbreviation} (described in
\sectionref{sec:abbreviations}) and \cs{glsxtrnewsymbol} (described
in \sectionref{sec:symbols}). If the description contains explicit paragraph
breaks then:
\nosecformatdef{longnewglossaryentry}
is required instead.

\section{Labels}
\label{sec:labels}

The label used to identify the entry can't contain any special characters, such
as \gls{commentchar} (percent), \gls{ampchar} (ampersand), \gls{param} (hash),
\gls{mshiftchar} (dollar), or \gls{nbspchar} (tilde).  Be careful of packages
that make other characters active (such as \isty{babel} with its shortcuts). If
you are using \isty{inputenc}, this also includes extended Latin characters and
characters from other scripts. If you want to include UTF-8 characters in the
label then you must use a \TeX\ engine with native Unicode support (that is,
\XeLaTeX\ or \LuaLaTeX).

For example, with no UTF-8 support (not even \sty{inputenc}):
\begin{codeenv}
\gls{newglossaryentry}\marg{elite}\comment{label (no UTF-8 support)}
\marg{
  \field{name} = \marg{\marg{\gls{acute}e}lite},
  \field{description} = \marg{group of people regarded as
  the best of a particular society or organisation}
}
\end{codeenv}
or with \sty{inputenc}:
\begin{codeenv}
\gls{newglossaryentry}\marg{elite}\comment{label (UTF-8 not natively supported)}
\marg{
  \field{name} = \marg{élite},
  \field{description} = \marg{group of people regarded as
  the best of a particular society or organisation}
}
\end{codeenv}
Whereas with \XeLaTeX\ or \LuaLaTeX\ you can do:
\begin{codeenv}
\gls{newglossaryentry}\marg{élite}\comment{label (UTF-8 natively supported)}
\marg{
  \field{name} = \marg{élite},
  \field{description} = \marg{group of people regarded as
  the best of a particular society or organisation}
}
\end{codeenv}

You may have noticed the grouping of the initial (accented) letter
in the \gls{ASCII} example (\code{\marg{\gls{acute}e}lite}). This is
necessary to ensure that the first-letter case-changing commands,
such as \ics{Gls}, work. It also used to be required around the
\qtt{é} with \sty{inputenc}, but if you have up-to-date versions of
\sty{glossaries} and \sty{datatool} then it should no longer be
necessary. No special treatment is needed with \XeLaTeX\ or
\LuaLaTeX\ where \qtt{é} is a single token.

If you can't use extended characters in the label (because you're
not using \XeLaTeX\ or \LuaLaTeX), then simply stripping the accents
to create an \gls{ASCII} alternative may be sufficient, but take
care if this may cause a conflict. For example:
\begin{codeenv}
\gls{newglossaryentry}\marg{resume}\comment{label}
\marg{
  \field{name} = \marg{resume},
  \field{description} = \marg{continue after an interruption}
}
\strut
\gls{newglossaryentry}\marg{resumee}\comment{label}
\marg{
  \field{name} = \marg{r\gls{acute}esum\gls{acute}e},
  \field{description} = \marg{summary of something or curriculum vitae}
}
\end{codeenv}
For languages that use a non-Latin script, if you can't or don't
want to use \XeLaTeX\ or \LuaLaTeX, then you need to decide the most
appropriate \gls{ASCII} naming scheme.
For example:
\begin{codeenv}
\gls{newglossaryentry}\marg{goose}\comment{using translation for label}
\marg{
  \field{name} = \marg{\textcyrillicmono{гусь}},
  \field{plural} = \marg{\textcyrillicmono{гуси}},
  \field{description} = \marg{\textnormal{\ldots}}
}
\end{codeenv}
or
\begin{codeenv}
\gls{newglossaryentry}\marg{hus}\comment{using closest ASCII match for label}
\marg{
  \field{name} = \marg{\textcyrillicmono{гусь}},
  \field{plural} = \marg{\textcyrillicmono{гуси}},
  \field{description} = \marg{\textnormal{\ldots}}
}
\end{codeenv}

In addition to labels identifying entries, there are also labels
that identify other things, such as a glossary, category or letter
group. The same restrictions apply to those labels.

\section{First Use}
\label{sec:firstuse}

Each entry has a \pidx{firstuseflag} (boolean variable) that
determines whether or not the entry has been referenced in the
document.  Commands like \gls{gls} and \gls{glspl} change the flag
to indicate that the entry has been used. Commands like
\gls{glsentrydesc} don't. Here's a modification of the earlier
example document that provides different versions depending on 
whether or not the entry has already been referenced:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries}
\strut
\gls{newglossaryentry}\marg{duck}\comment{label}
\marg{\comment{information about this term:}
  \field{name}   = \marg{Duck (noun)},\comment{display name}
  \field{first}  = \marg{duck (quack, quack)},\comment{first use singular}
  \field{firstplural} = \marg{ducks (quack, quack)},\comment{first use plural}
  \field{text}   = \marg{duck},\comment{subsequent use singular}
  \field{description} = \marg{a waterbird with webbed feet}\comment{description}
}
\strut
\gls{newglossaryentry}\marg{goose}\comment{label}
\marg{\comment{information about this term:}
  \field{name}   = \marg{Goose (noun, pl.\ geese)},\comment{display name}
  \field{first}  = \marg{goose (honk, honk)},\comment{first use singular}
  \field{firstplural} = \marg{geese (honk, honk)},\comment{first use plural}
  \field{text}   = \marg{goose},\comment{subsequent use singular}
  \field{plural} = \marg{geese},\comment{subsequent use plural}
  \field{description}=\marg{a large waterbird with a long neck, short legs,
   webbed feet and a short broad bill}
}
\strut
\cmd{begin}\marg{document}
The pond contained a \gls{gls}\marg{duck}\cmd{footnote}\marg{\gls{glsentryname}\marg{duck}:
\gls{glsentrydesc}\marg{duck}} and two 
\gls{glspl}\marg{goose}\cmd{footnote}\marg{\gls{glsentryname}\marg{goose}: 
\gls{glsentrydesc}\marg{goose}}. \gls{Glspl}\marg{duck} and \gls{glspl}\marg{goose} are fowl.
\cmd{end}\marg{document}
\end{codeenv}
This now produces:
\begin{result}
The pond contained a \gls{ex2.duck}\footnote{\glsentryname{ex2.duck}:
\glsentrydesc{ex2.duck}} and two
\glspl{ex2.goose}\footnote{\glsentryname{ex2.goose}: 
\glsentrydesc{ex2.goose}}. \Glspl{ex2.duck} and \glspl{ex2.goose} are fowl.
\end{result}
This uses:
\nosecformatdef{glsentryname}
which works in a similar way to \gls{glsentrydesc}. In this case,
\gls{glsentryname} simply expands to the value of the \field{name}
key. There's also a case-changing version:
\nosecformatdef{Glsentryname}
which changes the initial character to \idx{uppercase},
but (unlike \cs{glsentryname}) this command isn't expandable. If,
for example, I had instead set the duck's \field{name} key using:
\begin{codeenv}
\field{name} = \marg{duck (noun)}
\end{codeenv}
then I would need to use \code{\gls{Glsentryname}\marg{duck}}
instead.

So on \pidx{firstuse}, \cs{gls} uses the value of the \field{first} key
and \cs{glspl} uses the value of the \field{firstplural} key. On
\pidx{subsequentuse}, \cs{gls} uses the value of the \field{text} key and
\cs{glspl} uses the value of the \field{plural} key. \pIdx{regular}
abbreviations also follow this usage. \pIdx{non-regular}
abbreviations follow a different behaviour for \gls{gls} (and its
\idxpl{variant}) that's determined by the abbreviation style.

If the first use for a particular group of terms always has the
same pattern (such as following the term with a brief description or
alternative representation), then it's simpler to use one of the
automated methods provided, such as the abbreviation mechanism
(\sectionref{sec:abbreviations}) or changing the formatting
(\sectionref{sec:glsformats}).

You can test if an entry has been used with:
\nosecformatdef{ifglsused}
This requires that the entry (identified by \meta{label}) is
defined. If it isn't then neither \meta{true} nor \meta{false} is
done and an error or warning occurs. Otherwise, the command will do
\meta{true} if the entry has been used or \meta{false} if the entry
hasn't been used.

When using \bibgls, entries are never defined on the first \LaTeX\
run, so you may instead prefer:
\nosecformatdef{GlsXtrIfUnusedOrUndefined}
which does \meta{true} if either the entry hasn't been defined or
hasn't been marked as used, otherwise it does \meta{false}.

Neither \gls{ifglsused} nor \gls{GlsXtrIfUnusedOrUndefined} should
occur in the \idx{postlinkhook} (described later) as the entry will have already
been used by that point. Instead, you need \gls{glsxtrifwasfirstuse} 
(see \sectionref{sec:postlinkhooks}).

\section{Categories}
\label{sec:categories}

The \isty{glossaries-extra} extension package provides the
\field{category} key, which isn't available with just the base
\sty{glossaries} package. The value of this key must be a
label as it's used to construct command names. You can choose
whatever label you like (as long as it conforms to the valid
labelling scheme, described in \sectionref{sec:labels}). If you
don't specify a category, then \gls{newglossaryentry} and
\gls{longnewglossaryentry} assume \code{general}. The helper
commands, such as \gls{newabbreviation}, have different defaults.

For example:
\begin{codeenv}
\gls{newglossaryentry}\marg{amethyst}
\marg{
   \field{name} = \marg{amethyst},
   \field{description} = \marg{a purple type of quartz},
   \field{category} = \marg{mineral}
}
\end{codeenv}
The value of the \field{category} field for a given entry can be obtained
with:
\nosecformatdef{glscategory}
where \meta{label} identifies the entry. This command is expandable
and does nothing if the entry hasn't been defined. You can test the
value of the \field{category} field using:
\nosecformatdef{glsifcategory}
This checks if the \field{category} field for the entry given by
\meta{label} is set to \meta{category}, but doesn't perform any
expansion of \meta{category}. It generates an error if the entry
doesn't exist (or warning with \styopt[warn]{undefaction}).

The category allows you to apply certain types of formatting, such
as the \idx{postlinkhook} (\sectionref{sec:postlinkhooks}).
For abbreviations, the category also governs the abbreviation style (see
\sectionref{sec:abbreviations}) and can be used for filtering.
Categories may be assigned \pidxpl{attribute} that can also be used
to modify formatting or styles. 

Unlike the \idx{postlinkhook}, which
needs to be defined before an entry is \emph{used} (with commands like
\gls{gls}), some \idxpl{attribute} need to be set before the entry
is \emph{defined}, so it's best to set them up as soon as possible in the
preamble (after loading \sty{glossaries-extra}).

\section{Adding Extra Information}
\label{sec:userkeys}

In addition to the \field{name} and \field{description} keys,
there's also a \field{symbol} key which allows you to store an
associated symbol. The value can be obtained with:
\nosecformatdef{glssymbol}
(which is robust and recognises the \idx{postlinkhook}) or with:
\nosecformatdef{glsentrysymbol}
(which behaves like \gls{glsentrydesc} and \gls{glsentryname}).
Neither of the above commands affect the \idx{firstuseflag}.
For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}[hidelinks]\marg{hyperref}
\cmd{usepackage}\marg{glossaries}
\strut
\gls{newglossaryentry}\marg{pi}\comment{label}
\marg{\comment{settings:}
   \field{name}   = \marg{Archimedes' constant},
   \field{symbol} = \marg{\gls[noindex=false]{ensuremath}\marg{\cmd{pi}}},
   \field{description} = \marg{ratio of a circle's circumference to its 
diameter}
}
\strut
\gls{newglossaryentry}\marg{thetai}\comment{label}
\marg{\comment{settings:}
   \field{name}   = \marg{theta parameter},
   \field{symbol} = \marg{\gls{ensuremath}\marg{\cmd{theta}\gls{sbchar}i}},
   \field{description} = \marg{one of the model parameters}
}
\strut
\cmd{begin}\marg{document}
\gls{gls}\marg{pi} (\gls{glssymbol}\marg{pi}). Compare \gls{mshiftchar}\gls{glssymbol}\marg{thetai}\gls[noindex=false]{spchar}2\gls{mshiftchar}
with \gls{mshiftchar}\gls{glssymbol}\marg{thetai}[\gls{spchar}2]\gls{mshiftchar}.
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
\gls{ex.pi} (\glssymbol{ex.pi}). Compare $\glssymbol{ex.thetai}^2$
with $\glssymbol{ex.thetai}[^2]$.
\end{result}
Note that in this case there is now a difference between using the
final optional \meta{insert} argument and simply appending the extra
material. This is a result of the hyperlink that causes an
interruption between the subscript \code{\gls{sbchar}i} and the following
superscript \code{\gls{spchar}2}. (In this case, there's no target for the
hyperlinks. That's covered in \sectionref{sec:displaygloss}.)

If you have additional information, such as a translation,
associated image or citation, then you can supply this with the six
user keys:
\field{user1}\glsaddeach{field.user2,field.user3,field.user4,field.user5}, 
\ldots, \field{user6}. The value of the
first field (\field{user1}) can be obtained with:
\nosecformatdef{glsuseri}
(which behaves like \gls{glssymbol}) or with:
\nosecformatdef{glsentryuseri}
(which behaves like \gls{glsentrysymbol}).
\glsaddeach{glsuserii,glsuseriii,glsuseriv,glsuserv,%
glsentryuserii,glsentryuseriii,glsentryuseriv,glsentryuserv}%
The other fields are similarly obtained using \idx{lowercase} Roman
numerals, so value of the sixth field (\field{user6}) can be obtained with:
\nosecformatdef{glsuservi}
(which behaves like \gls{glssymbol}) or with:
\nosecformatdef{glsentryuservi}
(which behaves like \gls{glsentrysymbol}).
For example:
\begin{codeenv}
\gls{newglossaryentry}\marg{polly.parrot}\comment{label}
\marg{\comment{}
   \field{name} = \marg{Polly Parrot},
   \field{description} = \marg{Senior assistant at the International Society 
of Duck and Geese},
   \field{user1} = \marg{British},\comment{nationality}
   \field{user2} = \marg{1970-12-31},\comment{date of birth}
   \field{user3} = \marg{female},\comment{gender}
   \field{user4} = \marg{43 The Lane, Some Town, Noshire AB1 2XY},\comment{address}
   \field{user5} = \marg{polly.parrot@example.com}\comment{email}
}
\end{codeenv}

Alternatively you can define your own custom keys. If you don't need
commands equivalent to \gls{glssymbol}, then you can use:
\nosecformatdef{glsaddstoragekey}
where \meta{key} is the name of the new key, \meta{default value} is
the default value if the key isn't explicitly set and \meta{no link
cs} is the name of the command to access the field value (equivalent
to \gls{glsentrysymbol}). If you want commands equivalent to
\gls{glssymbol} that have the \meta{options} and \meta{insert}
optional arguments and obey the \idx{postlinkhook}, then use
\nosecformatdef{glsaddkey}
The first three arguments are as for \gls{glsaddstoragekey}.
The next argument \meta{no link ucfirst cs} is like \meta{no link
cs} but converts the first letter to \idx{uppercase} (analogous to
\gls{Glsentryname}). The final three commands behave like
\gls{glssymbol}, but \meta{link ucfirst cs} converts the first
letter to \idx{uppercase} and \meta{link allcaps cs} converts the entire
value to \idx{uppercase}.

The new keys must be provided before the entries are defined (and
the key definitions must come before the first \idx{resourceset}
if you use \bibgls). For example:
\begin{codeenv}
\gls{glsaddstoragekey}\marg{\fieldfmt{nationality}}\marg{}\marg{\cmd{Nationality}}
\gls{glsaddstoragekey}\marg{\fieldfmt{dateofbirth}}\marg{}\marg{\cmd{DateOfBirth}}
\gls{glsaddstoragekey}\marg{\fieldfmt{gender}}\marg{}\marg{\cmd{Gender}}
\gls{glsaddstoragekey}\marg{\fieldfmt{address}}\marg{}\marg{\cmd{Address}}
\gls{glsaddstoragekey}\marg{\fieldfmt{email}}\marg{}\marg{\cmd{Email}}
\gls{newglossaryentry}\marg{polly.parrot}\comment{label}
\marg{\comment{}
   \field{name} = \marg{Polly Parrot},
   \field{description} = \marg{Senior assistant at the International Society 
of Duck and Geese},
   \fieldfmt{nationality} = \marg{British},\comment{nationality}
   \fieldfmt{dateofbirth} = \marg{1970-12-31},\comment{date of birth}
   \fieldfmt{gender}  = \marg{female},\comment{gender}
   \fieldfmt{address} = \marg{43 The Lane, Some Town, Noshire AB1 2XY},\comment{address}
   \fieldfmt{email}   = \marg{polly.parrot@example.com}\comment{email}
}
\end{codeenv}

In addition to the commands like \gls{glssymbol} and
\gls{glsentrysymbol}, there are other ways of accessing the field
value or checking if the field has been set. In the commands listed
below, the field label is the \emph{internal} label. In some cases,
this is the same as the key, but there are a few that have a
different internal label. See Table~\ref*{tab:internalfields} in the
\bibgls\ user manual or Table~4.1 in the \sty{glossaries} user
manual~\cite{glossaries}. Custom fields provided with
\gls{glsaddkey} or \gls{glsaddstoragekey} have matching key and
internal field labels.

The \sty{glossaries-extra} package provides a generic way of
accessing a field, analogous to commands like \gls{glsentryname}:
\nosecformatdef{glsxtrusefield}
This expands to the field value if defined or does nothing if the
entry or field isn't defined.

The base \sty{glossaries} package provides:
\nosecformatdef{ifglshassymbol}
which tests if the \field{symbol} field has been assigned. There are similar 
commands for other common fields. For a more general purpose test, you 
can use:
\nosecformatdef{ifglshasfield}
which checks if the given entry (identified by \meta{entry label}, 
which must be defined) has the field identified by \meta{field label}
set to a non-empty value. Within \meta{true}, you can access the
field value with:
\nosecformatdef{glscurrentfieldvalue}
The \sty{glossaries-extra} package provides a similar command:
\nosecformatdef{glsxtrifhasfield}
which doesn't test if the entry exists. The unstarred form adds
implicit grouping around \meta{true} or \meta{false} (allowing
nested use). The starred form \gls{glsxtrifhasfield*} doesn't. 
You can compare the field value with a string using:
\nosecformatdef{GlsXtrIfFieldEqStr}
If you need the string to be (protected) fully expanded before
comparison, you need:
\nosecformatdef{GlsXtrIfFieldEqXpStr}
If you additionally need the field value (protected) fully expanded
before comparison, use:
\nosecformatdef{GlsXtrIfXpFieldEqXpStr}
For a complete list of field commands, see the
\sty{glossaries-extra} user manual~\cite{glossaries-extra}.

The earlier \code{duck} and \code{goose} examples from 
\sectionref{sec:firstuse} can be rewritten to move the parenthetical
material into separate keys:
\begin{codeenv}
\gls{newglossaryentry}\marg{duck}\comment{label}
\marg{\comment{information about this term:}
  \field{name}   = \marg{duck},
  \field{user1}  = \marg{noun},
  \field{user2}  = \marg{quack, quack},
  description = {a waterbird with webbed feet}
}
\strut
\gls{newglossaryentry}\marg{goose}\comment{label}
\marg{\comment{information about this term:}
  \field{name}   = \marg{goose},
  \field{plural} = \marg{geese},
  \field{user1}  = \marg{noun},
  \field{user2}  = \marg{honk, honk},
  \field{description}=\marg{a large waterbird with a long neck, short legs,
   webbed feet and a short broad bill}
}
\end{codeenv}
The \idx{postlinkhook} and glossary style can then be modified to 
include the additional information.  For example:
\begin{codeenv}
\gls[noindex=false]{glsdefpostlink}\marg{general}\marg{\comment{post-link hook}
 \gls[noindex=false]{glsxtrifwasfirstuse}\marg{\cmd{space}(\gls{glsentryuserii}\marg{\gls{glslabel}})}{}\comment{}
}
\strut
\gls[noindex=false]{glssetcategoryattribute}\marg{general}\marg{glossname}\marg{firstuc}
\strut
\gls[noindex=false]{glsdefpostname}\marg{general}\marg{\comment{post-name hook}
 \cmd{space}
 (\gls{glsentryuseri}\marg{\gls[noindex=false]{glscurrententrylabel}}\comment{}
  \gls{GlsXtrIfXpFieldEqXpStr}\marg{plural}\marg{\gls{glscurrententrylabel}}\comment{}
  \marg{\gls[noindex=false]{glsentrytext}\marg{\gls{glscurrententrylabel}}s}\marg{}\comment{}
  \marg{, pl.\gls{cs.space}\gls[noindex=false]{glsentryplural}{\gls{glscurrententrylabel}}}\comment{}
 )\comment{}
}
\end{codeenv}
The \idx{postlinkhook} appends the value of the \field{user2} field
after the \idx{firstuse} of \gls{gls} (or its \idxpl{variant}).
The \catattr{glossname} attribute is set to \code{firstuc}, which
converts the first letter of the \field{name} field to
\idx{uppercase} when it's displayed in the glossary.  The
\idx{postnamehook} appends (in parentheses) the value of the
\field{user1} field and then checks if the plural form is the same
as the singular form with \qt{s} appended, and only displays the
plural if they are different. See \sectionref{sec:glsformats} and
\sectionref{sec:displaygloss} for further details.

\section{Accessibility Support}
\label{sec:accsupp}

The base \sty{glossaries} package is distributed with the
supplementary \sty{glossaries-accsupp} package, which uses the
\sty{accsupp} package~\cite{accsupp} to provide accessibility support. With the
\sty{glossaries-extra} extension package, the
\sty{glossaries-accsupp} package needs to be loaded after \sty{glossaries}
but before \sty{glossaries-extra} sets up the accessibility
integration support. The simplest way to do this is with
\sty{glossaries-extra}'s \styopt{accsupp} package option.

The accessibility support is provided through the PDF
\code{ActualText} specification (via the \sty{accsupp} package). 
If you need \code{E} or \code{Alt} instead of \code{ActualText} then redefine:
\nosecformatdef{glsaccsupp}
as appropriate. For example:
\begin{codeenv}
\cmd{renewcommand}*\marg{\gls{glsaccsupp}}[2]\marg{\comment{}
  \cmd{BeginAccSupp}\marg{Alt=\marg{\gls{param}1}}\gls{param}2\cmd{EndAccSupp}\marg{}\comment{}
}
\end{codeenv}

The \sty{glossaries-accsupp} package provides additional keys (see
Table~\ref{tab:accsuppfields} in the \bibgls\ user manual or
Chapter~18 of the \sty{glossaries} user manual~\cite{glossaries}).
The main keys are \field{access}, which provides an alternative to
the \field{name} field, \field{symbolaccess}, which provides an
alternative to the \field{symbol} field and \field{shortaccess},
which provides an alternative to the \field{short} field,
\field{firstaccess}, which provides an alternative to the
\field{first} field, and \field{textaccess}, which provides an
alternative to the \field{text} field. If any of the accessibility
fields are unset, no accessibility support is provided for that
field.
For example:
\begin{codeenv}
\gls{newglossaryentry}\marg{R}\comment{label}
\marg{\comment{settings:}
 \field{name}        = \marg{\cmd{ensuremath}\marg{\cmd{Re}}},
 \field{access}      = \marg{set of real numbers symbol},\comment{name access}
 \field{textaccess}  = \marg{set of real numbers},\comment{text access}
 \field{firstaccess} = \marg{set of real numbers},\comment{first access}
 \field{description} = \marg{set of real numbers}
}
\end{codeenv}
This means that when the \field{name} field is displayed in the
glossary, the corresponding accessibility text is \qt{set of real
numbers symbol}, but the \idx{link-text} for \gls{gls} is just
\qt{set of real numbers} (for both \idx{firstuse} and subsequent
use).

There are some category attributes that govern the default settings
of some fields when using \gls{newabbreviation} (see
\sectionref{sec:abbreviations}). If accessibility support is
provided, there are some additional attributes (introduced to
\sty{glossaries-extra} version 1.31):
\begin{description}
\item[\catattr{accessinsertdots}] This is a boolean attribute that behaves like
\catattr{insertdots} but only applies to the \field{shortaccess}
field, if it hasn't explicitly been set. This is useful for
initialisms that should be read out as letters but the screen reader
might interpret as a word. For example:
\begin{codeenv}
\gls{glssetcategoryattribute}\marg{initialism}\marg{\catattr{accessinsertdots}}\marg{true}
\gls{newabbreviation}\oarg{\field{category}=initialism}\marg{pi}\marg{PI}\marg{Private Investigator}
\end{codeenv}
This means that the short form appears as just \qt{PI} in the
document text, but the accessibility text is \qt{P.I.} which prompts
the screen reader to read it as an abbreviation instead of the word
\qt{pi}. Since the \field{shortaccess} field is an aid to the screen
reader and doesn't modify the visible text, there's no check
for the \catattr{retainfirstuseperiod} or \catattr{discardperiod}
attributes for that field. This setting doesn't affect the
accessibility support for the \field{name}, \field{first} or
\field{text} fields.

\item[\catattr{nameshortaccess}] This is a boolean attribute, where
the value \code{true} indicates the attribute is set. If the
\field{shortaccess} field is assigned (either explicitly with the key or
implicitly through the use of the \catattr{accessinsertdots}
attribute) and the \field{access} field isn't specified, then if the
\catattr{nameshortaccess} attribute is set this will copy the
\field{shortaccess} field to the \field{access} field. For example:
\begin{codeenv}
\gls{glssetcategoryattribute}\marg{initialism}\marg{\catattr{accessinsertdots}}\marg{true}
\gls{glssetcategoryattribute}\marg{initialism}\marg{\catattr{nameshortaccess}}\marg{true}
\gls{newabbreviation}\oarg{\field{category}=initialism}\marg{pi}\marg{PI}\marg{Private Investigator}
\end{codeenv}
Abbreviations that behave like regular terms (such as
\abbrstyle{short-nolong}) may also need \catattr{textshortaccess}
and \catattr{firstshortaccess} set.

\item[\catattr{textshortaccess}] Like \catattr{nameshortaccess}, but
applies to the \field{textaccess} field.

\item[\catattr{firstshortaccess}] Like \catattr{firstshortaccess}, but
applies to the \field{firstaccess} field.

\item[\catattr{accessaposplural}] If the \field{shortaccess} field
is set (either explicitly with the key or implicitly through the use
of the \catattr{accessinsertdots} attribute) and the
\field{shortpluralaccess} field isn't set, the
\catattr{accessaposplural} boolean attribute behaves like
\catattr{aposplural} but only applies to the
\field{shortpluralaccess} field. If the \catattr{accessaposplural}
attribute isn't set but the \catattr{aposplural} attribute is set,
then that's used instead. If you want \catattr{aposplural} on but
not apply it to \field{shortpluralaccess} then you need to set the
\catattr{accessaposplural} attribute to \code{false}.

\item[\catattr{accessnoshortplural}] A boolean attribute like
\catattr{accessaposplural} but analogous to \catattr{noshortplural}
instead.
\end{description}
These attributes have no effect for entries that aren't defined
using \gls{newabbreviation}. (These attributes apply to
\gls{newacronym} provided it internally uses \gls{newabbreviation},
which is does by default with \sty{glossaries-extra}.)

\section{Prefixes}
\label{sec:prefixes}

The \sty{glossaries} package is distributed with the supplementary
\sty{glossaries-prefix} package. This automatically loads
\sty{glossaries}, but if you are using \sty{glossaries-extra}, it's
best loaded after. This supplementary package supplies extra keys
and some commands analogous to \gls{gls}. The main purpose is to
provide a different prefix to \gls{gls}, depending on whether it's
the \idx{firstuse} or subsequent use. For example, if the
\idx{firstuse} starts with a vowel (or vowel sound), you may need \qt{an
\gls{gls}\margm{label}} but if the subsequent use starts with a
constant, you may need \qt{a \gls{gls}\margm{label}}. The prefix for
the \idx{firstuse} form is specified in the \field{prefixfirst}
field, and the prefix for the subsequent use form is specified in the
\field{prefix} field. If a space is required between the prefix and
\gls{gls}, this needs to be included, as the prefixing system allows
for prefixes like l' which shouldn't be followed by a space.

To include the prefix, use:
\nosecformatdef{pgls}
instead of \gls{gls}. For example:
\begin{codeenv}
\cmd{documentclass}\marg{book}
\strut
\cmd{usepackage}\marg{glossaries-extra}
\cmd{usepackage}\marg{glossaries-prefix}
\strut
\gls{newabbreviation}
 \oarg{\field{prefixfirst}=\marg{a\gls[noindex=false]{nbspchar}},\field{prefix}=\marg{an\cmd{space}}}
 \marg{svm}\marg{SVM}\marg{support vector machine}
\strut
\cmd{begin}\marg{document}
With a prefix: \gls{pgls}\marg{svm} or \gls{pgls}\marg{svm}.
Without a prefix: the \gls{gls}\marg{svm}.
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
With a prefix: a support vector machine (SVM) or an SVM. Without a
prefix: the SVM.
\end{result}

\section{Spaces}
\label{sec:spaces}

With \LaTeX\ in general, spaces are sometimes significant and
sometimes ignored. When defining entries, any spaces around the
equal sign or comma are ignored. For example, if an entry is defined
as
\begin{codeenv}
\gls{newglossaryentry}\marg{sample}
\marg{
  \field{name} = \marg{sample} , \field{description} = \marg{an example}
}
\end{codeenv}
then
\begin{codeenv}
/\gls{gls}\marg{sample}/
\end{codeenv}
will produce
\begin{result}
/sample/
\end{result}
(no spaces). Similarly with:
\begin{codeenv}
\gls{newglossaryentry}\marg{sample}
\marg{
  \field{name} = sample , \field{description} = \marg{an example}
}
\end{codeenv}
However, spaces at the start or end of the value that's provided as
an argument (rather than in a \keyvallist) often aren't ignored.

The unstarred version of \gls{longnewglossaryentry} appends extra code to the end of the
description, which removes any trailing spaces (and also the 
\gls{postdescriptionhook}). The starred version
\gls{longnewglossaryentry*} (only available with \sty{glossaries-extra}) 
doesn't. In both cases any leading spaces are retained. For example,
if the entry is defined as:
\begin{codeenv}
\gls{longnewglossaryentry}\marg{sample}\marg{name=\marg{sample}}\marg{ an example }\incorrect
\end{codeenv}
then:
\begin{codeenv}
/\gls{glsentrydesc}\marg{sample}/
\end{codeenv}
produces:
\begin{result}
/ an example/
\end{result}
(trailing space removed), whereas if the entry is defined as:
\begin{codeenv}
\gls{longnewglossaryentry*}\marg{sample}\marg{name=\marg{sample}}\marg{ an example }\incorrect
\end{codeenv}
then:
\begin{codeenv}
/\gls{glsentrydesc}\marg{sample}/
\end{codeenv}
produces:
\begin{result}
/ an example /
\end{result}
(leading and trailing spaces retained).

Spaces in labels are significant. For example, in \verb|\gls{ duck }|
the spaces are considered part of the label. If the entry was
actually defined without spaces in the label then the entry
referenced in \verb|\gls{ duck }| won't be found.

\section{Undefined References}
\label{sec:undefaction}

If an entry that hasn't been defined is referenced with \gls{gls},
by default an error is triggered. For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries}
\strut
\cmd{begin}\marg{document}
A \gls{gls}\marg{duck}.
\cmd{end}\marg{document}
\end{codeenv}
This produces the error:
\begin{verbatim}
Glossary entry `duck' has not been defined.
\end{verbatim}
If you instruct \LaTeX\ to ignore the error and continue, the result
is
\begin{result}
A .
\end{result}
The \sty{glossaries-extra} package provides the option
\styopt[warn]{undefaction}, which will convert the error to a
warning. For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}[\styopt{undefaction}=warn]\marg{glossaries-extra}
\strut
\cmd{begin}\marg{document}
A \gls{gls}\marg{duck}.
\cmd{end}\marg{document}
\end{codeenv}
This now produces the warning:
\begin{verbatim}
Glossary entry `duck' has not been defined on input line 6
\end{verbatim}
(There are also other warnings about an empty \code{main} glossary.)
The result is now:
\begin{result}
A ??.
\end{result}
This replaces the undefined reference with two question marks, just like 
undefined cross-references.
Notice the difference between using \gls{ifglshasfield}:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}[\styopt{undefaction}=warn]\marg{glossaries-extra}
\strut
\cmd{begin}\marg{document}
A \gls{gls}\marg{duck} 
(\gls{ifglshasfield}\marg{\gls[noindex=false]{field.useri}}\marg{duck}\marg{\gls{glscurrentfieldvalue}}\marg{not set}).
\cmd{end}\marg{document}
\end{codeenv}
which produces:
\begin{result}
A ?? (??).
\end{result}
(and has two undefined warnings) and using \gls{glsxtrifhasfield}:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}[\styopt{undefaction}=warn]\marg{glossaries-extra}
\strut
\cmd{begin}\marg{document}
A \gls{gls}\marg{duck}
(\gls{glsxtrifhasfield}\marg{\field{useri}}\marg{duck}\marg{\gls{glscurrentfieldvalue}}\marg{not set}).
\cmd{end}\marg{document}
\end{codeenv}
which only has one undefined warning and produces:
\begin{result}
A ?? (not set).
\end{result}

When you incorporate \bibgls\ into the build process (see
\sectionref{sec:bib2gls}), the first \LaTeX\ run doesn't have any 
entries defined. One of the actions that the \styopt{record} option 
automatically performs is to switch on \styopt[warn]{undefaction}, which avoids
undefined errors on the first \LaTeX\ run. For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}[\styopt{record}]\marg{glossaries-extra}
\strut
\cmd{begin}\marg{document}
A \gls{gls}\marg{duck}
(\gls{glsxtrifhasfield}\marg{\field{useri}}\marg{duck}\marg{\gls{glscurrentfieldvalue}}\marg{not set}).
\cmd{end}\marg{document}
\end{codeenv}
This produces the same result as the previous example, but there's
only the one warning (about an undefined reference) and no warning
about the empty \code{main} glossary.

\section{Robust, Fragile and Expandable Commands}
\label{sec:robust}

Commands like \gls{gls} are \pidx{robust}. This protects them from
premature expansion in situations that would otherwise break the
command. If content containing a \idx{robust} command is written to
an external file, the \idx{robust} command itself is written instead of its
definition. For example, consider the following document:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\cmd{newcommand}\marg{\csfmt{test}}\marg{some sample text}
\cmd{begin}\marg{document}
\gls{tableofcontents}
\gls[noindex=false]{section}\marg{\csfmt{test}}
\cmd{end}\marg{document}
\end{codeenv}
In this case, \csfmt{test} is expandable. Its definition doesn't
contain anything complicated. The \ext{toc} file (which is input by
\csfmt{tableofcontents}\glsadd{toc}) contains the line:
\begin{codeenv}
\cmd{contentsline} \marg{section}\marg{\cmd{numberline} \marg{1}some sample text}\marg{1}
\end{codeenv}
So \csfmt{test} has been expanded to its definition when it was
written to the \ext{toc} file. If \csfmt{test} is defined in terms
of another command, that will also be expanded. For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\cmd{newcommand}\marg{\csfmt{sample}}\marg{\gls{emph}\marg{sample}}
\cmd{newcommand}\marg{\csfmt{test}}\marg{some \csfmt{sample}\gls{cs.space}text}
\cmd{begin}\marg{document}
\gls{tableofcontents}
\gls{section}\marg{\csfmt{test}}
\cmd{end}\marg{document}
\end{codeenv}
The \ext{toc} file now contains:
\begin{codeenv}
\cmd{contentsline} \marg{section}\marg{\cmd{numberline} \marg{1}some \gls{emph} \marg{sample}\gls{cs.space}text}\marg{1}
\end{codeenv}
So \csfmt{sample} has also been expanded but neither
\gls{emph} nor \idx{cs.space} (backslash space) have
been expanded. \Idx{robust} commands don't expand. For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries}
\strut
\gls{newglossaryentry}\marg{duck}
\marg{
  \field{name}=\marg{duck},
  \field{description}=\marg{a waterbird with webbed feet}
}
\strut
\cmd{begin}\marg{document}
\gls{tableofcontents}
\gls{section}\marg{\gls{Gls}\marg{duck}: \gls{glsentrydesc}\marg{duck}}
\cmd{end}\marg{document}
\end{codeenv}
The \ext{toc} file now contains:
\begin{codeenv}
\cmd{contentsline} \marg{section}\marg{\cmd{numberline} \marg{1}\gls{Gls} \marg{duck}: a waterbird with 
webbed feet}\marg{1}
\end{codeenv}
So \gls{Gls} doesn't expand, and the command itself is written to the
\ext{toc} file, but \gls{glsentrydesc} does expand.

A \pidx{fragile} command is one that breaks (causes an error) when
it's expanded in this type of context. One such command is \gls{footnote}.
For example, the following won't work:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries}
\strut
\gls{newglossaryentry}\marg{duck}
\marg{
  \field{name}=\marg{duck},
  \field{description}=\marg{a waterbird with webbed feet}
}
\strut
\cmd{begin}\marg{document}
\gls{tableofcontents}
\gls{section}\marg{\gls{Gls}\marg{duck}\gls{footnote}\marg{\gls{glsentrydesc}\marg{duck}}}\incorrect
\cmd{end}\marg{document}
\end{codeenv}
This causes the error:
\begin{verbatim}
! Argument of \@sect has an extra }.
\end{verbatim}
Inserting \gls{protect} before the command prevents the attempted
expansion, which makes the command behave as though it was robust:
\begin{codeenv}
\gls{section}\marg{\gls{Gls}\marg{duck}\gls{protect}\gls{footnote}\marg{\gls{glsentrydesc}\marg{duck}}}
\end{codeenv}
In this case, it's unlikely that you'd want the footnote to appear
in the \gls{toc}, so it would be better to use the optional
argument:
\begin{codeenv}
\gls{section}\oarg{Duck}\marg{\gls{Gls}\marg{duck}\gls{footnote}\marg{\gls{glsentrydesc}\marg{duck}}}\correct
\end{codeenv}
Now the \ext{toc} file is just:
\begin{codeenv}
\cmd{contentsline} \marg{section}\marg{\cmd{numberline} \marg{1}Duck}\marg{1}
\end{codeenv}
If the \field{description} field contains a \idx{fragile} command
then \gls{glsentrydesc} will break in expandable contexts. For
example, the following doesn't work:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries}
\strut
\gls{newglossaryentry}\marg{duck}
\marg{
  \field{name}=\marg{duck},
  \field{description}=\marg{a waterbird\gls{footnote}\marg{a bird that lives on or 
   near water} with webbed feet}
}
\strut
\cmd{begin}\marg{document}
\gls{tableofcontents}
\gls{section}\marg{\gls{Gls}\marg{duck}: \gls{glsentrydesc}\marg{duck}}\incorrect
\cmd{end}\marg{document}
\end{codeenv}
This is a contrived example. In this case, it would be better to
also define the term \qt{waterbird}: 
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries}
\strut
\gls{newglossaryentry}\marg{waterbird}
\marg{
  \field{name}=\marg{waterbird},
  \field{description}=\marg{a bird that lives on or near water}
}
\strut
\gls{newglossaryentry}\marg{duck}
\marg{
  \field{name}=\marg{duck},
  \field{description}=\marg{a \gls{gls}\marg{waterbird} with webbed feet}
}
\strut
\cmd{begin}\marg{document}
\gls{tableofcontents}
\gls{section}\marg{\gls{Gls}\marg{duck}: \gls{glsentrydesc}\marg{duck}}
\cmd{end}\marg{document}
\end{codeenv}
The \ext{toc} file now contains:
\begin{codeenv}
\cmd{contentsline} \marg{section}\marg{\cmd{numberline} \marg{1}\gls{Gls} \marg{duck}: a \gls{gls} \marg{waterbird} 
with webbed feet}\marg{1}
\end{codeenv}

\begin{important}
The examples in this section are used to illustrate the differences
between \idx{fragile}, \idx{robust} and \idx{expandable} commands.
In general, it's better not to use commands like \gls{gls} in
headings or captions (see \sectionref{sec:headings}). Using
commands like \gls{gls} in field values can be problematic (see
\sectionref{sec:nested}).
\end{important}

By default, most of the field values are expanded when the entry is
defined. This allows for defining entries programmatically, but it
can cause a problem if the value contains any \idx{fragile} commands.
For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries}
\strut
\gls{newglossaryentry}\marg{duck}\comment{label}
\marg{
  \field{name} = \marg{duck},
  \field{first} = \marg{duck\gls{footnote}\marg{quack, quack}},\incorrect
  \field{description} = \marg{a waterbird with webbed feet}
}
\strut
\cmd{begin}\marg{document}
A \gls{gls}\marg{duck}.
\cmd{end}\marg{document}
\end{codeenv}
This causes the confusing error:
\begin{verbatim}
! Undefined control sequence.
\in@ #1#2->\begingroup \def \in@@ 
\end{verbatim}
In order for this example to work, the \idx{fragile} command must either be
protected:
\begin{codeenv}
\gls{newglossaryentry}\marg{duck}\comment{label}
\marg{
  \field{name} = \marg{duck},
  \field{first} = \marg{duck\gls{protect}\gls{footnote}\marg{quack, quack}},\correct
  \field{description} = \marg{a waterbird with webbed feet}
}
\end{codeenv}
or the expansion must first be switched off:
\begin{codeenv}
\gls{glsnoexpandfields} \correct
\gls{newglossaryentry}\marg{duck}\comment{label}
\marg{
  \field{name} = \marg{duck},
  \field{first} = \marg{duck\gls{footnote}\marg{quack, quack}},
  \field{description} = \marg{a waterbird with webbed feet}
}
\end{codeenv}
Since it's not possible to programmatically define entries with
\bibgls, the expansion is automatically switched off as \bibgls\
writes \gls{glsnoexpandfields} to the \ext{glstex} file (although
you can disable this feature with \longarg{expand-fields}).

The reason why \gls{footnote} didn't cause a problem in the
\field{description} field \emph{when the entry was defined} is that, by
default, expansion isn't performed on the \field{name},
\field{description} and \field{symbol} fields, regardless of whether
or not \gls{glsnoexpandfields} has been used. This only applies to
the point when the entries are being defined. Unprotected
\idx{fragile} commands can still cause a problem if the value is
later used in a problematic context (such as the earlier example
where \gls{glsentrydesc} was used in a section heading).

\chapter{Abbreviations}
\label{sec:abbreviations}

The abbreviation handling provided by the base \isty{glossaries}
package is quite restrictive and only one abbreviation style can be
used for all abbreviations. The \isty{glossaries-extra} package
internally loads the \sty{glossaries} package and extends it,
providing new options and a better abbreviation mechanism that
allows different styles per category.

The base \sty{glossaries} package provides:
\nosecformatdef{newacronym}
The extension package \sty{glossaries-extra} provides:
\nosecformatdef{newabbreviation}
which internally uses \gls{newglossaryentry} with the
\field{category} set to \code{abbreviation} (which can be
overridden in the optional \meta{\keyvallist}).
The \gls{glossaries-extra} package also redefines \gls{newacronym} in 
terms of \gls{newabbreviation} so that it effectively behaves like:
\begin{codeenv}
\gls{newabbreviation}\oarg{\gls[noindex=false]{field.type}=\gls{acronymtype},\field{category}=acronym,\meta{\keyvallist}}
\margm{label}\margm{short}\margm{long}
\end{codeenv}
This makes it easier to transfer over from the base \sty{glossaries}
package, but if you use \gls{newacronym} remember that the
\field{category} is set to \code{acronym} instead of \code{abbreviation}.

In both cases, \meta{label} is the entry's label used to identify
the abbreviation in commands like \gls{gls}, \meta{short} is the
short form and \meta{long} is the long form. Any additional
settings, such as the \field{category} or \field{description} 
can be set in the optional argument.

The style must be set \emph{before the abbreviations are defined}
using:
\nosecformatdef{setabbreviationstyle}
where \meta{category} is the category label and \meta{style-name} is
the name of the style. If the optional argument is omitted,
\code{abbreviation} is assumed. The \sty{glossaries-extra} package
automatically sets the default styles:
\begin{codeenv*}
\gls{setabbreviationstyle}\marg{\abbrstyle{long-short}}
\gls{setabbreviationstyle}\oarg{acronym}\marg{\abbrstyle{short-nolong}}
\end{codeenv*}
This means that if you don't explicitly set the style then any
abbreviation defined with \gls{newacronym} will use the
\abbrstyle{short-nolong} style (unless you change the category in
the optional argument) and other abbreviations will use the
\abbrstyle{long-short} style.

If these styles aren't suitable, then you need to change them. Any
abbreviation that's defined with a category that hasn't been
assigned a style will fallback on the style for the default
\code{abbreviation} category. There are many predefined styles to
choose from and they come with commands to help adjust the
formatting. See the \sty{glossaries-extra} user
manual~\cite{glossaries-extra} for the
complete list. The \sty{glossaries-extra} package also comes with a
sample document
\ctanfile{glossaries-extra/samples}{sample-abbr-styles.pdf}
demonstrating all the predefined styles.

The style determines whether the abbreviation is treated as a
\idx{regular} term.  There are also some \idxpl{categoryattribute} that govern
abbreviations (see below and \sectionref{sec:accsupp}).  These
should also be set before the abbreviation is defined.

Some of the styles set the \field{description} field (typically to
the \meta{long} form). The styles that end with \code{-desc} don't,
and so that key must be set explicitly in the \meta{\keyvallist} optional part.

Here's a simple example that uses both \gls{newabbreviation} and
\gls{newacronym} to illustrate the difference:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{newabbreviation}\marg{tug}\marg{TUG}\marg{\cmd{TeX}\gls{cs.space}Users Group}
\gls{newabbreviation}\marg{cldr}\marg{CLDR}\marg{Unicode Common Locale Data 
Repository}
\strut
\gls{newacronym}\marg{SIunit}\marg{SI unit}\marg{International System of Units}
\gls{newacronym}\marg{ascii}\marg{ASCII}\marg{American Standard Code for 
Information Interchange}
\strut
\cmd{begin}\marg{document}
First use: \gls{gls}\marg{tug}, \gls{gls}\marg{cldr}, \gls{gls}\marg{SIunit}, \gls{gls}\marg{ascii}.
Next use: \gls{gls}\marg{tug}, \gls{gls}\marg{cldr}, \gls{gls}\marg{SIunit}, \gls{gls}\marg{ascii}.
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
First use: \gls{TUG}, \gls{CLDR}, \gls{SIunit}, \gls{ASCII}.
Next use: \gls{TUG}, \gls{CLDR}, \gls{SIunit}, \gls{ASCII}.
\end{result}
Note that the \idx{firstuse} of \code{SIunit} and \code{ascii} only
show the short form. This is because the default style for the
\code{acronym} category is the \abbrstyle{short-nolong} style, which
doesn't show the long form with \gls{gls} (and its \idxpl{variant}).

The final optional \meta{insert} argument of commands like \gls{gls}
is typically moved inside, depending on the style. For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{newabbreviation}\marg{svm}\marg{SVM}\marg{support vector machine}
\strut
\cmd{begin}\marg{document}
The \gls{gls}\marg{svm}\oarg{'s} parameters are\cmd{ldots}
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
The \gls{ex.svm}['s] parameters are\ldots
\end{result}
Compare this with:
\begin{codeenv}
The \gls{gls}\marg{svm}'s parameters are\cmd{ldots}\incorrect
\end{codeenv}
which produces:
\begin{result}
The \gls{ex.svm}'s parameters are\ldots
\end{result}

\section{Only Long or Only Short}
\label{sec:longorshort}

If you only want \gls{gls} to show the short form but not the long
form (including on \idx{firstuse}), use one of the \code{-nolong}
styles (such as \abbrstyle{short-nolong}). If you only want the long
form and not the short form (including subsequent use), use one of
the \code{-noshort} styles (such as \abbrstyle{long-noshort}).

If you want only the long form on \idx{firstuse} (without the short
form) and only the short form subsequently then use one of the
\code{-only} styles, such as \abbrstyle{long-only-short-only}.

If you need to reshow the full form, you can reset the
\idx{firstuseflag} with:
\nosecformatdef{glsreset}
which will make the next instance of \code{\gls{gls}\margm{labe}}
act according to \idx{firstuse}.

\begin{important}
If you need an abbreviation in a caption or section title, see 
\sectionref{sec:headings}.
\end{important}

Otherwise, if you want a \emph{specific} instance to show only the short 
form, without modifying the \idx{firstuseflag}, then use
\nosecformatdef{glsxtrshort}
If you want a specific instance to show only the long form, without
modifying the \idx{firstuseflag}, then use
\nosecformatdef{glsxtrlong}
If you want a specific instance to show both the long and short form, without
modifying the \idx{firstuseflag}, then use
\nosecformatdef{glsxtrfull}
Depending on the style, this may not exactly match the format
produced by the \idx{firstuse} of \code{\gls{gls}\margm{label}}.
Don't use these commands for every use. Change the style instead,
which will make it easier to modify the document at a later date.

If you find these commands quite long-winded, there are some
shortcuts available with the \styopt{shortcuts} option, but as these
may interfere with other packages, you might want to consider
investigating your text editor settings as the more sophisticated
ones provide ways of inserting commonly-used commands to save typing.

\section{Plural Abbreviations}
\label{sec:pluralabbr}

If the abbreviation represents something countable then the plural
form can again be obtained with \gls{glspl}:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{newabbreviation}\marg{svm}\marg{SVM}\marg{support vector machine}
\strut
\cmd{begin}\marg{document}
First use: \gls{glspl}\marg{svm}. Next use: \gls{glspl}\marg{svm}.
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
First use: \glspl{ex.svm}. Next use: \glspl{ex.svm}.
\end{result}
The default plural short and long forms are obtained by
appending the letter \qt{s} after the singular form. These can be
changed on an individual basis with the \field{shortplural} and
\field{longplural} keys. For example:
\begin{codeenv}
\gls{newabbreviation}
 [\field{longplural}=\marg{lower triangular matrices}]
 \marg{ltm}\marg{LTM}\marg{lower triangular matrix}
\end{codeenv}

It may be that you prefer to keep the short plural form the same as
the short singular value for all abbreviations within a particular
category. You can implement this with the
\catattr{noshortplural} attribute, which must be set to \code{true}
before the abbreviations for that category are defined. For example:
\begin{codeenv}
\gls{glssetcategoryattribute}\marg{abbreviation}\marg{\catattr{noshortplural}}\marg{true}
\gls{newabbreviation}\marg{svm}\marg{SVM}\marg{support vector machine}
\end{codeenv}
Now:
\begin{codeenv}
First use: \gls{glspl}\marg{svm}. Next use: \gls{glspl}\marg{svm}.
\end{codeenv}
produces:
\begin{result}
First use: support vector machines (SVM). Next use: SVM.
\end{result}
A related attribute is \catattr{aposplural} which inserts \qtt{'s}
(apostrophe followed by \qt{s}) to form the default short plural to
help avoid ambiguity with \idx{lowercase} abbreviations where it might
not be obvious that the \qt{s} indicates a plural (rather than
another letter in the abbreviation). Again, this needs to be set
before the abbreviations for the given category (or categories) are
defined (but check with your supervisor, publisher or editor as this 
usage is controversial).

\section{Abbreviation Markup}
\label{sec:markwords}

The \catattr{markwords} attribute can be set to \code{true} to
indicate that \gls{newabbreviation} should parse the long form and
markup the words using:
\nosecformatdef{glsxtrword}
The words are separated with
\nosecformatdef{glsxtrwordsep}
For example:
\begin{codeenv}
\gls{glssetcategoryattribute}\marg{abbreviation}\marg{\catattr{markwords}}\marg{true}
\gls{newabbreviation}\marg{ssl}\marg{SSL}\marg{Secure Sockets Layer}
\end{codeenv}
This is essentially the same as
\begin{codeenv}
\gls{newabbreviation}\marg{ssl}\marg{SSL}\marg{\gls{glsxtrword}\marg{Secure}\gls{glsxtrwordsep}
\gls{glsxtrword}\marg{Sockets}\gls{glsxtrwordsep}\gls{glsxtrword}\marg{Layer}}
\end{codeenv}
This is typically used with the \code{-hyphen} abbreviation styles,
such as \abbrstyle{long-hyphen-short-hyphen}.
If the final optional \meta{insert} argument of commands like
\gls{gls} starts with a hyphen, \gls{glsxtrwordsep} is locally
changed to a hyphen.

For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{setabbreviationstyle}\marg{\abbrstyle[noindex=false]{long-hyphen-short-hyphen}}
\strut
\gls{glssetcategoryattribute}\marg{abbreviation}\marg{\catattr{markwords}}\marg{true}
\strut
\gls{newabbreviation}\marg{ssl}\marg{SSL}\marg{Secure Sockets Layer}
\strut
\cmd{begin}\marg{document}
First use: \gls{gls}\marg{ssl}\oarg{-enabled}. Next use: \gls{gls}\marg{ssl}\oarg{-enabled}.
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
First use: \gls{ex.ssl}[-enabled]. Next use: \gls{ex.ssl}[-enabled].
\end{result}
Compare this with:
\begin{codeenv}
First use: \gls{gls}\marg{ssl}-enabled. Next use: \gls{gls}\marg{ssl}-enabled.\incorrect
\end{codeenv}
which instead produces:
\begin{result}
First use: \gls{ex.ssl}-enabled. Next use: \gls{ex.ssl}-enabled.
\end{result}
Whereas:
\begin{codeenv}
First use: \gls{gls}\marg{ssl}\oarg{ enabled}. Next use: \gls{gls}\marg{ssl}\oarg{ enabled}.
\end{codeenv}
produces:
\begin{result}
First use: \gls{ex.ssl}[ enabled]. Next use: \gls{ex.ssl}[ enabled].
\end{result}
Note that this is different to the result obtained with the
\abbrstyle{long-short} style which doesn't include the inserted
material in the parentheses (and doesn't check if the inserted
text starts with a hyphen).

There's a related attribute \catattr{markshortwords} which applies
to the short form instead. This is only useful if the short form contains
spaces.

Another markup-related attribute is \catattr{tagging}. In general,
you don't need to explicitly set this attribute. Instead, you need
to define a tagging command using:
\nosecformatdef{GlsXtrEnableInitialTagging}
This (robustly) defines \meta{cs} (a control sequence) to accept a
single argument, which you need to use in the \meta{long} part of the 
abbreviation definition (it's not inserted automatically).

The \gls{GlsXtrEnableInitialTagging} command also sets the
\catattr{tagging} attribute to \code{true} for each of the listed
categories, which ensures that \meta{cs} uses
\nosecformatdef{glsxtrtagfont}
within the glossary (see \sectionref{sec:displaygloss}). Within the
main text the command simply does its argument.
For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{GlsXtrEnableInitialTagging}\marg{abbreviation}\marg{\cmd{itag}}
\strut
\gls{newabbreviation}\marg{xml}\marg{XML}\marg{e\cmd{itag}\marg{x}tensible \cmd{itag}\marg{m}arkup
\cmd{itag}\marg{l}anguage}
\strut
\cmd{begin}\marg{document}
First use: \gls{gls}\marg{xml}. Next use: \gls{gls}\marg{xml}.
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
First use: \gls{ex.xml}. Next use: \gls{ex.xml}.
\end{result}
This doesn't show the markup as the tagging command (\csfmt{itag} in
this example) simply expands to its argument in the main document
text. The difference is only evident in the glossary.

If all your abbreviations are defined in a separate file, it's
useful to provide a definition of the tagging command with
\gls{providecommand} to ensure it's defined if you decide not to use
\gls{GlsXtrEnableInitialTagging}. With \bibgls, you can include it
in the \atentry{preamble}. For example:
\begin{codeenv}
\atentry{preamble}\marg{"\gls{providecommand}\marg{\cmd{itag}}\oarg{1}\marg{\gls{param}1}"}
\end{codeenv}

\section{Dotted Abbreviations}
\label{sec:dotabbr}

If an abbreviation ends with a \idx{full-stop}, it can be awkward
when it appears at the end of a sentence, as you can end up with two
dots by mistake. For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{newabbreviation}\marg{dante}\marg{DANTE e.V.}
\marg{Deutschsprachige Anwendervereinigung \cmd{TeX}\gls{cs.space}e.V.}
\strut
\gls{newabbreviation}\marg{gp}\marg{G.P.}\marg{General Practitioner}
\strut
\cmd{begin}\marg{document}
\gls{gls}\marg{dante} is a local \cmd{TeX}\gls{cs.space}user group.
The German-speaking local \cmd{TeX}\gls{cs.space}user group is \gls{gls}\marg{dante}.
\strut
A \gls{gls}\marg{gp} is a medical doctor.
I went to my surgery to see the \gls{gls}\marg{gp}.
\cmd{end}\marg{document}
\end{codeenv}
This results in:
\begin{result}
\gls{ex.dante} is a local \TeX\ user group.
The German-speaking local \TeX\ user group is \gls{ex.dante}\relax.\incorrect

A \gls{ex.gp} is a medical doctor.
I went to my surgery to see the \gls{ex.gp}\relax.\incorrect
\end{result}
The awkward double-dot is caused by the final dot in the
short form followed by the sentence terminating \idx{full-stop}.

If the \catattr{discardperiod} attribute is set to \code{true}, the
\idx{postlinkhook} will look ahead for a \idx{full-stop}. If it
finds one, it will be discarded. For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{glssetcategoryattribute}\marg{abbreviationdot}\marg{\catattr{discardperiod}}\marg{true}
\strut
\gls{newabbreviation}\oarg{\field{category}=abbreviationdot}
 \marg{dante}\marg{DANTE e.V.}\marg{Deutschsprachige Anwendervereinigung \cmd{TeX}\gls{cs.space}e.V.}
\strut
\gls{newabbreviation}\oarg{\field{category}=abbreviationdot}
 \marg{gp}\marg{G.P.}\marg{General Practitioner}
\strut
\cmd{begin}\marg{document}
\gls{gls}\marg{dante} is a local \cmd{TeX}\gls{cs.space}user group.
The German-speaking local \cmd{TeX}\gls{cs.space}user group is \gls{gls}\marg{dante}.
\strut
A \gls{gls}\marg{gp} is a medical doctor.
I went to my surgery to see the \gls{gls}\marg{gp}.
\cmd{end}\marg{document}
\end{codeenv}
This now results in:
\begin{result}
\gls{ex.dante} is a local \TeX\ user group.
The German-speaking local \TeX\ user group is \gls{ex.dante}.

A \gls{ex.gp} is a medical doctor.
I went to my surgery to see the \gls{ex.gp}.
\end{result}
This attribute only affects the \emph{non-plural} commands, such as
\gls{gls} and \gls{glsxtrshort}. If the last paragraph in the above 
example is changed to:
\begin{codeenv}
A \gls{gls}\marg{gp} is a medical doctor.
I went to my surgery to see the \gls{glspl}\marg{gp}.
\end{codeenv}
then the result is:
\begin{result}
A \gls{ex.gp} is a medical doctor.
I went to my surgery to see the \glspl{ex.gp}.
\end{result}
In this case there's no need to discard the terminating
\idx{full-stop} as the plural form doesn't end with one. If the
plural form also ends with a \idx{full-stop} (for example, if the
\catattr{noshortplural} attribute is also set) then you additionally
need to set the \catattr{pluraldiscardperiod} attribute.

The \idx{postlinkhook} is also applied to other commands, such as 
\gls{glsxtrfull}, \gls{glsxtrlong}, \gls{glsxtrshort} and \gls{glssymbol}.
For example:
\begin{codeenv}
I went to my surgery to see the \gls{glsxtrshort}\marg{gp}.
\end{codeenv}
results in:
\begin{result}
I went to my surgery to see the \glsxtrshort{ex.gp}.
\end{result}
In some cases, this may be inappropriate, for example:
\begin{codeenv}
I went to my surgery to see the \gls{glsxtrlong}\marg{gp}.
\end{codeenv}
results in:
\begin{result}
I went to my surgery to see the \glsxtrlong{ex.gp}.
\end{result}
In this case the terminating \idx{full-stop} shouldn't be discarded.
There are several ways to prevent it. For example, moving the
\idx{full-stop} into the \meta{insert} argument:
\begin{codeenv}
I went to my surgery to see the \gls{glsxtrlong}\marg{gp}\oarg{.}
\end{codeenv}
This results in:
\begin{result}
I went to my surgery to see the \glsxtrlong{ex.gp}[.]
\end{result}
Alternatively, insert \csfmt{relax} before the \idx{full-stop}:
\begin{codeenv}
I went to my surgery to see the \gls{glsxtrlong}\marg{gp}\cmd{relax}.
\end{codeenv}

Depending on the abbreviation style, it may be inappropriate for the
\idx{firstuse} to discard the \idx{full-stop}. In this case, it's a
bit of a nuisance to keep track of whether the term is being
referenced for the first time. Instead, set the
\catattr{retainfirstuseperiod} attribute to \code{true}.

If you have many abbreviations defined without dots and then you
later decide to insert them, you may prefer an automated approach.
This can be done by setting the \catattr{insertdots} attribute to \code{true}.
For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{glssetcategoryattribute}\marg{initialism}\marg{\catattr{insertdots}}\marg{true}
\gls{glssetcategoryattribute}\marg{initialism}\marg{\catattr{discardperiod}}\marg{true}
\gls{glssetcategoryattribute}\marg{initialism}\marg{\catattr{retainfirstuseperiod}}\marg{true}
\strut
\gls{setabbreviationstyle}\oarg{initialism}\marg{\abbrstyle[noindex=false]{short-long}}
\strut
\gls{newabbreviation}\oarg{\field{category}=initialism}
 \marg{gp}\marg{GP}\marg{General Practitioner}
\strut
\cmd{begin}\marg{document}
Today I went to my surgery to see the \gls{gls}\marg{gp}.
Tomorrow I'm going to my surgery to see the \gls{gls}\marg{gp}.
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
Today I went to my surgery to see the \gls{ex2.gp}.
Tomorrow I'm going to my surgery to see the \gls{ex2.gp}.
\end{result}

\section{Translations}
\label{sec:abbrvtrans}

If an abbreviation needs to be accompanied by a translation, then
you can use a custom field or one of the supplied user fields
described in \sectionref{sec:userkeys} to store the translation. The
\code{-user} abbreviation styles can be used to include the extra
information if the field is set. The \field{user1} field
is the default, but you can change this by redefining:
\nosecformatdef{glsxtruserfield}
to the \emph{internal} field name. (For example, \field{userii} for
\field{user2}.) In the sample document below, the translation is
supplied in the default \field{user1} field:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{setabbreviationstyle}\marg{\abbrstyle{long-short-user}}
\strut
\gls{newabbreviation}\oarg{\field{user1}=\marg{ribonucleic acid}}
 \marg{rna}\marg{RNA}\marg{ribonukleins\gls[noindex=false]{umlaut}aure}
\strut
\cmd{begin}\marg{document}
First use: \gls{gls}\marg{rna}.  Next use: \gls{gls}\marg{rna}.
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
First use: \gls{ex.rna}.  Next use: \gls{ex.rna}.
\end{result}
If the field is empty, \abbrstyle{long-short-user} behaves like
\abbrstyle{long-short}.

Here's an example where the native language is English:
\begin{codeenv}
\gls{newabbreviation}\marg{iso}\marg{ISO}\marg{International Organization for Standardization}
\strut
\gls{newabbreviation}\oarg{
  \field{user1} = \marg{Associa\gls{c}\marg{c}\gls{cs.tilde}ao Brasileria de Normas T\cs{acute}ecnicas},
  \field{user2} = \marg{pt-BR},
  \field{category} = \marg{foreignabbreviation}
}
\marg{abnt}\marg{ABNT}\marg{Brazilian National Standards Organization}
\strut
\gls{newabbreviation}\oarg{
  \field{user1} = \marg{Deutsches Institut f\gls{umlaut}ur Normung e.V.},
  \field{user2} = \marg{de-1996},
  \field{category} = \marg{foreignabbreviation}
}\marg{din}\marg{DIN}\marg{German Institute for Standardization}
\end{codeenv}
The use of the custom \field{category} label
\code{foreignabbrevaiation} means I can set up different abbreviation
styles. For example:
\begin{codeenv}
\gls{setabbreviationstyle}\marg{short-nolong}
\gls{setabbreviationstyle}\oarg{foreignabbreviation}\marg{long-short-user}
\end{codeenv}
This example differs from the previous one as there are now two
foreign languages (Portuguese and German) with English as the native
language. The previous had German as the native language and English
as the sole foreign language. In this case, I've used the
\field{user2} field to identify the language of the original text
(stored in the \field{user1} field).

For example, suppose I'm using \sty{babel} with the language options
\code{british}, \code{brazilian} and \code{ngerman}:
\begin{codeenv}
\cmd{usepackage}[main=british,brazilian,ngerman]\marg{babel}
\end{codeenv}
then I might want to modify \gls{glsxtruserparen} to use
\gls{foreignlanguage}. This would be easier if the \field{user2}
field used a recognised \sty{babel} dialect label, but that's less
consistent across documents. For example, in another document I
might use \code{UKenglish} or just \code{english} (or perhaps use
\sty{polyglossia} instead).

The \sty{glossaries} package loads \sty{tracklang}~\cite{tracklang},
which provides:
\nosecformatdef{GetTrackedDialectFromLanguageTag}
If the given language tag matches a document dialect that's been
tracked (by \sty{tracklang}), this stores the \emph{\sty{tracklang}
dialect label} in the control sequence \meta{cs} otherwise it sets
that control sequence to empty. The match requires that five
properties of the language tag and \sty{tracklang}'s dialect label
are the same: root language, region, sub-language, variant and
script. Some of these elements may be empty, in which case those
elements must be empty for both. If the script is missing in either
case, the default script for the given root language is assumed. For
example, \code{Latn} for \code{en} (English).

\begin{important}
The \sty{tracklang} dialect label isn't always the same as
\sty{babel}'s dialect label.
\end{important}

The simplest way to test if the \sty{tracklang} label matches the
\sty{babel} label is to test for the existence of
\csfmt{captions}\meta{label}. For example, using \sty{etoolbox}'s
\gls{ifcsundef}:
\begin{codeenv}
\gls{GetTrackedDialectFromLanguageTag}\marg{pt-BR}\marg{\cmd{dialectlabel}}
\gls{ifdefempty}\cmd{dialectlabel}
\marg{}\comment{no exact match found}
\marg{\comment{exact match found}
  \gls{ifcsundef}\marg{captions\cmd{dialectlabel}}
  \marg{}\comment{not a recognised \sty{babel} label}
  \marg{}\comment{recognised \sty{babel} label}
}
\end{codeenv}
In the \qt{not a recognised \sty{babel} label} argument, you can
find out if the \sty{tracklang} dialect label has a mapping to the
closest known \sty{babel} dialect label with:
\nosecformatdef{IfTrackedDialectHasMapping}
If true, you can fetch the corresponding \sty{babel} label with:
\nosecformatdef{GetTrackedDialectToMapping}
If false, you can try the root language label instead, which can be
obtained with:
\nosecformatdef{TrackedLanguageFromDialect}
For example:
\begin{codeenv}
\gls{GetTrackedDialectFromLanguageTag}\marg{pt-BR}\marg{\cmd{dialectlabel}}
\gls{ifdefempty}\cmd{dialectlabel}
\marg{}\comment{no exact match found}
\marg{\comment{exact match found}
  \gls{ifcsundef}\marg{captions\cmd{dialectlabel}}
  \marg{\comment{not a recognised \sty{babel} label, use root language}
    \cmd{edef}\cmd{dialectlabel}\marg{\gls{TrackedLanguageFromDialect}\cmd{dialectlabel}}\comment{}
  }\comment{}
  \marg{}\comment{recognised \sty{babel} label}
}
\end{codeenv}

Consider the following document:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}[british]\marg{babel}
\cmd{usepackage}\marg{tracklang}
\strut
\cmd{begin}\marg{document}
\gls{GetTrackedDialectFromLanguageTag}\marg{en-GB}\marg{\cmd{trackeddialect}}\comment{}
Tracked dialect label: \cmd{trackeddialect}.
\gls{IfTrackedDialectHasMapping}\marg{\cmd{trackeddialect}}\comment{}
\marg{Has mapping: \gls{GetTrackedDialectToMapping}\marg{\cmd{trackeddialect}}}\comment{}
\marg{No mapping}.
Root language: \gls{TrackedLanguageFromDialect}\marg{\cmd{trackeddialect}}.
\cmd{end}\marg{document}
\end{codeenv}
In this case the \sty{tracklang} dialect label is the same as
\sty{babel}'s dialect label. The above produces:
\begin{result}
Tracked dialect label: british. No mapping. Root language: english.
\end{result}
Now consider this document:
\begin{codeenv}
\cmd{documentclass}[en-MT]\marg{article}
\strut
\cmd{usepackage}[british]\oarg{babel}
\cmd{usepackage}\marg{tracklang}
\strut
\cmd{begin}\marg{document}
en-GB: \gls{GetTrackedDialectFromLanguageTag}\marg{en-GB}\marg{\cmd{trackeddialect}}\comment{} Tracked dialect label: \cmd{trackeddialect}.
\gls{IfTrackedDialectHasMapping}\marg{\cmd{trackeddialect}}\comment{}
\marg{Has mapping: \gls{GetTrackedDialectToMapping}\marg{\cmd{trackeddialect}}}\comment{}
\marg{No mapping}.
Root language: \gls{TrackedLanguageFromDialect}\marg{\cmd{trackeddialect}}.
\strut
en-MT: \gls{GetTrackedDialectFromLanguageTag}\marg{en-MT}\marg{\cmd{trackeddialect}}\comment{} Tracked dialect label: \cmd{trackeddialect}.
\gls{IfTrackedDialectHasMapping}\marg{\cmd{trackeddialect}}\comment{}
\marg{Has mapping: \gls{GetTrackedDialectToMapping}\marg{\cmd{trackeddialect}}}\comment{}
\marg{No mapping}.
Root language: \gls{TrackedLanguageFromDialect}\marg{\cmd{trackeddialect}}.
\cmd{end}\marg{document}
\end{codeenv}
In this case the document requires Maltese English but \sty{babel}
doesn't have an associated dialect so \code{british} is used
instead in \sty{babel}'s options list. However, \sty{tracklang} does
recognise \code{en-MT} as a document class option, which allows
extra localisation from other locale-sensitive packages. (For
example, \sty{datetime2} will use different time zone abbreviations.) If
\sty{tracklang} picks up document class options, these override any
\sty{babel} settings, but the mapping allows a way of accessing the
captions hook provided by \sty{babel}.

The above document produces:
\begin{result}
en-GB: Tracked dialect label: . No mapping. Root language: .

en-MT: Tracked dialect label: maltaenglish. Has mapping: british.
Root language: english.
\end{result}
So now, even though \sty{babel}'s \code{british} option has been
used, en-GB isn't recognised as a tracked locale. Things are a
little more complicated if the language tag is too specific compared
to the \sty{babel} dialect label. For example, while the dialect
label \code{nswissgerman} identifies the region, the \code{ngerman}
label doesn't.
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}[ngerman]\marg{babel}
\cmd{usepackage}\marg{tracklang}
\strut
\cmd{begin}\marg{document}
\gls{GetTrackedDialectFromLanguageTag}\marg{de-DE-1996}\marg{\cmd{trackeddialect}}\comment{}
Tracked dialect label: \cmd{trackeddialect}.
\gls{IfTrackedDialectHasMapping}\marg{\cmd{trackeddialect}}\comment{}
\marg{Has mapping: \gls{GetTrackedDialectToMapping}\marg{\cmd{trackeddialect}}}\comment{}
\marg{No mapping}.
\end{codeenv}
In this case no dialect label is found. The result is:
\begin{result}
Tracked dialect label: . No mapping.
\end{result}
This is because the document doesn't have a dialect that matches
both the language \emph{and} region. As from \sty{tracklang} version
1.3.6, \gls{GetTrackedDialectToMapping} sets:
\nosecformatdef{TrackedDialectClosestSubMatch}
to the closest dialect label that has the same root language if the
exact match isn't found. This will be empty if there's no tracked
dialect with the given root language (and may also be empty if an
exact match is found). 
 
Returning to \sty{glossaries-extra} with the original text stored in
the \field{user1} field (identified by \gls{glsxtruserfield} in the
\abbrstyle{long-short-user} style) and the language tag stored in
the \field{user2} field, then if you have at least version 1.32 of
\sty{glossaries-extra} and version 1.3.6 of \sty{tracklang} you
can use:
\nosecformatdef{GlsXtrForeignText}
to encapsulate \meta{text} with:
\nosecformatdef{foreignlanguage}
where the field containing the appropriate locale tag is stored in
the field given by:
\nosecformatdef{GlsXtrForeignTextField}
which defaults to the \field{userii} internal field for the entry
identified by \meta{label} (corresponding to the \field{user2} field).
For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}[main=british,brazilian,ngerman]\marg{babel}
\cmd{usepackage}[\styopt{record}]\marg{glossaries-extra}
\strut
\gls{setabbreviationstyle}\oarg{foreignabbreviation}\marg{long-short-user}
\strut
\gls{newabbreviation}\marg{iso}\marg{ISO}\marg{International Organization for Standardization}
\strut
\gls{newabbreviation}\oarg{
  \field{user1} = \marg{Associa\gls{c}\marg{c}\gls{cs.tilde}ao Brasileria de Normas T\cs{acute}ecnicas},
  \field{user2} = \marg{pt-BR},
  \field{category} = \marg{foreignabbreviation}
}
\marg{abnt}\marg{ABNT}\marg{Brazilian National Standards Organization}
\strut
\gls{newabbreviation}\oarg{
  \field{user1} = \marg{Deutsches Institut f\gls{umlaut}ur Normung e.V.},
  \field{user2} = \marg{de-1996},
  \field{category} = \marg{foreignabbreviation}
}\marg{din}\marg{DIN}\marg{German Institute for Standardization}
\strut
\cmd{renewcommand}*\marg{\gls{glsxtruserparen}}[2]\marg{\comment{}
  \gls[noindex=false]{glsxtrfullsep}\marg{\gls{param}2}\comment{}
  \gls[noindex=false]{glsxtrparen}
  \marg{\gls{param}1\comment{}
   \gls{ifglshasfield}\marg{\gls{glsxtruserfield}}\marg{\gls{param}2}\comment{}
   \marg{, \gls{emph}\marg{\gls{GlsXtrForeignText}\marg{\gls{param}2}\marg{\gls{glscurrentfieldvalue}}}}\comment{}
   \marg{}\comment{}
  }\comment{}
}
\strut
\cmd{begin}\marg{document}
\gls{gls}\marg{abnt}, \gls{gls}\marg{din}.
\cmd{end}\marg{document}
\end{codeenv}
This essentially uses the earlier \sty{tracklang} code where an
extra \gls{ifdefempty} is inserted, which sets the equivalent of
\csfmt{trackeddialect} in the above to \gls{TrackedDialectClosestSubMatch}. If
the test for the captions hook is false, then \gls{foreignlanguage}
isn't used.


\chapter{Symbols}
\label{sec:symbols}

\Sectionref{sec:userkeys} described the \field{symbol} key, which can
be used to additionally provide a symbol. For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{\gls[noindex=false]{siunitx}}\comment{provides \gls{si}}
\cmd{usepackage}\marg{glossaries}
\strut
\gls{newglossaryentry}\marg{length}\comment{label}
\marg{\comment{settings:}
   \field{name}   = \marg{length},
   \field{symbol} = \marg{\gls{si}\marg{\cmd{metre}}},
   \field{description} = \marg{measurement between two points}
}
\strut
\gls{newglossaryentry}\marg{area}\comment{label}
\marg{\comment{settings:}
   \field{name}   = \marg{area},
   \field{symbol} = \marg{\gls[noindex=false]{si}\marg{\cmd{metre}\cmd{squared}}},
   \field{description} = \marg{measurement of a surface}
}
\strut
\cmd{begin}\marg{document}
Measurements: \gls{gls}\marg{length} (\gls{glssymbol}\marg{length}) and
\gls{gls}\marg{area} (\gls{glssymbol}\marg{area}).
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
Measurements: \gls{ex.length} (\glssymbol{ex.length}) and
\gls{ex.area} (\glssymbol{ex.area}).
\end{result}

It may be that you prefer to have the symbol in the \field{name}
field instead. The example document below is a modification of the
above and uses the \idx{postlinkhook} to append the description on
\idx{firstuse} (see \sectionref{sec:postlinkhooks}).
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{siunitx}
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls[noindex=false]{glsnoexpandfields} \comment{name field contains \gls{si}}
\strut
\gls{glsdefpostlink}\marg{symbol}\marg{\gls{glsxtrpostlinkAddDescOnFirstUse}}
\strut
\gls{newglossaryentry}\marg{length}\comment{label}
\marg{\comment{settings:}
  \field{name} = \marg{\gls{si}\marg{\cmd{metre}}},
  \field{description} = \marg{length},
  \field{category} = \marg{symbol}
}
\strut
\gls{newglossaryentry}\marg{area}\comment{label}
\marg{\comment{settings:}
  \field{name} = \marg{\gls{si}\marg{\cmd{metre}\cmd{squared}}},
  \field{description} = \marg{area},
  \field{category} = \marg{symbol}
}
\strut
\cmd{begin}\marg{document}
First use: \gls{gls}\marg{length} and \gls{gls}\marg{area}.
Next use: \gls{gls}\marg{length} and \gls{gls}\marg{area}.
\cmd{end}\marg{document}
\end{codeenv}
Note the need for \gls{glsnoexpandfields} (described in
\sectionref{sec:robust}). This wasn't required in the previous
example because the \sty{siunitx} commands were in the
\field{symbol} field, which isn't expanded by default. The
\field{name} field also isn't expanded by default, but its value is
copied to the \field{text} and \field{first} fields, which are
expanded by default. If \gls{glsnoexpandfields} is omitted from the
above document, the following error would occur:
\begin{verbatim}
! Undefined control sequence.
\@glo@name ->\si {\metre 
                         }
\end{verbatim}
Although \gls{si} is robust, commands like \csfmt{metre} and
\csfmt{squared} are only available within the argument of \gls{si}
(and other similar commands provided by \sty{siunitx}) and so break
in expandable contexts.
With \gls{glsnoexpandfields}, the document compiles correctly and
produces:
\begin{result}
\glsdefpostlink{symbol}{\glsxtrpostlinkAddDescOnFirstUse}%
First use: \gls{ex2.length} and \gls{ex2.area}.
Next use: \gls{ex2.length} and \gls{ex2.area}.
\end{result}

The \sty{glossaries-extra}['s] \styopt{symbols} package option
provides the command
\nosecformatdef{glsxtrnewsymbol}
which is a shortcut for
\begin{codeenv}
\gls{newglossaryentry}\margm{label}\marg{\field{name}=\margm{symbol},\field{category}=\marg{symbol},\gls[noindex=false]{field.sort}=\margm{label},
\gls[noindex=false]{field.type}=\marg{symbols},\meta{\keyvallist}}
\end{codeenv}
So the above document can be changed to:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{siunitx}
\cmd{usepackage}[\styopt{symbols}]\marg{glossaries-extra}
\strut
\gls{glsnoexpandfields}
\strut
\gls{glsdefpostlink}\marg{symbol}\marg{\gls{glsxtrpostlinkAddDescOnFirstUse}}
\strut
\gls{glsxtrnewsymbol}\oarg{\field{description} = \marg{length}}\marg{length}\marg{\gls{si}\marg{\cmd{metre}}}
\strut
\gls{glsxtrnewsymbol}\oarg{\field{description} = \marg{area}}\marg{area}\marg{\gls{si}\marg{\cmd{metre}\cmd{squared}}}
\strut
\cmd{begin}{document}
First use: \gls{gls}\marg{length} and \gls{gls}\marg{area}.
Next use: \gls{gls}\marg{length} and \gls{gls}\marg{area}.
\cmd{end}\marg{document}
\end{codeenv}
The result is the same.

\section{Functions}
\label{sec:functions}

Some symbols may represent functions. For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}[\styopt{symbols}]\marg{glossaries-extra}
\strut
\gls{glsnoexpandfields}
\strut
\gls{glsxtrnewsymbol}
 \oarg{\field{description} = \marg{derivative}}
 \marg{deriv}\comment{label}
 \marg{\gls{ensuremath}\marg{f'(x)}}\comment{symbol}
\strut
\cmd{begin}\marg{document}
The derivative is denoted \gls{gls}\marg{deriv}.
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
The derivative is denoted \gls{ex.deriv}.
\end{result}
What if I need to change the variable for a specific instance, for
example, if I want $f'(x_i)$ instead of $f'(x)$? I can just use:
\begin{codeenv}
The gradient at \gls{mshiftchar}x\gls{sbchar}i\gls{mshiftchar} is \gls{mshiftchar}f'(x\gls{sbchar}i)\gls{mshiftchar}.
\end{codeenv}
So far, none of the example documents have a glossary or list of
terms. The ultimate aim when using the \styfmt{glossaries} package
is to ensure consistent formatting and notation, and, where
applicable, include a list of all terms referenced in the document.
The use of commands like \gls{gls} helps to achieve this. If the
notation needs to be changed, only the entry definition (and
associated formatting commands) should need to be redefined without
having to go through the whole document changing the code. Using
commands like \gls{gls} also identifies which entries need to be
included in the list of terms and, if \sty{hyperref} is loaded, can
be hyperlinked to the relevant place in that list (see
\sectionref{sec:displaygloss}).

So explicitly using \verb|f'(x_i)| won't index the \code{deriv} entry 
or mark it has having been used or create a hyperlink. One
possibility is to use one of the following commands:
\nosecformatdef{glslink}
\nosecformatdef{glsdisp}
They both work in much the same way, indexing the entry and
displaying \meta{text} as the \idx{link-text}. The only difference is
that \gls{glsdisp} also unsets the \idx{firstuseflag}, which marks the entry
as having been used. For example:
\begin{codeenv}
The gradient at \gls{mshiftchar}x\gls{sbchar}i\gls{mshiftchar} is \gls{glslink}\marg{deriv}\marg{\gls{mshiftchar}f'(x\gls{sbchar}i)\gls{mshiftchar}}.
\end{codeenv}
This solves the problem of ensuring that the \code{deriv} entry is
indexed and, if \sty{hyperref} is loaded, ensures that the
\idx{link-text} has a hyperlink to the relevant place in the list of
notation, but it doesn't solve the problem of consistent formatting.

One way of ensuring consistent formatting is to define a semantic
command. For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}[\styopt{symbols}]\marg{glossaries-extra}
\strut
\gls{glsnoexpandfields}
\strut
\cmd{newcommand}\marg{\cmd{derivfn}}[1]\marg{f'(\gls{param}1)}
\strut
\gls{glsxtrnewsymbol}
 \oarg{\field{description} = \marg{derivative}}
 \marg{deriv}\comment{label}
 \marg{\gls{ensuremath}\marg{\cmd{derivfn}\marg{x}}}\comment{symbol}
\strut
\cmd{begin}\marg{document}
The derivative is denoted \gls{gls}\marg{deriv}.
The gradient at \gls{mshiftchar}x\gls{sbchar}i\gls{mshiftchar} is \gls{glslink}\marg{deriv}\marg{\gls{mshiftchar}\cmd{derivfn}\marg{x\gls{sbchar}i}\gls{mshiftchar}}.
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
\providecommand{\derivfn}[1]{f'(#1)}
The derivative is denoted \gls{ex.deriv}.
The gradient at $x_i$ is \glslink{ex.deriv}{$\derivfn{x_i}$}.
\end{result}
Now only \csfmt{derivfn} needs modifying if the notation must change.
This requires remembering both the entry label (\code{deriv} in this
case) and the associated formatting command (\csfmt{derivfn} in this
case). The \sty{glossaries-extra} package provides a way of storing
the associated formatting command in one of the additional keys (see
\sectionref{sec:userkeys}). The field is identified by:
\nosecformatdef{GlsXtrFmtField}
which defaults to \field{useri} (the internal representation of the
\field{user1} key). The value must be the name (without the leading
backslash) of a control sequence that takes a \emph{single}
mandatory argument. The above custom command \code{derivfn}
satisfies this requirement, so the entry can be defined as:
\begin{codeenv}
\gls{glsxtrnewsymbol}
 \oarg{\comment{settings:}
   \field{description} = \marg{derivative},
   \field{user1} = \marg{derivfn}
 }
 \marg{deriv}\comment{label}
 \marg{\gls{ensuremath}\marg{\cmd{derivfn}\marg{x}}}\comment{symbol}
\end{codeenv}
The formatting command can now be applied using one of the
following:
\nosecformatdef{glsxtrfmt}
\nosecformatdef{glsxtrfmt*}
which internally use \gls{glslink} or:
\nosecformatdef{glsxtrentryfmt}
which doesn't (and so is more like using \gls{glsentryname}).

So an alternative approach is:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}[\styopt{symbols}]\marg{glossaries-extra}
\strut
\gls{glsnoexpandfields}
\strut
\cmd{newcommand}\marg{\cmd{derivfn}}[1]\marg{f'(\gls{param}1)}
\strut
\gls{glsxtrnewsymbol}
 \oarg{\comment{settings:}
   \field{description} = \marg{derivative},
   \field{user1} = \marg{derivfn}
 }
 \marg{deriv}\comment{label}
 \marg{\gls{ensuremath}\marg{\cmd{derivfn}\marg{x}}}\comment{symbol}
\strut
\cmd{begin}\marg{document}
The derivative is denoted \gls{gls}\marg{deriv}.
The gradient at \gls{mshiftchar}x\gls{sbchar}i\gls{mshiftchar} is \gls{mshiftchar}\gls{glsxtrfmt}\marg{deriv}\marg{x\gls{sbchar}i}\gls{mshiftchar}.
\cmd{end}\marg{document}
\end{codeenv}
This again produces:
\begin{result}
The derivative is denoted \gls{ex.deriv}.
The gradient at $x_i$ is $\glsxtrfmt{ex.deriv}{x_i}$.
\end{result}

Both the starred \gls{glsxtrfmt*} and unstarred \gls{glsxtrfmt}
format the \meta{text} argument using:
\nosecformatdef{glsxtrfmtdisplay}
where \meta{cs-name} is the control sequence name stored in the
field identified by \gls{GlsXtrFmtField} and the \meta{insert} part
is the final optional argument for the starred \gls{glsxtrfmt*} (if
provided) otherwise it's empty. If the command identified by
\meta{cs-name} doesn't exist (or if the field providing it isn't
set) then just \meta{text}\meta{insert} is done.

\begin{important}
Nested \idx{link-text} causes problems so don't use \gls{glsxtrfmt}
in the optional part of commands like \gls{gls} or \gls{glssymbol}
or in field values that are used by those types of command. Also
don't use \gls{glsxtrfmt} within the \meta{text} or \meta{insert}
part of another instance of \gls{glsxtrfmt} or in \gls{glslink} or
\gls{glsdisp}. Use \gls{glsxtrentryfmt} instead.
\end{important}

If more than one argument is required, then a helper macro is
needed. For example:
\begin{verbatim}
\newcommand{\iderivfn}[2][f]{#1'(#2)}
\newcommand{\derivfn}[1]{\iderivfn#1}
\end{verbatim}
Now to obtain $g'(x_i)$:
\begin{codeenv}
\gls{mshiftchar}\gls{glsxtrfmt}\marg{deriv}\marg{[g]\marg{x\gls{sbchar}i}}\gls{mshiftchar}
\end{codeenv}
Note that for this simplistic helper macro, the mandatory inner
argument needs extra braces if it consists of more than a single
token. For example:
\begin{codeenv}
\gls{mshiftchar}\gls{glsxtrfmt}\marg{deriv}\marg{\marg{x\gls{sbchar}i}}\gls{mshiftchar}
\end{codeenv}

\section{Dealing with Automated Case-Changing}
\label{sec:symfirstuc}

Commands like \gls{Gls} don't usually make much sense for symbols as
a change in case can cause a change in meaning. For example,
$\boldsymbol{x}$ might denote a vector and $\boldsymbol{X}$ might
denote a matrix. However, you may have a mixed list of terms
containing both symbols and words, and if you set the
\catattr{glossname} attribute to \code{firstuc}, which automatically
converts the first letter of each \field{name} to \idx{uppercase} in the
glossary, then this can cause a problem for entries where the
\field{name} starts with a symbol. The simplest solution is to
insert an empty group at the start of the \field{name} field for
such entries. For example:
\begin{codeenv}
\gls{glsxtrnewsymbol}
 \oarg{\field{description} = \marg{length}}\comment{settings}
 \marg{length}\comment{label}
 \marg{\marg{}\gls{si}\marg{\cmd{metre}}}\comment{name}
\end{codeenv}
This is done automatically by \bibgls, but if it causes any
interference you can switch off the behaviour with
\longarg{no-mfirstuc-math-protection}.

\chapter{Displaying the Definition}
\label{sec:displaygloss}

The examples so far only use the defined entries in the documents
with commands like \gls{gls} or \gls{glssymbol} or
\gls{glsentrydesc}. These are useful for ensuring consistent
formatting, but it's also helpful to have a place in the document
where the term is formally defined. This can be partially solved
by including the description in parentheses on \idx{firstuse},
either by explicitly including the description in the \field{first}
field or with the use of the \idx{postlinkhook}, but the
\idx{firstuse} might not be the most appropriate place for the
description.

\section{Listing the Terms (Glossary)}
\label{sec:printgloss}

If you want a complete list of all defined terms, you can use:
\nosecformatdef{printunsrtglossary}
This lists all the terms for the given glossary (identified by the
\printglossopt{type} key in \meta{options}, see
\sectionref{sec:multigloss}) according to the order of the
glossary's internal list of labels, which is typically in the order of 
definition. (As each entry is defined, its label is appended to the
internal list of the associated glossary.)

You can change the default title with the \printglossopt{title} option. For
example:
\begin{codeenv}
\gls{printunsrtglossary}\oarg{\printglossopt[Nomenclature]{title}}
\end{codeenv}
The title used in the \gls{toc} is assumed to be the same,
but you can change it with \printglossopt{toctitle}. For example:
\begin{codeenv}
\gls{printunsrtglossary}\oarg{
 \printglossopt[List of Terms and Notation]{title},
 \printglossopt[Notation]{toctitle}
}
\end{codeenv}

The glossary style can be set with the \printglossopt{style} key
in \meta{options}. Alternatively, you can set a default style with the
\styopt{style} package option. There are many predefined styles to
choose from (see the
\href{https://www.dickimaw-books.com/gallery/glossaries-styles/}{\styfmt{glossaries}
gallery}~\cite{glossarystylesgallery}). The styles are provided in supplementary packages, some
of which are automatically loaded. Since each package adds to the
document overhead, and some require additional packages to be
loaded, when using \sty{glossaries-extra}, it's a good idea to
disable the automatic loading of all styles with \styopt{nostyles}
and then use \styopt{stylemods} to load the specific packages (along
with the \sty{glossaries-extra-stylemods} package, which patches
some of the predefined styles). For example, the
\glostyle{index} style is provided by the \styfmt{glossary-tree}
package, so \styopt[tree]{stylemods} will automatically load
\styfmt{glossary-tree} and provide all the tree-like styles,
including \glostyle{index}. The \styopt{stylemods} value may be a
comma-separated list, so to load both \styfmt{glossary-tree} and
\styfmt{glossary-long}, use \styopt[tree,long]{stylemods}.
For example:
\begin{codeenv}
\cmd{documentclass}\marg{scrartcl}
\cmd{usepackage}\marg{\gls[noindex=false]{mhchem}}\comment{provides \gls{ce}}
\cmd{usepackage}[\styopt[dot]{postpunc},\comment{full stop after description}
 \styopt{nostyles},\comment{don't load default style packages}
\comment{load glossaries-extra-stylemods.sty and glossary-tree.sty:}
 \styopt[tree]{stylemods}
]\marg{glossaries-extra}
\strut
\gls{newglossaryentry}\marg{area}
\marg{
   \field{name} = \marg{\gls{ensuremath}\marg{A}},
   \field{description} = \marg{area}
}
\strut
\gls{newglossaryentry}\marg{amethyst}
\marg{
   \field{name} = \marg{amethyst},
   \field{description} = \marg{a purple type of quartz},
   \field{symbol} = \marg{\gls[noindex=false]{ce}\marg{SiO2}}
}
\strut
\gls{newglossaryentry}\marg{circumference}
\marg{
   \field{name} = \marg{\gls{ensuremath}\marg{C}},
   \field{description} = \marg{circumference}
}
\strut
\gls{newglossaryentry}\marg{duck}
\marg{
   \field{name} = \marg{duck},
   \field{description} = \marg{a waterbird with webbed feet}
}
\gls{newglossaryentry}\marg{goose}
\marg{
   \field{name} = \marg{goose},
   \field{description} = \marg{a large waterbird with a long neck, short legs,
webbed feet and a short broad bill}
}
\strut
\gls{newglossaryentry}\marg{radius}
\marg{
   \field{name} = \marg{\gls{ensuremath}\marg{r}},
   \field{description} = \marg{radius}
}
\strut
\gls{newglossaryentry}\marg{pi}
\marg{
   \field{name} = \marg{\gls{ensuremath}\marg{\cmd{pi}}},
   \field{description} = \marg{Archimedes' constant}
}
\strut
\cmd{begin}\marg{document}
\gls{printunsrtglossary}\oarg{\printglossopt[index]{style}}
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
\glsaddeach{ex3.goose,ex3.duck,ex2.amethyst,standalone.pi,%
standalone.circumference,standalone.area,standalone.radius}%
\setupglossaries{toc=false,section}%
\glossariesextrasetup{postpunc=dot}%
\renewcommand{\glsxtrgroupfield}{useriii}%
\renewcommand*{\printunsrtglossaryentryprocesshook}[1]{%
  \glsifcategory{#1}{standalone}{}{\printunsrtglossaryskipentry}%
}%
\printunsrtglossary[style=index,title=Glossary,nonumberlist,target=false]
\end{result}
The \glostyle{index} glossary style checks if the \field{symbol}
field has been set. If it has, then the symbol is added in
parentheses (as in the amethyst example). Only some of the styles
include the \field{symbol} field. (Table~15.1 in the
\sty{glossaries} user manual~\cite{glossaries} gives an overview of
the features supported by the predefined styles.)

The \glostyle{bookindex} style is provided by the
\isty{glossary-bookindex} package, which is distributed with
\sty{glossaries-extra}. This style is designed for indexes
and omits both the description and the symbol by default. It's
customized specifically for use with \bibgls. Without the
\idxpl{locationlist} obtained by \bibgls, this simply becomes a list
of the \field{name} values for each term.

The glossary is sub-divided into letter groups. By default, these
sub-groups are separated with a vertical gap (for example, between
duck and goose above). In the above example, the letter group is
determined by the first character of the \field{sort} field. Since the
default behaviour of both \sty{glossaries} and
\sty{glossaries-extra} is to use \idx{makeindex}, the \field{sort}
field (which is used by \idx{makeindex}) is set to the value of the
\field{name} field (unless explicitly set) and then sanitized.

When using \gls{printunsrtglossary}, the \field{sort} field is
irrelevant except to determine the letter group (unless the
\field{group} field has been defined). The sub-group
heading is displayed by some styles, such as the
\glostyle{indexgroup} and \glostyle{bookindex} styles. For example, with:
\begin{codeenv}
\gls{printunsrtglossary}\oarg{\printglossopt[indexgroup]{style}}
\end{codeenv}
The glossary is now:
\begin{result}
\setupglossaries{toc=false,section}%
\glossariesextrasetup{postpunc=dot}%
\renewcommand{\glsxtrgroupfield}{useriii}%
\renewcommand*{\printunsrtglossaryentryprocesshook}[1]{%
  \glsifcategory{#1}{standalone}{}{\printunsrtglossaryskipentry}%
}%
\printunsrtglossary[style=indexgroup,title=Glossary,nonumberlist,target=false]
\end{result}
This explains why there's a gap between $A$ (area) and amethyst as
they don't belong to the same letter group. The \field{sort} field
for the \code{area} entry is \verb|\ensuremath{A}| which has been
sanitized, so it starts with a literal backslash (\idx{backslashchar}).
This means that \code{area} is assigned to the symbols letter group. The
symbols group occurs three times, because the list is following the
order of definition.

\subsection{Groups and Locations}
\label{sec:group}

\begin{important}
The \field{group} and \field{location} fields are considered
internal fields by \bibgls. They may be referenced within the
document, but they should not be assigned in the \ext{bib} file.
\bibgls\ assigns these fields according to the resource options and
command line switches. Explicitly assigning them can cause
unexpected results. See also \sectionref{sec:logicaldivisions} of
the \bibgls\ manual.
\end{important}

The \field{group} key isn't defined by default, but if it is defined
then \gls{printunsrtglossary} will use the \field{group} field
instead of trying to determine the group from the first character of
the \field{sort} field (as in the example above). The value of the
\field{group} field must be a label (see \sectionref{sec:labels}). 
A title may be assigned to a group with:
\nosecformatdef{glsxtrsetgrouptitle}
If a title hasn't been assigned, the label is used as the title.
The above command is the preferred form, but the base
\sty{glossaries} package checks for a control sequence in the form
\csfmt{\meta{label}groupname} where \meta{label} is the group label.
The \sty{glossaries-extra} package also recognises this form to
ensure backward-compatibility.  If the \field{group} field is empty
the sub-group won't have a title.

For example, the following defines the \field{group} field with a
custom command \csfmt{grouplabel} (that's not needed, but it's
required by the \gls{glsaddstoragekey} syntax):
\begin{codeenv}
\cmd{documentclass}\marg{scrartcl}
\cmd{usepackage}\marg{mhchem}
\cmd{usepackage}[\styopt[dot]{postpunc},\comment{full stop after description}
 \styopt{nostyles},\comment{don't load default style packages}
 \styopt[tree]{stylemods}\comment{load glossary-tree.sty and patch styles}
]\marg{glossaries-extra}
\strut
\gls{glsaddstoragekey}\marg{group}\marg{}\marg{\cmd{grouplabel}}
\gls{glsxtrsetgrouptitle}\marg{greek}\marg{Greek Symbols}
\strut
\gls{newglossaryentry}\marg{area}
\marg{
   \field{name} = \marg{\gls{ensuremath}\marg{A}},
   \field{description} = \marg{area},
   \field{group} = \marg{A}
}
\strut
\gls{newglossaryentry}\marg{amethyst}
\marg{
   \field{name} = \marg{amethyst},
   \field{description} = \marg{a purple type of quartz},
   \field{symbol} = \marg{\gls{ce}\marg{SiO2}},
   \field{group} = \marg{A}
}
\strut
\gls{newglossaryentry}\marg{circumference}
\marg{
   \field{name} = \marg{\gls{ensuremath}\marg{C}},
   \field{description} = \marg{circumference},
   \field{group} = \marg{C}
}
\strut
\gls{newglossaryentry}\marg{duck}
\marg{
   \field{name} = \marg{duck},
   \field{description} = \marg{a waterbird with webbed feet},
   \field{group} = \marg{D}
}
\strut
\gls{newglossaryentry}\marg{goose}
\marg{
   \field{name} = \marg{goose},
   \field{description} = \marg{a large waterbird with a long neck, short legs,
   webbed feet and a short broad bill},
   \field{group} = \marg{G}
}
\strut
\gls{newglossaryentry}\marg{radius}
\marg{
   \field{name} = \marg{\gls{ensuremath}\marg{r}},
   \field{description} = \marg{radius},
   \field{group} = \marg{R}
}
\strut
\gls{newglossaryentry}\marg{pi}
\marg{
   \field{name} = \marg{\gls{ensuremath}\marg{\cmd{pi}}},
   \field{description} = \marg{Archimedes' constant},
   \field{group} = \marg{greek}
}
\strut
\cmd{begin}\marg{document}
\gls{printunsrtglossary}\oarg{\printglossopt[indexgroup]{style}}
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
\setupglossaries{toc=false,section}%
\glossariesextrasetup{postpunc=dot}%
\renewcommand{\glsxtrgroupfield}{useriv}%
\glsxtrsetgrouptitle{greek}{Greek Symbols}%
\renewcommand*{\printunsrtglossaryentryprocesshook}[1]{%
  \glsifcategory{#1}{standalone}{}{\printunsrtglossaryskipentry}%
}%
\printunsrtglossary[style=indexgroup,title=Glossary,nonumberlist,target=false]
\end{result}
Note that with this method \emph{every} entry must be assigned a
group or it will be assigned to the empty group.

Similarly, if the \field{location} field is defined, you can use it
to provide a \idx{locationlist}. The \styopt{record} package option
conveniently defines both \field{group} and \field{location}, so the
following can be used instead:
\begin{codeenv}
\cmd{usepackage}[
 \styopt{record},\comment{provides group and location fields (and other stuff)}
 postpunc=dot,nostyles,stylemods={tree}]\marg{glossaries-extra}
\strut
\gls{newglossaryentry}\marg{area}
\marg{
   \field{name} = \marg{\gls{ensuremath}\marg{A}},
   \field{description} = \marg{area},
   \field{group} = \marg{A},
   \field{location} = \marg{page 1}
}
\end{codeenv}
This very quickly becomes tedious and prone to errors as the entries
have to be ordered manually, and every entry must be assigned the
group and location (if required).  Every time the location changes
through edits to the document, the locations must be updated.
However, this is exactly the method that \bibgls\ uses, but it does
it automatically for you by selecting the required data from one or
more \ext{bib} files and then creating a file containing all the
glossary entry definitions with the fields set appropriately. The \ext{aux}
file provides \bibgls\ with the indexing information so that it
knows which entries to select and what the locations are, and how to
order the definitions. See \sectionref{sec:bib2gls} for further
information.

\subsection{Homographs and Hierarchical Terms}
\label{sec:parent}

An entry may be assigned a parent with the \field{parent} key. The
value must be the label of an entry that's already defined. You can
test if an entry has the \field{parent} field set with:
\nosecformatdef{ifglshasparent}
If the \field{name} key is omitted, the value is assumed to be the same as
the parent's \field{name}.
For example:
\begin{codeenv}
\comment{parent:}
\gls{newglossaryentry}\marg{glossary}\marg{\field{name}=\marg{glossary},\field{description}=\marg{}}
\comment{children:}
\gls{newglossaryentry}\marg{glossarycol}
\marg{\comment{settings:}
 \field{parent} = \marg{glossary},\comment{parent label}
 \field{description} = \marg{collection of glosses}
}
\gls{newglossaryentry}\marg{glossarylist}
\marg{\comment{settings:}
 \field{parent} = \marg{glossary},\comment{parent label}
 \field{description} = \marg{list of technical words}
}
\end{codeenv}
In this case the entry with the label \code{glossary} is the
\pidx{parent-entry}, and the entries with
the labels \code{glossarycol} and \code{glossarylist} are 
\pidxpl{child-entry} (or sub-items). An entry that doesn't have a
parent is a main or top-level or level~0 item. In this case, the
\idxpl{child-entry} don't have the \field{name} key, so the name is
obtained from the parent's name. This is an example of a
\pidx{homograph}, where two words with different meanings
have the same spelling. The parent entry has an empty description.

Here's another example:
\begin{codeenv}
\comment{parent:}
\gls{newglossaryentry}\marg{mineral}\comment{label}
\marg{\comment{settings:}
  \field{name} = \marg{mineral},
  \field{description} = \marg{natural inorganic substance}
}
\comment{sub-entries:}
\gls{newglossaryentry}\marg{quartz}\comment{label}
\marg{
  \field{parent} = \marg{mineral},\comment{parent label}
  \field{name} = \marg{quartz},
  \field{description} = \marg{hard mineral consisting of silica}
}
\gls{newglossaryentry}\marg{amethyst}\comment{label}
\marg{
  \field{parent} = \marg{quartz},\comment{parent label}
  \field{name} = \marg{amethyst},
  \field{description} = \marg{a purple type of quartz}
}
\end{codeenv}
In this case, the \idxpl{child-entry} have the \field{name} key
set. This is an example of a set of \pidxpl{hierarchical-entry},
where each \idx{child-entry} is a sub-category of the parent.
Some glossary styles are appropriate for \idxpl{homograph} and some
are appropriate for \idxpl{hierarchical-entry} and some are only
appropriate for flat glossaries (no child entries).
For example, the \glostyle{index}, \glostyle{indexgroup},
\glostyle{tree} and \glostyle{treegroup} styles are appropriate 
for \idxpl{hierarchical-entry}:
\begin{codeenv}
\cmd{documentclass}\marg{scrartcl}
\strut
\cmd{usepackage}[\styopt{nostyles},\styopt[dot]{postpunc},\styopt[tree]{stylemods}]\marg{glossaries-extra}
\strut
\gls{newglossaryentry}\marg{animal}
\marg{
   \field{name} = \marg{animal},
   \field{description} = \marg{living organism with a nervous system and sense organs
    that can move independently}
}
\strut
\gls{newglossaryentry}\marg{bird}
\marg{
  \field{parent} = \marg{animal},
  \field{name} = \marg{bird},
  \field{description} = \marg{warm-blooded egg-laying animal with feathers, wings
   and a beak}
}
\strut
\gls{newglossaryentry}\marg{duck}
\marg{
   \field{parent} = \marg{bird},
   \field{name} = \marg{duck},
   \field{description} = \marg{a waterbird with webbed feet}
}
\strut
\gls{newglossaryentry}\marg{goose}
\marg{
   \field{parent} = \marg{bird},
   \field{name} = \marg{goose},
   \field{description} = \marg{a large waterbird with a long neck, short legs,
   webbed feet and a short broad bill}
}
\strut
\gls{newglossaryentry}\marg{mineral}
\marg{
  \field{name} = \marg{mineral},
  \field{description} = \marg{natural inorganic substance}
}
\strut
\gls{newglossaryentry}\marg{calcite}\comment{label}
\marg{
  \field{parent} = \marg{mineral},\comment{parent label}
  \field{name} = \marg{calcite},
  \field{description} = \marg{a carbonate mineral}
}
\strut
\gls{newglossaryentry}\marg{quartz}
\marg{
  \field{parent} = \marg{mineral},
  \field{name} = \marg{quartz},
  \field{description} = \marg{hard mineral consisting of silica}
}
\strut
\gls{newglossaryentry}\marg{amethyst}
\marg{
   \field{parent} = \marg{quartz},
   \field{name} = \marg{amethyst},
   \field{description} = \marg{a purple type of quartz},
}
\strut
\gls{newglossaryentry}\marg{citrine}
\marg{
  \field{parent} = \marg{quartz},
  \field{name} = \marg{citrine},
  \field{description} = \marg{a form of quartz with a colour ranging
  from pale yellow to brown due to ferric impurities}
}
\strut
\cmd{begin}\marg{document}
\gls{printunsrtglossary}\oarg{style=indexgroup}
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
\glsaddeach{hier.animal,hier.bird,hier.duck,hier.goose,hier.mineral,%
hier.calcite,hier.quartz,hier.amethyst,hier.citrine}%
\setupglossaries{toc=false,section}%
\glossariesextrasetup{postpunc=dot}%
\renewcommand*{\printunsrtglossaryentryprocesshook}[1]{%
  \glsifcategory{#1}{hierarchical}{}{\printunsrtglossaryskipentry}%
}%
\printunsrtglossary[style=indexgroup,title=Glossary,nonumberlist,target=false]
\end{result}

The \glostyle{treenoname} and \glostyle{treenonamegroup} styles are
appropriate for \idxpl{homograph}. These are usually best with the
\styopt{subentrycounter} package option, which defines the
\counter{glossarysubentry} counter that's incremented and
displayed for every level~1 entry (that is, an entry with a parent
but not a grandparent). If the \styopt{entrycounter} option is also
used, \counter{glossaryentry} is set as the master counter for
\counter{glossarysubentry} (although it's not included in the 
display form of that counter), but \styopt{subentrycounter} may be used
without \styopt{entrycounter}, in which case
\counter{glossarysubentry} has no master counter. If
\styopt{subentrycounter} is used as a package option and
\styopt{entrycounter} is later switched on outside of the package
option list (through \gls{setupglossaries} or in the optional argument of
\gls{printunsrtglossary}) then it won't be made the master counter.

For example:
\begin{codeenv}
\cmd{documentclass}\marg{scrartcl}
\strut
\cmd{usepackage}[\styopt{subentrycounter},\comment{create glossarysubentry counter}
 \styopt[dot]{postpunc},\comment{append full stop after description}
 \styopt{nostyles},\styopt[tree]{stylemods}]\marg{glossaries-extra}
\strut
\gls{newglossaryentry}\marg{bow1}
\marg{
 \field{name}=\marg{bow},
 \field{description}=\marg{(rhymes with toe)}
}
\strut
\gls{newglossaryentry}\marg{bowknot}
\marg{
  \field{parent} = \marg{bow1},
  \field{description} = \marg{a knot tied with two loops and loose ends}
}
\strut
\gls{newglossaryentry}\marg{bowweapon}
\marg{
  \field{parent} = \marg{bow1},
  \field{description} = \marg{a weapon for shooting arrows, made of curved wood
  joined at both ends with taut string}
}
\strut
\gls{newglossaryentry}\marg{bow2}
\marg{
 \field{name}=\marg{bow},
 \field{description}=\marg{(rhymes with cow)}
}
\strut
\gls{newglossaryentry}\marg{bowbend}
\marg{
  \field{parent} = \marg{bow2},
  \field{description} = \marg{bend head or upper body}
}
\strut
\gls{newglossaryentry}\marg{bowpressure}
\marg{
  \field{parent} = \marg{bow2},
  \field{description} = \marg{give in to pressure}
}
\strut
\gls{newglossaryentry}\marg{bow3}
\marg{
 \field{name}=\marg{bow},
 \field{description}=\marg{(also bows) the front end of a ship}
}
\strut
\gls{newglossaryentry}\marg{glossary}\marg{\field{name}=\marg{glossary},\field{description}=\marg{}}
\strut
\gls{newglossaryentry}\marg{glossarycol}
\marg{
  \field{parent} = \marg{glossary},
  \field{description} = \marg{collection of glosses}
}
\strut
\gls{newglossaryentry}\marg{glossarylist}
\marg{
  \field{parent} = \marg{glossary},
  \field{description} = \marg{list of technical words}
}
\strut
\cmd{begin}\marg{document}
\gls{printunsrtglossary}\oarg{style=treenoname}
\cmd{end}\marg{document}
\end{codeenv}
This produces
\begin{result}
\glsaddeach{hom.bow1,hom.bowknot,hom.bowweapon,%
hom.bow2,hom.bowbend,hom.bowpressure,hom.bow3,%
hom.glossary,hom.glossarycol,hom.glossarylist}%
\setupglossaries{toc=false,section,subentrycounter}%
\glossariesextrasetup{postpunc=dot}%
\renewcommand*{\printunsrtglossaryentryprocesshook}[1]{%
  \glsifcategory{#1}{homograph}{}{\printunsrtglossaryskipentry}%
}%
\printunsrtglossary[style=treenoname,title=Glossary,nonumberlist,target=false]
\end{result}
The empty description for the top-level \code{glossary} entry has
caused an odd effect with a space occurring between the name and the
post-description punctuation. This can be removed by redefining:
\nosecformatdef{glstreenonamedesc}
so that it checks if the \field{description} field has been set with:
\nosecformatdef{ifglshasdesc}
For example:
\begin{codeenv}
\cmd{renewcommand}\marg{\gls{glstreenonamedesc}}[1]\marg{\comment{}
  \gls{ifglshasdesc}\marg{\gls{param}1}
  \marg{\gls[noindex=false]{glstreepredesc}\gls{glossentrydesc}\marg{\gls{param}1}\gls{glspostdescription}}
  \marg{}\comment{do nothing, description field is empty}
}
\end{codeenv}
Another variation is to check if the entry has children add use a
colon instead of a \idx{full-stop}. The base \sty{glossaries}
package provides:
\nosecformatdef{ifglshaschildren}
However this method is very inefficient as it has to iterate over
all defined entries and check if any have the \field{parent} field
set to \meta{entry label}. A more efficient method can be obtained
with \bibgls\ and the \csopt{save-child-count} resource option,
which will save the number of child entries that have been indexed
in an internal field labelled \field{childcount} and a list of child
entry labels is stored in the internal field labelled
\field{childlist}. In this case, a more efficient method is to use:
\nosecformatdef{GlsXtrIfHasNonZeroChildCount}
which checks the \field{childcount} field for a non-zero value.
If you don't use \bibgls, this command will always do \meta{false}
(unless you explicitly set the internal fields to the correct
values, which is tedious and has to be updated whenever 
definitions are added, deleted or have the \field{parent} field
changed).

Another variation could use custom fields (see
\sectionref{sec:userkeys}) to store the pronunciation guide (\qt{rhymes
with \ldots}) and the alternative version (\qt{also \ldots}) as well
as other information, such as whether the word is a noun or verb.

\subsection{Multiple Glossaries}
\label{sec:multigloss}

The default glossary has the label \code{main}, but it can also be referenced 
with:
\nosecformatdef{glsdefaulttype}
The \styopt{nomain} package option suppresses the creation of the
\code{main} glossary, in which case \gls{glsdefaulttype} will be set to
the first glossary to be defined. (There must be at least one
glossary defined, so if you use \styopt{nomain} you must provide
another default.) If you use the \styopt{entrycounter} package
option, the associated counter isn't reset at the start of the
glossary. If you have multiple glossaries and you need it to be reset, add:
\nosecformatdef{glsresetentrycounter}
before the start of the appropriate glossary.

Abbreviations defined with \gls{newabbreviation}
(see \sectionref{sec:abbreviations}) are, by default, assigned to the glossary 
given by:
\nosecformatdef{glsxtrabbrvtype}
This initially expands to \gls{glsdefaulttype}, but the
\styopt{abbreviations} option redefines this to \code{abbreviations}
and creates a glossary with that label.

Abbreviations defined with \gls{newacronym} are, by default,
assigned to the glossary given by:
\nosecformatdef{acronymtype}
This initially expands to \gls{glsdefaulttype}, but the
\styopt{abbreviations} option redefines this to
\gls{glsxtrabbrvtype}. However, the \styopt{acronyms} option
redefines \gls{acronymtype} to \code{acronym} and creates a glossary
with that label. So if you use both the \styopt{abbreviations} and
\styopt{acronyms} package options, you will have two extra
glossaries created, one as the default for \gls{newabbreviation} and
the other as the default for \gls{newacronym}.

The \styopt{symbols} package option creates a glossary with the
label \code{symbols} and defines \gls{glsxtrnewsymbol} (see 
\sectionref{sec:symbols}) which sets the \field{type} to
\code{symbols}. There are also similar package options
\styopt{numbers} and \styopt{index}, which create the \code{numbers}
glossary (and \gls{glsxtrnewnumber}) and the \code{index} glossary
(and \gls{newterm}).

In each case, the default type can be overridden when defining an
entry by using the \field{type} key in the assignment list. The
value must be the label identifying a defined glossary.

You can provide your own custom glossary using:
\nosecformatdef{newglossary*}
where \meta{type} is the label used to identify the glossary and
\meta{title} is the default title used by \gls{printunsrtglossary}.
(The unstarred version has a different syntax and is only applicable 
with \gls{makeindex} or \gls{xindy}.) For example:
\begin{codeenv}
\gls{newglossary*}\marg{measurements}\marg{SI Units}
\gls{newglossaryentry}\marg{length}
\marg{\comment{settings:}
  \field{name} = \marg{\gls{si}\marg{\cmd{metre}}},
  \field{description} = \marg{length},
  \field{type} = \marg{measurements}\comment{glossary label}
}
\end{codeenv}
In this case, the label identifying the new glossary is
\code{measurements} and the title is \qt{SI Units}.

You can specify the glossary using the \printglossopt{type} setting
in the optional argument of \gls{printunsrtglossary}. For example, 
the above \code{measurements} glossary can be displayed with:
\begin{codeenv}
\gls{printunsrtglossary}\oarg{\printglossopt[measurements]{type}}
\end{codeenv}
For convenience, there's a command that iterates over all defined
glossaries (in the order of definition) and does
\gls{printunsrtglossary}\oarg{\printglossopt[\meta{label}]{type}}
for each glossary:
\nosecformatdef{printunsrtglossaries}
There's no optional argument for this command. When creating
glossaries with package options, such as \styopt{abbreviations}, you
may find an unexpected order as the options aren't always processed
in the order in which they were specified. (Some
\sty{glossaries-extra} options are passed to the base
\sty{glossaries} package and are processed when that package is
internally loaded not when the extension options are processed.) In
which case you need to use \gls{printunsrtglossary} for each
glossary in the required order. You will also need to do this if the
glossary settings are different. (For example, if one glossary needs
to use the \glostyle{tree} style and another needs to use the
\glostyle{treenoname} style.)

You can also define an \pidx{ignoredglossary}, which is ignored by
\gls{printunsrtglossaries}. This is a useful way of creating a
glossary for common terms that shouldn't appear in a list or for
stand-alone entries (see \sectionref{sec:standalone}). The unstarred
form:
\nosecformatdef{newignoredglossary}
is useful for common terms where the list won't be displayed as it
automatically suppresses hyperlinks for entries assigned to that
glossary. The starred form:
\nosecformatdef{newignoredglossary*}
is useful for stand-alone entries as it doesn't automatically
suppress the hyperlinks.
Although \gls{printunsrtglossaries} skips \idxpl{ignoredglossary},
it's still possible to display an \idx{ignoredglossary} with
\gls{printunsrtglossary} but you'll need to use the
\printglossopt{title} option to override the default title.

\subsection{Redisplaying or Filtering a Glossary}
\label{sec:printglossagain}

It's possible to use \gls{printunsrtglossary} multiple times for the
same glossary, but if you have hyperlinks you will need to either
suppress the targets with \printglossopt[false]{target} or change
the target name (see \sectionref{sec:targetnames}).

The starred form of \gls{printunsrtglossary} has an extra
argument:
\nosecformatdef{printunsrtglossary*}
This may be used to make local assignments. It's equivalent to:
\begin{codeenv}
\cmd{begingroup} \meta{code}\gls{printunsrtglossary}\oargm{options}\cmd{endgroup}
\end{codeenv}
For example, if the \field{group} key has been defined (see
\sectionref{sec:group}) you can locally switch to a different field
for the group label by redefining:
\nosecformatdef{glsxtrgroupfield}
within \meta{code}.
For example, if the \field{secondarygroup} field has been defined:
\begin{codeenv}
\gls{printunsrtglossary*}\marg{\comment{}
  \cmd{renewcommand}\marg{\gls{glsxtrgroupfield}}\marg{secondarygroup}\comment{}
}
\end{codeenv}
Note that this just changes the group labels. The order is still
according to the glossary's internal list of labels.

Unlike \gls{printglossary} (used with \gls{makeindex} and
\gls{xindy}) which inputs a file containing the code to typeset the glossary,
\gls{printunsrtglossary} iterates over the labels defined in the
given glossary and adds the appropriate code to an internal command.
Once the construction of the internal command is completed, it's
then performed. (The construction of this internal command is done
to avoid complications when iterating within \env{tabular}-like
environments, as some of the styles use \env{longtable} or
\env{supertabular}.) There's a hook just before the internal command is 
expanded:
\nosecformatdef{printunsrtglossarypredoglossary}
The glossary header and preamble are displayed before 
the loop starts, so this hook won't change them (but you can make
local changes in \meta{code} outside of the hook).
The style is also set before the loop, but the start
and end of the \env{theglossary} environment (which is defined by
the glossary styles) is included in the internal command, so minor
adjustments to the style can be made in this hook.

There's another hook that's performed at each iteration:
\nosecformatdef{printunsrtglossaryentryprocesshook}
where \meta{label} is the current entry label. For example, the
\glostyle{alttree} style needs to know the widest entry name in
order to set up the correct indentation. The widest name is set
using:
\nosecformatdef{glssetwidest}
but this requires knowing which entry has the widest name. There are
some commands provided by the \sty{glossary-tree} and
\sty{glossaries-extra-stylemods} packages that iterate over all
entries, measuring each name, in order to find the widest, but since
\gls{printunsrtglossary} already has to iterate over the list before
typesetting it, this hook can be used to update the widest name at
the same time. You can update the value with:
\nosecformatdef{glsupdatewidest}
which computes the width of \meta{text} and, if it's wider than the
current widest name for the given level, sets the widest value to
\meta{text} (without expanding it). If \meta{text} needs expanding
you need to use:
\nosecformatdef{eglsupdatewidest}
The \meta{level} refers to the entry's hierarchical level with a
value of~0 indicating top-level (that is, an entry without a parent).
The level is stored in the internal \field{level} field and can only
be accessed with \gls{glsxtrusefield} or similar commands 
(see \sectionref{sec:userkeys}).

You can also redefine this hook to filter the glossary list. 
If an entry shouldn't appear in the list, use:
\nosecformatdef{printunsrtglossaryskipentry}
For example, to only include entries that have the \field{category}
set to \code{formula}:
\begin{codeenv}
\gls{printunsrtglossary*}\oarg{\printglossopt{target}=false,\printglossopt{title}=\marg{Formula}}
\marg{\comment{local code:}
  \cmd{renewcommand}\marg{\gls{printunsrtglossaryentryprocesshook}}[1]\marg{\comment{}
   \gls{glsifcategory}\marg{\gls{param}1}\marg{formula}
   \marg{}\comment{category = formula}
   \marg{\gls{printunsrtglossaryskipentry}}\comment{}
  }\comment{}
}
\end{codeenv}
This uses \gls{glsifcategory} to check the value of the entry's 
\field{category} field (see \sectionref{sec:categories}). Another
conditional you might find useful is:
\nosecformatdef{glsxtriflabelinlist}
which tests if the given \meta{label} is in the comma-separated
\meta{list} of labels. Both \meta{label} and \meta{list} are fully
expanded before testing. This command is only intended for labels,
which must be fully expandable.
For example, the following excludes any entries that have the
\field{category} set to \code{abbreviation} or \code{acronym}:
\begin{codeenv}
\gls{printunsrtglossary*}\oarg{\printglossopt{target}=false,\printglossopt{title}=\marg{Formula}}
\marg{\comment{local code:}
  \cmd{renewcommand}\marg{\gls{printunsrtglossaryentryprocesshook}}[1]\marg{\comment{}
   \gls{glsxtriflabelinlist}
   \marg{\gls{glscategory}\marg{\gls{param}1}}\comment{category label for this entry}
   \marg{abbreviation,acronym}\comment{exclusion list}
   \marg{\gls{printunsrtglossaryskipentry}}\comment{skip (exclude)}
   \marg{}\comment{don't skip (include)}
  }\comment{}
}
\end{codeenv}

\subsection{Hyperlink Targets}
\label{sec:targetnames}

The naming system used for the hyperlinks from commands like
\gls{gls} and \gls{glssymbol} to the corresponding definition in the
glossary is given by \meta{prefix}\meta{label} where \meta{label} is
the entry's label and \meta{prefix} is given by:
\nosecformatdef{glolinkprefix}
This can locally be changed within commands like \gls{gls} and
\gls{glssymbol} with the \glsopt{prefix} option. There is a matching
\printglossopt{prefix} option for \gls{printunsrtglossary}.
You can set an additional prefix in the glossary with
\printglossopt[\meta{extra}]{targetnameprefix}, which means that the
target name in the glossary is now
\code{\meta{extra}\gls{glolinkprefix}\meta{label}} (so
\printglossopt{targetnameprefix} doesn't modify \gls{glolinkprefix}
but prepends an extra prefix).

If you change the prefix either by using the above options or by
redefining \gls{glolinkprefix}, you need to make sure that the
target names match for the links to work correctly.
The \styopt[showtargets]{debug} package option can be used to show
the target names in the document. The target is displayed in the
document using:
\nosecformatdef{glsshowtarget}
which may be redefined as appropriate. For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{hyperref}
\cmd{usepackage}[\styopt{debug}=showtargets]\marg{glossaries-extra}
\strut
\gls{newglossaryentry}\marg{sample}\marg{\field{name}=\marg{sample},\field{description}=\marg{an example}}
\strut
\cmd{begin}\marg{document}
\gls{gls}\oarg{\glsopt{prefix}=\marg{TARGET.}}\marg{sample}.
\strut
\gls{printunsrtglossary}\oarg{\printglossopt{prefix}=\marg{TARGET.}}
\gls{printunsrtglossary}\oarg{\printglossopt{prefix}=\marg{TARGET.},\printglossopt{targetnameprefix}=\marg{EXTRA.}}
\cmd{end}\marg{document}
\end{codeenv}

\section{Stand-alone Definitions}
\label{sec:standalone}

The \sty{glossaries-extra} package provides:
\nosecformatdef{glsxtrglossentry}
which may be used to create a target for a particular entry (identified by
\meta{label}). This displays the value of the \field{name} field,
but it also obeys the \idx{postnamehook} (see
\sectionref{sec:postfieldhooks}), the \catattr{glossname}
and \catattr{glossnamefont} attributes (see
\sectionref{sec:glossname}), and provides accessibility support if
the \field{access} field is set (see \sectionref{sec:accsupp}).
This command may be used for both top-level and child entries, and
will obey the \styopt{entrycounter} (see below) and \styopt{subentrycounter}
(see \sectionref{sec:parent}) package options according to the
entry's hierarchical level.

This command doesn't display any of the other field values. 
If any are required, you need to add them afterwards.
For the description, you can use \gls{glsentrydesc}, but it's better
to use:
\nosecformatdef{glossentrydesc}
Unlike \gls{glsentrydesc}, which just displays the value of the
\field{description} field, \gls{glossentrydesc} obeys the
\catattr{glossdesc} and \catattr{glossdescfont} attributes
(\sectionref{sec:glossname}). Alternatively, you can use:
\nosecformatdef{Glossentrydesc}
which converts the first letter of the description to
\idx{uppercase}.
To pick up the \styopt{postpunc} setting and the
\glslink{postdescriptionhook}{post-description category hook}, 
append \gls{glspostdescription}
after the description (see \sectionref{sec:postfieldhooks}).

There's a similar command for symbols:
\nosecformatdef{glossentrysymbol}
There are currently no category attributes governing this
command, but it does check for the \field{symbolaccess} field if
accessibility support has been added (see \sectionref{sec:accsupp}). 
For other fields, you can use the commands described in
\sectionref{sec:userkeys}.

If you need to substitute the \field{name} for another field in the
target, you can use:
\nosecformatdef{glsxtrglossentryother}
instead of \code{\gls{glsxtrglossentry}\margm{label}},
where \meta{label} identifies the entry and \meta{field} is the
internal field label to use instead of the \field{name}. The
\meta{header} argument is the code to use in the header (which
should be left empty for the default value\footnote{The
\meta{header} argument doesn't use standard \LaTeX\ optional syntax
\code{\oargm{option}} because \gls{glsxtrglossentryother} has to be 
expandable in order for it to work correctly in section arguments.})\ if
\gls{glsxtrglossentryother} is used in a sectioning command. This
command obeys the \catattr{glossname} and \catattr{glossnamefont}
attributes and the \idx{postnamehook}, even though it's not actually
displaying the name. For example,
\begin{codeenv}
\cmd{section}\marg{\gls{glsxtrglossentryother}\marg{}\marg{duck}\marg{\field{plural}}}
\end{codeenv}

Here's a complete example that uses \gls{glsxtrglossentry} after an
equation to describe the notation:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{\gls[noindex=false]{xcolor}}\comment{provides colour}
\cmd{usepackage}[colorlinks,linkcolor=purple]\marg{\gls[noindex=false]{hyperref}}
\cmd{usepackage}[\styopt[dot]{postpunc}]\marg{glossaries-extra}
\strut
\gls{newglossaryentry}\marg{pi}
\marg{
   \field{name} = \marg{\gls{ensuremath}\marg{\cmd{pi}}},
   \field{description} = \marg{Archimedes' constant}
}
\strut
\gls{newglossaryentry}\marg{radius}
\marg{
   \field{name} = \marg{\gls{ensuremath}\marg{r}},
   \field{description} = \marg{radius}
}
\strut
\gls{newglossaryentry}\marg{area}
\marg{
   \field{name} = \marg{\gls{ensuremath}\marg{A}},
   \field{description} = \marg{area}
}
\strut
\cmd{begin}\marg{document}
\cmd{begin}\marg{equation}
\gls{gls}\marg{area} = \gls{gls}\marg{pi}\gls{gls}\marg{radius}[\gls{spchar}2]
\cmd{end}\marg{equation}
\cmd{begin}\marg{tabular}\marg{ll}
\gls{glsxtrglossentry}\marg{area} \gls[noindex=false]{colsep} \gls{glossentrydesc}\marg{area}\gls{glspostdescription}\gls[noindex=false]{cs.backslash}
\gls{glsxtrglossentry}\marg{pi} \gls{colsep} \gls{glossentrydesc}\marg{pi}\gls{glspostdescription}\gls{cs.backslash}
\gls{glsxtrglossentry}\marg{radius} \gls{colsep} \gls{glossentrydesc}\marg{radius}\gls{glspostdescription}
\cmd{end}\marg{tabular}
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
\setcounter{equation}{0}%
\renewcommand{\theequation}{\arabic{equation}}%
\renewcommand{\theHequation}{\thechapter.standalone1.\arabic{equation}}%
\renewcommand{\glolinkprefix}{standalone1}%
\renewcommand{\glstextformat}[1]{\textcolor{purple}{#1}}%
\renewcommand{\glslinkpresetkeys}{\setkeys{glslink}{local}}%
\glossariesextrasetup{postdot}%
\begin{equation}
\gls{standalone.area} = \gls{standalone.pi}\gls{standalone.radius}[^2]
\end{equation}
\begin{tabular}{ll}
\glsxtrglossentry{standalone.area} & \glossentrydesc{standalone.area}\glspostdescription\\
\glsxtrglossentry{standalone.pi} & \glossentrydesc{standalone.pi}\glspostdescription\\
\glsxtrglossentry{standalone.radius} & \glossentrydesc{standalone.radius}\glspostdescription
\end{tabular}
\end{result}
The purple text shows the hyperlinks to the relevant definition. As
with \gls{printunsrtglossary}, the hypertargets are prefixed with
\gls{glolinkprefix} (see \sectionref{sec:printglossagain}).  This
can be locally changed to avoid clashes if the definition needs to
be reproduced later.

A more convenient approach to the above is to define an environment that can
list all the referenced entries automatically. The
\sty{glossaries-extra} package provides a way of buffering the
boolean switch performed by \gls{gls} that ensures that the
\idx{firstuseflag} is unset (see \sectionref{sec:buffering}). 
This is intended for use where the switch causes a problem, but it
can also be used in this case to store a list of used entries (since
there's no difference between \idx{firstuse} and subsequent use in
this case, it won't affect the \idx{link-text}).

Here's a modified version of the above document:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{xcolor}
\cmd{usepackage}[colorlinks,linkcolor=purple]\marg{hyperref}
\cmd{usepackage}[\styopt[dot]{postpunc}]\marg{glossaries-extra}
\strut
\gls{newglossaryentry}\marg{pi}
\marg{
   \field{name} = \marg{\gls{ensuremath}\marg{\cmd{pi}}},
   \field{description} = \marg{Archimedes' constant}
}
\strut
\gls{newglossaryentry}\marg{radius}
\marg{
   \field{name} = \marg{\gls{ensuremath}\marg{r}},
   \field{description} = \marg{radius}
}
\strut
\gls{newglossaryentry}\marg{area}
\marg{
   \field{name} = \marg{\gls{ensuremath}\marg{A}},
   \field{description} = \marg{area}
}
\strut
\gls{newglossaryentry}\marg{circumference}
\marg{
   \field{name} = \marg{\gls{ensuremath}\marg{C}},
   \field{description} = \marg{circumference}
}
\strut
\cmd{newcommand}\marg{\cmd{doglossaryentry}}[1]\marg{\comment{handler macro}
  \gls{glsxtrglossentry}\marg{\gls{param}1} \gls{colsep} \gls{glossentrydesc}\marg{\gls{param}1}\gls{glspostdescription}\gls{cs.backslash}\comment{}
}
\strut
\cmd{newcounter}\marg{localglossary}
\strut
\cmd{newenvironment}\marg{localglossary}
\marg{\comment{}
  \cmd{stepcounter}\marg{localglossary}\comment{}
  \cmd{renewcommand}\marg{\gls{glolinkprefix}}\marg{\cmd{thelocalglossary}.}\comment{}
  \gls{GlsXtrStartUnsetBuffering}*
}
\marg{\comment{}
  \cmd{par}
  \cmd{begin}\marg{tabular}\marg{ll}
  \gls{GlsXtrForUnsetBufferedList}\cmd{doglossaryentry}
  \cmd{end}\marg{tabular}
  \gls{GlsXtrStopUnsetBuffering}
  \cmd{par}
}
\strut
\cmd{begin}\marg{document}
The area of a circle is given by:
\cmd{begin}\marg{localglossary}
\cmd{begin}\marg{equation}
\gls{gls}\marg{area} = \gls{gls}\marg{pi}\gls{gls}\marg{radius}[\gls{spchar}2]
\cmd{end}\marg{equation}
\cmd{end}\marg{localglossary}
The circumference of a circle is given by:
\cmd{begin}\marg{localglossary}
\cmd{begin}\marg{equation}
\gls{gls}\marg{circumference} = 2\gls{gls}\marg{pi}\gls{gls}\marg{radius}
\cmd{end}\marg{equation}
\cmd{end}\marg{localglossary}
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
\setcounter{equation}{0}%
\renewcommand{\theequation}{\arabic{equation}}%
\renewcommand{\theHequation}{\thechapter.standalone2.\arabic{equation}}%
\renewcommand{\glolinkprefix}{standalone2}%
\renewcommand{\glstextformat}[1]{\textcolor{purple}{#1}}%
\renewcommand{\glslinkpresetkeys}{}%
\glossariesextrasetup{postdot}%
The area of a circle is given by:
\begin{localglossary}
\begin{equation}
\gls{standalone.area} = \gls{standalone.pi}\gls{standalone.radius}[^2]
\end{equation}
\end{localglossary}
The circumference of a circle is given by:
\begin{localglossary}
\begin{equation}
\gls{standalone.circumference} = 2\gls{standalone.pi}\gls{standalone.radius}
\end{equation}
\end{localglossary}
\end{result}
The custom \counterfmt{localglossary} counter is defined and incremented to
ensure that the target prefix \gls{glolinkprefix} is unique for each
environment. This definition of the custom \envfmt{localglossary}
environment is intentionally kept trivial since the main point here is
the demonstration of \gls{glsxtrglossentry} and the buffering rather
than the actual formatting of the entries. Additional vertical
spacing, appropriate alignment and a paragraph column specifier are
left as an exercise for the reader.

\subsection{Numbering Top-Level Entries}
\label{sec:entrycounter}

The \styopt{entrycounter} package option creates a new counter
called \counter{glossaryentry}, which will automatically be
incremented and displayed at the start of \gls{glsxtrglossentry}
for top-level entries. (The \counter{glossarysubentry} counter created with the
\styopt{subentrycounter} option, described in \sectionref{sec:parent},
may be used independently of the \styopt{entrycounter} package option.) In
the above example, this counter will need to depend on the custom
\counterfmt{localglossary} counter to ensure that it's reset at the
start of each \envfmt{localglossary} environment. This can easily be
done by using the name of the master counter as the value of
\styopt{counterwithin} (which automatically implements
\styopt{entrycounter}), but the master counter must be defined
first:
\begin{codeenv}
\cmd{newcounter}\marg{localglossary}
\cmd{usepackage}[\styopt[localglossary]{counterwithin}]\marg{glossaries-extra}
\end{codeenv}
The default definition of \gls{theHglossaryentry} is:
\begin{codeenv}
\gls{currentglossary}.\gls[noindex=false]{theglossaryentry}
\end{codeenv}
The prefix \gls{currentglossary} is set by both
\gls{printunsrtglossary} and \gls{glsxtrglossentry} to the current
glossary label (given by the \printglossopt{type} option in
\gls{printunsrtglossary} and by the entry's \field{type} field for
\gls{glsxtrglossentry}). In the case of \gls{glsxtrglossentry}
(and \gls{glsxtrglossentryother}), the value of
\gls{currentglossary} is obtained from:
\nosecformatdef{GlsXtrStandaloneGlossaryType}
which defaults to the value of the \field{type} field for the
current entry.

Since this example is using multiple stand-alone definitions that
may repeat the same entry, this definition isn't appropriate and will 
cause duplicate destination warnings. The simplest solution is to redefine
\gls{GlsXtrStandaloneGlossaryType} in terms of the custom
\counterfmt{localglossary} counter value:
\begin{codeenv}
\cmd{renewcommand}\marg{\cmd{GlsXtrStandaloneGlossaryType}}\marg{\comment{}
 standalone.\cmd{thelocalglossary}.\cmd{arabic}\marg{\counter{glossaryentry}}\comment{}
}
\end{codeenv}

Unlike commands such as \gls{gls}, which can be problematic in moving
arguments, \gls{glsxtrglossentry} is designed to work in section
headings. For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{mhchem}
\cmd{usepackage}[colorlinks,linkcolor=magenta]\marg{hyperref}
\cmd{usepackage}[\styopt[dot]{postpunc}]\marg{glossaries-extra}
\strut
\gls{newglossaryentry}\marg{amethyst}
\marg{
   \field{name} = \marg{amethyst},
   \field{description} = \marg{a purple type of quartz},
   \field{symbol} = \marg{\gls{ce}\marg{SiO2}},
   \field{category} = \marg{mineral}
}
\strut
\gls{glssetcategoryattribute}\marg{mineral}\marg{glossname}\marg{firstuc}
\strut
\cmd{newcommand}\marg{\cmd{displayterm}}[1]\marg{\comment{}
 \cmd{subsection}\marg{\gls{glsxtrglossentry}\marg{\gls{param}1}}\comment{}
 Chemical formula: \gls{glossentrysymbol}\marg{\gls{param}1}.
 \gls{Glossentrydesc}\marg{\gls{param}1}\gls{glspostdescription}\cmd{par}
}
\cmd{begin}\marg{document}
\gls{tableofcontents}
\cmd{section}\marg{Types of Quartz}
A reference to \gls{gls}\marg{amethyst}.
\strut
\cmd{displayterm}\marg{amethyst}
\cmd{end}\marg{document}
\end{codeenv}
(Again, improvements to the actual formatting of the custom
\csfmt{displayterm} is left as an exercise to the reader. Additional
fields could contain, for example, the name of an image file to
illustrated the entry. See the
\href{https://www.dickimaw-books.com/gallery/}{\styfmt{glossaries}
gallery}~\cite{gallery} for further ideas.)

The above example uses the \catattr{glossname} attribute to convert the first
letter of the \field{name} to \idx{uppercase}. Unfortunately this can't be
applied to the PDF bookmark or \gls{toc}. A solution to this
would be to explicitly set the \field{name} with the first letter as
an \idx{uppercase} character and the \field{text} field in
\idx{lowercase}. For example:
\begin{codeenv}
\gls{newglossaryentry}\marg{amethyst}
\marg{
   \field{name} = \marg{Amethyst},
   \field{text} = \marg{amethyst},
   \field{description} = \marg{a purple type of quartz},
   \field{symbol} = \marg{\gls{ce}\marg{SiO2}},
   \field{category} = \marg{mineral}
}
\end{codeenv}
The \catattr{glossname} attribute can then be omitted. This is a bit
inconvenient, but if you use \bibgls\ (see \sectionref{sec:bib2gls})
this can be performed automatically with the
\csopt{name-case-change} resource option.

\subsection{Stand-alone Hierarchical Entries}
\label{sec:standalonehierarchy}

Sub-entries can also be displayed with \gls{glsxtrglossentry} or
\gls{glsxtrglossentryother}. These check if the entry has a parent
(with \gls{ifglshasparent}).  If it doesn't, then it will display
the \counter{glossaryentry} counter label if the
\styopt{entrycounter} package option has been used. If the entry
does have a parent, it uses:
\nosecformatdef{GlsXtrStandaloneSubEntryItem}
which checks the internal \field{level} field to
determine the hierarchical level. If the \field{level} is~1 (that
is, the entry has a parent but not a grandparent) then it will
display the \counter{glossarysubentry} label if that counter has
been defined, otherwise it does nothing.

Here's an example document with a top-level entry (\code{mineral}),
a level~1 entry (\code{quartz}) and a level~2 entry (\code{amethyst}).
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{xcolor}\comment{provides colour}
\cmd{usepackage}[colorlinks,linkcolor=magenta]\marg{hyperref}
\cmd{usepackage}[
 \styopt{entrycounter},\comment{enable top-level counter}
 \styopt{subentrycounter},\comment{enable level 1 counter}
 \styopt{postpunc}=\marg{dot},\comment{put full-stop after description}
 \styopt{nostyles},\comment{suppress automatic loading of default styles}
 \styopt[tree]{stylemods}\comment{load glossary-tree.sty}
]\marg{glossaries-extra}
\strut
\gls{newglossaryentry}\marg{mineral}
\marg{
  \field{name} = \marg{mineral},
  \field{description} = \marg{natural inorganic substance},
  \field{category} = \marg{mineral}
}
\strut
\gls{newglossaryentry}\marg{calcite}
\marg{
  \field{parent} = \marg{mineral},
  \field{name} = \marg{calcite},
  \field{description} = \marg{a carbonate mineral},
  \field{category} = \marg{mineral}
}
\strut
\gls{newglossaryentry}\marg{quartz}
\marg{
  \field{parent} = \marg{mineral},
  \field{name} = \marg{quartz},
  \field{description} = \marg{hard mineral consisting of silica},
  \field{category} = \marg{mineral}
}
\strut
\gls{newglossaryentry}\marg{amethyst}
\marg{
  \field{parent} = \marg{quartz},
  \field{name} = \marg{amethyst},
  \field{description} = \marg{a purple type of quartz},
  \field{category} = \marg{mineral}
}
\strut
\gls{glssetcategoryattribute}\marg{mineral}\marg{glossname}\marg{firstuc}
\strut
\cmd{renewcommand}\marg{\gls[noindex=false]{GlsXtrStandaloneGlossaryType}}\marg{standalone}
\strut
\cmd{newcommand}\marg{\cmd{displayterm}}\oarg{1}\marg{\comment{}
 \cmd{par}
 Definition \gls{glsxtrglossentry}\marg{\gls{param}1}:
 \gls{glossentrydesc}\marg{\gls{param}1}\gls{glspostdescription}\cmd{par}
}
\strut
\cmd{begin}\marg{document}
\cmd{displayterm}\marg{mineral}
\cmd{displayterm}\marg{calcite}
\cmd{displayterm}\marg{quartz}
\cmd{displayterm}\marg{amethyst}
\strut
A reference to \gls{gls}\marg{mineral}.
A reference to \gls{gls}\oarg{\printglossopt{prefix}={main.}}\marg{amethyst}.
\strut
\cmd{renewcommand}\marg{\gls[noindex=false]{GlsEntryCounterLabelPrefix}}\marg{main.glsentry-}
\gls{glsresetentrycounter}
\gls{printunsrtglossary}\oarg{\printglossopt{prefix}=\marg{main.},\printglossopt{style}=tree}
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
\renewcommand{\glslinkpresetkeys}{\setkeys{glslink}{local}}%
\def\glolinkprefix{standalone.hier.}%
\renewcommand{\glstextformat}[1]{\textcolor{magenta}{#1}}%
\setupglossaries{entrycounter,subentrycounter,section,toc=false}%
\glossariesextrasetup{postdot}%
\glssetcategoryattribute{hierarchical}{glossname}{firstuc}%
\renewcommand{\GlsXtrStandaloneGlossaryType}{standalone}%
\newcommand{\displayterm}[1]{%
 \par
 \begingroup
   Definition \glsxtrglossentry{#1}:
   \glossentrydesc{#1}\glspostdescription\par
 \endgroup
}%
\displayterm{hier.mineral}
\displayterm{hier.calcite}
\displayterm{hier.quartz}
\displayterm{hier.amethyst}

A reference to \gls{hier.mineral}.
A reference to \gls[prefix={hierarchical.main.}]{hier.amethyst}.

\printunsrtglossary*[prefix={hierarchical.main.},style=tree,nonumberlist]
{%
  \glsresetentrycounter
  \renewcommand{\GlsEntryCounterLabelPrefix}{main.glsentry-}%
  \renewcommand*{\printunsrtglossaryentryprocesshook}[1]{%
    \glsxtriflabelinlist{#1}{hier.mineral,hier.calcite,hier.quartz,hier.amethyst}%
    {}{\printunsrtglossaryskipentry}%
  }%
}
\end{result}
Note the need to reset the \counter{glossaryentry} counter with 
\gls{glsresetentrycounter} before the main glossary. The top-level
entry (\code{mineral}) has the label formatted as
\qt{1.\textvisiblespace} and the level~1 entries (\code{calcite}
and \code{quartz}) have their labels formatted as
\qt{1)\textvisiblespace} and \qt{2)\textvisiblespace} but the
level~2 entry (\code{amethyst}) doesn't have an associated number.
If you want to number levels deeper than 1, you will have to provide
your own custom counters. (If the stand-alone level~2 entry shows a
number when you try this, then you've encountered a bug that's been
fixed in \sty{glossaries-extra} version~1.31.)

The hyperlinks are shown in magenta. The first (\code{mineral}) links to the
stand-alone target, and the second (\code{amethyst}) links to the entry in 
the main glossary.

\chapter{Changing the Formatting}
\label{sec:glsformats}

All commands like \gls{gls} and \gls{glssymbol} by default
encapsulate the \idx{link-text} within the argument of:
\nosecformatdef{glstextformat}
For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{xcolor}\comment{provides colour}
\cmd{usepackage}\marg{pifont}\comment{provides \gls{ding}}
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{newglossaryentry}\marg{duck}\comment{label}
\marg{
   \field{name} = \marg{duck},
   \field{description} = \marg{a waterbird with webbed feet}
}
\strut
\gls{newglossaryentry}\marg{fleuron}\comment{label}
\marg{
  \field{name} = \marg{fleuron},
  \field{symbol} = \marg{\gls[noindex=false]{ding}\marg{167}},
  \field{category} = \marg{ornament},
  \field{description} = \marg{typographic ornament}
}
\strut
\gls{newabbreviation}\marg{tug}\marg{TUG}\marg{\cmd{TeX}\gls{cs.space}Users Group}
\strut
\cmd{renewcommand}\marg{\gls{glstextformat}}[1]\marg{\cmd{textcolor}\marg{violet}\marg{\gls{param}1}}
\strut
\cmd{begin}\marg{document}
A \gls{gls}\marg{duck}, a \gls{gls}\marg{fleuron} (\gls{glssymbol}\marg{fleuron}, 
\gls{glsentrydesc}\marg{fleuron}) and \gls{gls}\marg{tug}.
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}%
\renewcommand{\glstextformat}[1]{\textcolor{violet}{#1}}%
A \gls{ex1.duck}, a \gls{ex.fleuron} (\glssymbol{ex.fleuron}, 
\glsentrydesc{ex.fleuron}) and \gls{TUG}.
\end{result}
Note that this has affected \gls{gls} and \gls{glssymbol} but not
\gls{glsentrydesc}.

A distinction can be made between abbreviations (\idx{non-regular}
terms) and \idx{regular} terms (non-abbreviations or abbreviations
that are considered \idx{regular} entries). 
A \idx{regular} term is encapsulated with 
\nosecformatdef{glsxtrregularfont}
and an abbreviation is encapsulated with 
\nosecformatdef{glsxtrabbreviationfont}
For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{xcolor}\comment{provides colour}
\cmd{usepackage}\marg{pifont}\comment{provides \gls{ding}}
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{newglossaryentry}\marg{duck}\comment{label}
\marg{
   \field{name} = \marg{duck},
   \field{description} = \marg{a waterbird with webbed feet}
}
\strut
\gls{newglossaryentry}\marg{fleuron}\comment{label}
\marg{
  \field{name} = \marg{fleuron},
  \field{symbol} = \marg{\gls{ding}\marg{167}},
  \field{category} = \marg{ornament},
  \field{description} = \marg{typographic ornament}
}
\strut
\gls{newabbreviation}\marg{tug}\marg{TUG}\marg{\cmd{TeX}\gls{cs.space}Users Group}
\gls{newacronym}\marg{ascii}\marg{ASCII}\marg{American Standard Code for 
Information Interchange}
\strut
\cmd{renewcommand}\marg{\gls{glstextformat}}[1]\marg{\cmd{textcolor}\marg{violet}\marg{\gls{param}1}}
\cmd{renewcommand}\marg{\gls{glsxtrregularfont}}[1]\marg{\cmd{underline}\marg{\gls{param}1}}
\cmd{renewcommand}\marg{\gls{glsxtrabbreviationfont}}[1]\marg{\gls{emph}\marg{\gls{param}1}}
\strut
\cmd{begin}\marg{document}
Two \gls{glspl}\marg{duck}, a \gls{gls}\marg{fleuron} (\gls{glssymbol}\marg{fleuron}, 
\gls{glsentrydesc}\marg{fleuron}), \gls{gls}\marg{tug} and \gls{gls}\marg{ascii}.
\cmd{end}\marg{document}
\end{codeenv}
This now produces:
\begin{result}%
\renewcommand{\glstextformat}[1]{\textcolor{violet}{#1}}%
\renewcommand{\glsxtrregularfont}[1]{\underline{#1}}%
\renewcommand{\glsxtrabbreviationfont}[1]{\emph{#1}}%
Two \glspl{ex1.duck}, a \gls{ex.fleuron} (\glssymbol{ex.fleuron}, 
\glsentrydesc{ex.fleuron}), \gls{TUG} and \gls{ASCII}.
\end{result}
Note the difference between the abbreviation defined with
\gls{newabbreviation} and the one defined with \gls{newacronym}.
The above example document is using the default styles, which is
\abbrstyle{long-short} for the \code{abbreviation} category
and \abbrstyle{short-nolong} for the \code{acronym} category.
The \abbrstyle{short-nolong} style makes the abbreviation behave
like a \idx{regular} entry and so it's governed by \gls{glsxtrregularfont}
not by \gls{glsxtrabbreviationfont}.

The \gls{glstextformat} command is overridden by the
\catattr{textformat} attribute. The value of this attribute must be
the name (without the leading backslash) of a command that takes a
single argument, which will be used instead of \gls{glstextformat}
for any entry that has this attribute set for its category.
For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{xcolor}\comment{provides colour}
\cmd{usepackage}\marg{pifont}\comment{provides \gls{ding}}
\cmd{usepackage}\marg{glossaries-extra}
\strut
\cmd{newcommand}\marg{\cmd{ornamentfmt}}[1]\marg{\cmd{textcolor}\marg{cyan}\marg{\gls{param}1}}
\strut
\gls{glssetcategoryattribute}\marg{ornament}\marg{\catattr{textformat}}\marg{ornamentfmt}
\strut
\gls{setabbreviationstyle}\marg{\abbrstyle[noindex=false]{long-short-em}}
\gls{setabbreviationstyle}\oarg{acronym}\marg{\abbrstyle[noindex=false]{short-sc-nolong}}
\strut
\gls{newglossaryentry}\marg{duck}\comment{label}
\marg{
   \field{name} = \marg{duck},
   \field{description} = \marg{a waterbird with webbed feet}
}
\strut
\gls{newglossaryentry}\marg{fleuron}\comment{label}
\marg{
  \field{name} = \marg{fleuron},
  \field{symbol} = \marg{\gls{ding}\marg{167}},
  \field{category} = \marg{ornament},
  \field{description} = \marg{typographic ornament}
}
\strut
\gls{newabbreviation}\marg{tug}\marg{TUG}\marg{\cmd{TeX}\gls{cs.space}Users Group}
\gls{newacronym}\marg{ascii}\comment{label}
\marg{ascii}\comment{short form needs to be in lower case with sc styles}
\marg{American Standard Code for Information Interchange}
\strut
\cmd{renewcommand}\marg{\gls{glstextformat}}[1]\marg{\cmd{textcolor}\marg{violet}\marg{\gls{param}1}}
\cmd{renewcommand}\marg{\gls{glsxtrregularfont}}[1]\marg{\cmd{underline}\marg{\gls{param}1}}
\cmd{renewcommand}\marg{\gls{glsxtrabbreviationfont}}[1]\marg{\gls{textbf}\marg{\gls{param}1}}
\strut
\cmd{begin}\marg{document}
Two \gls{glspl}\marg{duck}, a \gls{gls}\marg{fleuron} (\gls{glssymbol}\marg{fleuron}, 
\gls{glsentrydesc}\marg{fleuron}), \gls{gls}\marg{tug} and \gls{gls}\marg{ascii}.
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
\renewcommand{\glstextformat}[1]{\textcolor{violet}{#1}}%
\renewcommand{\glsxtrregularfont}[1]{\underline{#1}}%
\renewcommand{\glsxtrabbreviationfont}[1]{\textbf{#1}}%
\newcommand{\ornamentfmt}[1]{\textcolor{cyan}{#1}}%
\glssetcategoryattribute{ornament}{textformat}{ornamentfmt}%
Two \glspl{ex1.duck}, a \gls{ex.fleuron} (\glssymbol{ex.fleuron}, 
\glsentrydesc{ex.fleuron}), \gls{ex.tug} and \gls{ex.ascii}.
\end{result}
So \code{\gls{gls}\marg{fleuron}} and \code{\gls{glssymbol}\marg{fleuron}} are now
formatted according to the custom command \csfmt{ornamentfmt} (cyan)
not by \gls{glstextformat} (violet), but they are still affected by
\gls{glsxtrregularfont} (underline).

The \code{tug} abbreviation has been assigned the
\abbrstyle{long-short-em} style which encapsulates the short form
with \gls{emph}, but it also obeys \gls{glsxtrabbreviationfont}
(bold) and it's encapsulated by \gls{glstextformat} (violet), so the
full form on \idx{firstuse} is all violet and bold with the short
form in italics.

The \code{ascii} entry (which has the \field{category} set to
\code{acronym}) has been assigned the \abbrstyle{short-sc-nolong}
style, which encapsulates the short form with \gls{textsc} (so the
short form must be converted to \idx{lowercase}) and identifies the
entry as a \idx{regular} term, so it obeys \gls{glsxtrregularfont}
(underline). Again, the \idx{link-text} is encapsulated with
\gls{glstextformat} (violet) so the abbreviation is violet,
underlined and in small-caps.

You can override a specific instance with the \glsopt{textformat}
setting in the first optional argument of commands like \gls{gls}.
For example, if the above is modified to:
\begin{codeenv}
Two \gls{glspl}\marg{duck}, a \gls{gls}\oarg{\glsopt{textformat}=textbf}\marg{fleuron} 
(\gls{glssymbol}\marg{fleuron}, \gls{glsentrydesc}\marg{fleuron}), \gls{gls}\marg{tug} 
and \gls{gls}\marg{ascii}.
\end{codeenv}
then the result is now:
\begin{result}
\renewcommand{\glstextformat}[1]{\textcolor{violet}{#1}}%
\renewcommand{\glsxtrregularfont}[1]{\underline{#1}}%
\renewcommand{\glsxtrabbreviationfont}[1]{\textbf{#1}}%
\newcommand{\ornamentfmt}[1]{\textcolor{cyan}{#1}}%
\glssetcategoryattribute{ornament}{textformat}{ornamentfmt}%
Two \glspl{ex1.duck}, a \gls[textformat=textbf]{ex.fleuron} 
(\glssymbol{ex.fleuron}, \glsentrydesc{ex.fleuron}),
\gls{ex.tug} and \gls{ex.ascii}.
\end{result}
In this case, only that specific instance is changed.

Take care if the formatting command needs to parse its argument as
the argument won't be the actual text but consists of intermediary commands
that determine the required text and any inner formatting, such as
the formatting applied by abbreviation styles. See
\sectionref{sec:expandedfmt} for further details.

\section{Post-Link Category Hooks}
\label{sec:postlinkhooks}

Extra information can be appended after commands such as \gls{gls}
by defining a \pidx{postlinkhook} for the given category. You can
obtain the label of the entry that's just been referenced with:
\nosecformatdef{glslabel}
The \idx{postlinkhook} is a command in the form
\nosecformatdef{glsxtrpostlinkcategory}
where \meta{category} is the category label. This hook is
implemented after any instances of commands such as \gls{gls} or
\gls{glssymbol} (but not after commands like \gls{glsentryname},
\gls{glsentrydesc} or \gls{glsentryname}, which may be used in the
hook).

Consider the following document:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{pifont}\comment{provides \gls{ding}}
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{newglossaryentry}\marg{fleuron}\comment{label}
\marg{
  \field{name} = \marg{fleuron},
  \field{symbol} = \marg{\gls{ding}\marg{167}},
  \field{description} = \marg{typographic ornament}
}
\strut
\gls{newglossaryentry}\marg{pi}\comment{label}
\marg{
  \field{name} = \marg{Archimedes' constant},
  \field{symbol} = \marg{\gls{ensuremath}\marg{\cmd{pi}}},
  \field{category} = \marg{constant},
  \field{description} = \marg{Archimedes' constant}
}
\strut
\comment{post-link hook for 'constant' category:}
\cmd{newcommand}\marg{\csfmt{glsxtrpostlinkconstant}}\marg{\comment{} 
 \cmd{space} (\gls{glsentrysymbol}\marg{\gls{glslabel}})}
\strut
\cmd{begin}\marg{document}
A \gls{gls}\marg{fleuron} and \gls{gls}\marg{pi}.
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
\newcommand{\glsxtrpostlinkconstant}{\space (\glsentrysymbol{\glslabel})}%
A \gls{ex.fleuron} and \gls{ex.pi}.
\end{result}
The \code{fleuron} entry doesn't have the \field{category} key
explicitly set, so it defaults to \code{general}, but the \code{pi}
entry has the \field{category} set to \code{constant}, so it's
affected by the \idx{postlinkhook} for that category, which in this
case is given by \csfmt{glsxtrpostlinkconstant}. This hook is
defined to use \gls{glsentrysymbol} where the entry label is obtained
from \gls{glslabel}, which is set by \gls{gls} and similar commands.

\begin{important}
If \code{\gls{glssymbol}\marg{\gls{glslabel}}} had been used instead of
\code{\gls{glsentrysymbol}\marg{\gls{glslabel}}} it would've caused infinite
recursion! Don't use commands like \gls{glssymbol}, \gls{glsdesc} or
\gls{gls} in \idxpl{postlinkhook}.
\end{important}

This means that \code{\gls{gls}\marg{pi}} is automatically followed by the
symbol in parentheses, but \code{\gls{gls}\marg{fleuron}} isn't because it's
governed by the \code{general} \idx{postlinkhook} instead. Note that
the above is a simple example to demonstrate one of the uses of the
\field{category} field.

Here's a minor modification that sets the category for the
\code{fleuron} entry to \code{ornament} and creates another hook for
that.
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{pifont}\comment{provides \gls{ding}}
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{newglossaryentry}\marg{fleuron}\comment{label}
\marg{
  \field{name} = \marg{fleuron},
  \field{symbol} = \marg{\gls{ding}\marg{167}},
  \field{category} = \marg{ornament},
  \field{description} = \marg{typographic ornament}
}
\strut
\gls{newglossaryentry}\marg{pi}\comment{label}
\marg{
  \field{name} = \marg{pi},
  \field{symbol} = \marg{\gls{ensuremath}\marg{\cmd{pi}}},
  \field{category} = \marg{constant},
  \field{description} = \marg{Archimedes' constant}
}
\strut
\comment{post-link hook for 'ornament' category:}
\cmd{newcommand}\marg{\csfmt{glsxtrpostlinkornament}}\marg{\comment{}
 \cmd{space} (\gls{glsentrydesc}\marg{\gls{glslabel}})}
\strut
\comment{post-link hook for 'constant' category:}
\cmd{newcommand}\marg{\csfmt{glsxtrpostlinkconstant}}{\comment{}
 \cmd{space} (\gls{glsentrysymbol}\marg{\gls{glslabel}})}
\strut
\cmd{begin}\marg{document}
A \gls{gls}\marg{fleuron} and \gls{gls}\marg{pi}. Another \gls{gls}\marg{fleuron} and 
\gls{gls}\marg{pi}. Symbols: \gls{glssymbol}\marg{fleuron} and \gls{glssymbol}\marg{pi}.
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
\newcommand{\glsxtrpostlinkornament}{\space (\glsentrydesc{\glslabel})}%
\newcommand{\glsxtrpostlinkconstant}{\space (\glsentrysymbol{\glslabel})}%
A \gls{ex.fleuron} and \gls{ex.pi}. Another \gls{ex.fleuron} and 
\gls{ex.pi}. Symbols: \glssymbol{ex.fleuron} and \glssymbol{ex.pi}.\incorrect
\end{result}
The \idx{postlinkhook} is repeated after every instance of \gls{gls}
or \gls{glssymbol} etc. In the case of the \code{ornament} category,
the description is appended in parentheses and in the case of the
\code{constant} category the symbol is appended. This results in
redundant repetition, especially with \verb|\glssymbol{pi}| which
displays the symbol followed by the symbol in parentheses.

It's more likely that the information only needs to be appended
after the \idx{firstuse}. You can determine if the
\idx{postlinkhook} follows the \idx{firstuse} of the entry using:
\nosecformatdef{glsxtrifwasfirstuse}
For example:
\begin{codeenv}
\cmd{newcommand}\marg{\csfmt{glsxtrpostlinkconstant}}\marg{\comment{}
 \gls{glsxtrifwasfirstuse}\marg{\cmd{space} (\gls{glsentrysymbol}\marg{\gls{glslabel}})}\marg{}\comment{}
}
\end{codeenv}
Commands that don't check or modify the \idx{firstuseflag}, such as
\gls{glssymbol}, always set \gls{glsxtrifwasfirstuse} so that it
expands to \meta{false}. This means that even if
\code{\gls{glssymbol}\marg{pi}}
is placed before the first instance of \code{\gls{gls}\marg{pi}} it still
won't be treated as the first use of that entry.

For convenience, there's a shortcut command:
\nosecformatdef{glsxtrpostlinkAddSymbolOnFirstUse}
So an alternative definition is:
\begin{codeenv}
\cmd{newcommand}\marg{\csfmt{glsxtrpostlinkconstant}}\marg{\comment{}
  \gls{glsxtrpostlinkAddSymbolOnFirstUse}
}
\end{codeenv}
This does nothing if the \field{symbol} field hasn't been set.

Similarly, there's a shortcut command for the description:
\nosecformatdef{glsxtrpostlinkAddDescOnFirstUse}
Version 1.31+ provides a combination:
\nosecformatdef{glsxtrpostlinkAddSymbolDescOnFirstUse}
If the \field{symbol} field is set, this displays the symbol
followed by a comma and space. The description is always displayed
at the end of the parenthetical material.

Also from \sty{glossaries-extra} v1.31, there's a shortcut
command that you can use to define the \idx{postlinkhook}:
\nosecformatdef{glsdefpostlink} 
This is just a shortcut for:
\begin{codeenv}
\csfmt{csdef}\marg{glsxtrpostlink\meta{category}}\margm{definition}
\end{codeenv}
So the above document can be changed to:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{pifont}\comment{provides \gls{ding}}
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{newglossaryentry}\marg{fleuron}\comment{label}
\marg{
  \field{name} = \marg{fleuron},
  \field{symbol} = \marg{\gls{ding}\marg{167}},
  \field{category} = \marg{ornament},
  \field{description} = \marg{typographic ornament}
}
\strut
\gls{newglossaryentry}\marg{pi}\comment{label}
\marg{
  \field{name} = \marg{pi},
  \field{symbol} = \marg{\gls{ensuremath}\marg{\cmd{pi}}},
  \field{category} = \marg{constant},
  \field{description} = \marg{Archimedes' constant}
}
\strut
\comment{post-link hook for 'ornament' category:}
\gls{glsdefpostlink}\marg{ornament}\marg{\comment{}
  \gls{glsxtrpostlinkAddSymbolDescOnFirstUse}
}
\strut
\comment{post-link hook for 'constant' category:}
\gls{glsdefpostlink}\marg{constant}\marg{\comment{}
  \gls{glsxtrpostlinkAddSymbolOnFirstUse}
}
\strut
\cmd{begin}\marg{document}
Symbols: \gls{glssymbol}\marg{fleuron} and \gls{glssymbol}\marg{pi}.
A \gls{gls}\marg{fleuron} and \gls{gls}\marg{pi}. Another \gls{gls}\marg{fleuron} and 
\gls{gls}\marg{pi}.
\cmd{end}\marg{document}
\end{codeenv}
The result is now:
\begin{result}%
\glsdefpostlink{ornament}{\glsxtrpostlinkAddSymbolDescOnFirstUse}%
\glsdefpostlink{constant}{\glsxtrpostlinkAddSymbolOnFirstUse}%
Symbols: \glssymbol{ex.fleuron} and \glssymbol{ex.pi}.
A \gls{ex.fleuron} and \gls{ex.pi}. Another \gls{ex.fleuron} and
\gls{ex.pi}.
\end{result}

\section{Glossary Name and Description Formatting}
\label{sec:glossname}

When an entry's definition is displayed within
\gls{printunsrtglossary} or \gls{glsxtrglossentry} (see
\sectionref{sec:displaygloss}), the value of the \field{name} field
is encapsulated by
\nosecformatdef{glsnamefont}
This may be overridden with the \catattr{glossnamefont} attribute
whose value must be the name (without the leading backslash) of a
control sequence that takes a single argument. If set, this control
sequence is used instead of \gls{glsnamefont}.

By default \gls{glsnamefont} simply does its argument, but the
glossary style may apply additional formatting. For example, the
\glostyle{list} styles place the name in the optional argument of
\csfmt{item} within the \envfmt{description} environment. With the
standard document classes, this renders the name in bold, but other
classes may apply different formatting.

The \glostyle{tree} styles defined by the \sty{glossary-tree} style 
encapsulate the name within:
\nosecformatdef{glstreenamefmt}
which does \code{\gls{textbf}\margm{text}} by default. So, for
example, if \gls{glsnamefont} is redefined to use \gls{textit} and
the \glostyle{tree} style is used, then the name will appear in
italic bold.  The letter group headings are encapsulated within:
\nosecformatdef{glstreegroupheaderfmt}
which defaults to \code{\gls{glstreenamefmt}\margm{text}}, so if you
need to redefine \gls{glstreenamefmt} you may also need to redefine
\gls{glstreegroupheaderfmt} if the headers should have different formatting.
The \sty{glossaries-extra-stylemods} package (as from v1.31) now
redefine both \gls{glstreenamefmt} and \gls{glstreegroupheaderfmt}
to use:
\nosecformatdef{glstreedefaultnamefmt}
which does \code{\gls{textbf}\margm{text}} by default. This means
that if you want to change both the header and name to a different
font, you can just redefine \gls{glstreedefaultnamefmt}, and if you
want to change only the font used for the name, then now you only
need to redefine \gls{glstreenamefmt}, without also having to
redefine \gls{glstreegroupheaderfmt}.

Case-changing can be automatically applied to the name with the
\catattr{glossname} attribute, which may take one of the values:
\code{firstuc} (convert the first letter to \idx{uppercase}), \code{title}
(convert to title case) or \code{uc} (convert to all capitals).
Alternatively, if you're using \bibgls, you can use the
\csopt{name-case-change} resource option.

The description is similarly governed by the
\catattr{glossdescfont}, which again should have the name (without
the leading backslash) of a control sequence that takes a single
argument. There's no equivalent of \gls{glsnamefont} for the
description but the glossary or abbreviation style may apply
particular formatting, which will be in addition to the formatting
command given by \catattr{glossdescfont} (if set).

Case-changing is also available for descriptions with the
\catattr{glossdesc} attribute, but this only has two allowed values:
\code{firstuc} (convert the first letter to \idx{uppercase}) and
\code{title} (convert to title case). 
Alternatively, if you're using \bibgls, you can use the
\csopt{description-case-change} resource option.

\section{Post-Name and Post-Description Hooks}
\label{sec:postfieldhooks}

Information can be appended to the \field{name} in the glossary for
a particular category using the \pidx{postnamehook}, which is given
by the command:
\nosecformatdef{glsxtrpostnamecategory}
The current entry's label can be referenced with:
\nosecformatdef{glscurrententrylabel}
For example, if the preferred glossary style doesn't include the
\field{symbol} field, but you want the symbol displayed after the
name for entries with the \field{category} field set to \code{symbol}:
\begin{codeenv}
\cmd{newcommand}\marg{\cmd{glsxtrpostnamesymbol}}\marg{\cmd{space} 
 (\gls{glsentrysymbol}\marg{\gls{glscurrententrylabel}})}
\end{codeenv}
There's a convenient shortcut:
\nosecformatdef{glsdefpostname}
which defines \gls{glsxtrpostnamecategory} to \meta{definition}
(using \gls{csdef}). There's also a more general purpose \idx{postnamehook} 
used regardless of the category:
\nosecformatdef{glsextrapostnamehook}

The \idx{postnamehook} is placed inside the formatting command used
for the \field{name} field in the glossary. It's only present in the
glossary (see \sectionref{sec:printgloss}) or stand-alone entries
(see \sectionref{sec:standalone}).

There is a similar \pidx{postdescriptionhook}. For a particular category,
the hook is given by:
\nosecformatdef{glsxtrpostdesccategory}
There are some categories that have empty hooks already defined,
such as
\nosecformatdef{glsxtrpostdescgeneral}
These will need \csfmt{renewcommand} rather than \csfmt{newcommand}.
Again there's a shortcut command provided:
\nosecformatdef{glsdefpostdesc}
which just uses \gls{csdef}, so there's no check if the command is
already defined.
As with the \idx{postnamehook}, the entry's label can be accessed
with \gls{glscurrententrylabel}.

Punctuation (such as a \idx{full-stop} or comma) can automatically be 
appended to the description in the
glossary with the \styopt{postpunc} option.  (Note that the
unstarred form of \gls{longnewglossaryentry} interferes with this
option. Use the starred form \gls{longnewglossaryentry*} instead.)
The post-description punctuation (if set) is placed after the
\glslink{postdescriptionhook}{post-description category hook} (if
provided). Both the post-description category hook and the
post-description punctuation are implemented by
\nosecformatdef{glspostdescription}
The \sty{glossaries-extra-stylemods}
package (which can be loaded with the \styopt{stylemods} option)
patches the predefined styles provided with the base
\sty{glossaries} package to ensure that the standard styles all use
\gls{glspostdescription}.


\chapter{Problematic Areas}
\label{sec:problems}

There are some places where the use of commands like \gls{gls} can
cause problems. Common issues are listed below, with workarounds provided.

\section{Headings and Captions}
\label{sec:headings}

The arguments of sectioning commands (such as \gls{chapter} or
\gls{section}) and of captions (\gls{caption}) are
\pidxpl{moving-argument}. The text is not only displayed at the
point in the document where the command occurs, but may also be
copied to the \gls{toc} or list of figures etc.
Additionally, depending on the page style, the section argument may
also be reproduced in the page header. This repeated use of the same
material can cause complications, in particular it can prematurely
triggering the \idx{firstuseflag} switch and cause unwanted
indexing. If the content appears in the page header and the page
styles converts headers to upper case, this can also cause a
problem.

For example:
\begin{codeenv}
\cmd{documentclass}\marg{book}
\strut
\cmd{usepackage}\marg{lipsum}\comment{provides \cmd{lipsum}}
\cmd{usepackage}\marg{glossaries}
\strut
\gls{newglossaryentry}\marg{sample}\marg{\field{name}=\marg{sample},\field{description}=\marg{an example}}
\strut
\cmd{begin}{document}
\gls{chapter}\marg{A \gls{gls}\marg{sample} chapter}
\cmd{lipsum} \comment{dummy text}
\cmd{end}\marg{document}
\end{codeenv}
I've used \csfmt{lipsum} here to create some dummy text that ensures
a multi-paged document because the problem doesn't occur until the second
page. The error message is:
\begin{verbatim}
Glossary entry `SAMPLE' has not been defined.
\end{verbatim}
The problem here is that the chapter title is copied to the header
(which doesn't appear on the chapter's first page) but the header
uses \gls{MakeUppercase}, which can't expand \gls{gls} but it does
change the label, so \code{\gls{gls}\marg{sample}} is converted to
\code{\gls{gls}\marg{SAMPLE}}, but there's no entry with that label.
(Labels are case-sensitive.)

Here's an example that doesn't cause an error (because there's not
enough text to trigger a page break) but does cause unexpected output:
\begin{codeenv}
\cmd{documentclass}\marg{book}
\strut
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{setabbreviationstyle}\marg{\abbrstyle{long-short-sc}}
\gls{newabbreviation}\marg{html}\marg{html}\marg{hypertext markup language}
\strut
\cmd{begin}\marg{document}
\gls{tableofcontents}
\gls{chapter}\marg{A chapter about \gls{gls}\marg{html}}
Reference \gls{gls}\marg{html}.
\cmd{end}\marg{document}
\end{codeenv}
On the first \LaTeX\ run, the \gls{toc} is empty as the
associated \ext{toc} file didn't exist at the start. The chapter title
appears as \qt{A chapter about hypertext markup language
(\textsc{html})}, which shows the \idx{firstuse} of
\code{\gls{gls}\marg{html}}. The \ext{toc} file (which was created
but not read by \gls{tableofcontents}) now contains:
\begin{codeenv}
\cmd{contentsline} \marg{chapter}\marg{\cmd{numberline} \marg{1}A chapter about \gls{gls} \marg{html}}\marg{3}
\end{codeenv}
This means that on the next \LaTeX\ run, the \gls{toc} now
includes \code{\gls{gls}\marg{html}}. Since the \gls{toc}
occurs at the start of the document, this is now the \idx{firstuse}
of \code{html}, so the full form is shown in the \gls{toc},
but the chapter title is now \qt{A chapter about \textsc{html}}, which shows
the subsequent use.

The \sty{glossaries-extra} package provides some commands that are
designed for use in section or caption titles. These include:
\nosecformatdef{glsfmtshort}
which shows the short form of an abbreviation,
\nosecformatdef{glsfmtlong}
which shows the long form of an abbreviation,
\nosecformatdef{glsfmtfull}
which shows the full form of an abbreviation, 
\nosecformatdef{glsfmtname}
which shows the entry's name, 
\nosecformatdef{glsfmtfirst}
which shows the entry's \field{first} field, and
\nosecformatdef{glsfmttext}
which shows the entry's \field{text} field.

Here's a modified version of the above:
\begin{codeenv}
\cmd{documentclass}\marg{book}
\strut
\cmd{usepackage}\marg{lipsum}\comment{provides \cmd{lipsum}}
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{setabbreviationstyle}\marg{\abbrstyle{long-short-sc}}
\gls{newabbreviation}\marg{html}\marg{html}\marg{hypertext markup language}
\strut
\cmd{begin}\marg{document}
\gls{tableofcontents}
\gls{chapter}\marg{A chapter about \gls{glsfmtlong}\marg{html}}
Reference \gls{gls}\marg{html}.
\cmd{lipsum} \comment{dummy text}
\cmd{end}\marg{document}
\end{codeenv}
This now shows the long form in the \gls{toc} and the
chapter title. Since \gls{glsfmtlong} doesn't affect the
\idx{firstuseflag}, the reference after the chapter title now shows
the \idx{firstuse} full form. There's no longer an error with the
page header on the second page, but it's not quite right as the
case-change hasn't been applied, so the page heading appears as:
\begin{result}
4\hfill \emph{CHAPTER 1. A CHAPTER ABOUT hypertext markup language}
\end{result} 
This can be corrected by setting the \catattr{headuc} attribute to
\code{true}:
\begin{codeenv}
\gls{glssetcategoryattribute}\marg{abbreviation}\marg{headuc}\marg{true}
\end{codeenv}
This now makes the page header too long, but remember that you can
use the optional argument of sectioning commands to provide a
shorter form for both the page heading and \gls{toc}:
\begin{codeenv}
\gls{chapter}\oarg{A chapter about \gls{glsfmtshort}\marg{html}}\marg{A chapter about 
\gls{glsfmtlong}\marg{html}}
\end{codeenv}
One final problem remains and it's due to the
\abbrstyle{long-short-sc} abbreviation style which uses \gls{textsc}
to display the short form in small capitals. The combination of
italic and small capitals isn't supported with the default fonts and
results in a font substitution. There's a similar problem in the 
\gls{toc} which displays the chapter title in bold. There's 
a warning at the end of the transcript:
\begin{verbatim}
Some font shapes were not available, defaults substituted.
\end{verbatim}
The conflict between bold and small capitals can be solved by
switching to the T1 font encoding:
\begin{codeenv}
\cmd{usepackage}[T1]\marg{\sty[noindex=false]{fontenc}}
\end{codeenv}
The conflict between italic and small capitals can be solved with
the \sty{slantsc} package. Another possibility is to redefine:
\nosecformatdef{glsabbrvscfont}
which is used by the \qt{sc} abbreviation styles:
\begin{codeenv}
\cmd{renewcommand}\marg{\gls{glsabbrvscfont}}[1]\marg{\comment{}
 \gls{glsxtrifinmark}\marg{\gls{MakeTextUppercase}\marg{\gls{param}1}}\marg{\gls{textsc}\marg{\gls{param}1}}\comment{}
}
\end{codeenv}
This uses:
\nosecformatdef{glsxtrifinmark}
which expands to \meta{true} in headings and the \gls{toc},
otherwise it expands to \meta{false}. This use of
\gls{MakeTextUppercase} replaces the need for the \catattr{headuc}
attribute. Both \catattr{headuc} and the above redefinition of
\gls{glsabbrvscfont} will cause the abbreviation to appear in
\idx{uppercase} in the \gls{toc}. If you don't want this,
you can defer making these modifications until after the 
\gls{toc}. Alternatively, use:
\nosecformatdef{glsxtrRevertTocMarks}
which makes \gls{glsxtrifinmark} expand to \meta{false} in the 
\gls{toc}.  For example:
\begin{codeenv}
\cmd{documentclass}\marg{book}
\strut
\cmd{usepackage}[T1]\marg{fontenc}
\cmd{usepackage}\marg{lipsum}
\cmd{usepackage}\marg{glossaries-extra}
\strut
\cmd{renewcommand}\marg{\gls{glsabbrvscfont}}[1]\marg{\comment{}
 \gls{glsxtrifinmark}\marg{\gls{MakeTextUppercase}\marg{\gls{param}1}}\marg{\gls{textsc}{\gls{param}1}}\comment{}
}
\strut
\gls{setabbreviationstyle}\marg{\abbrstyle{long-short-sc}}
\gls{newabbreviation}\marg{html}\marg{html}\marg{hypertext markup language}
\strut
\cmd{begin}\marg{document}
\gls{tableofcontents}
\gls{chapter}\oarg{A chapter about \gls{glsfmtshort}\marg{html}}\marg{A chapter 
about \gls{glsfmtlong}\marg{html}}
Reference \gls{gls}\marg{html}.
\cmd{lipsum} \comment{dummy text}
\cmd{end}\marg{document}
\end{codeenv}


\section{Nesting}
\label{sec:nested}

Nesting refers to commands like \gls{gls} and \gls{glssymbol} being
used in the \idx{link-text} of similar commands. This occurs if
these commands are used in fields that form part of the
\idx{link-text} or if they occur in the final \meta{insert}
optional argument (which is included in the \idx{link-text}) or in the 
\idx{postlinkhook} (which isn't included in the \idx{link-text} but
is still problematic).

The most serious problem is when the \idx{postlinkhook} includes one
of these commands that references an entry with the same category
(and therefore the same \idx{postlinkhook} code) as
you can end up with an infinite loop. For example:
\begin{codeenv}
\gls{glsdefpostlink}\marg{symbol}\marg{ (\gls{glssymbol}\marg{\gls{glslabel}})}\comment{infinite loop!}\incorrect
\end{codeenv}
Instead, use \gls{glsentrysymbol}:
\begin{codeenv}
\gls{glsdefpostlink}\marg{symbol}\marg{ (\gls{glsentrysymbol}\marg{\gls{glslabel}})}\correct
\end{codeenv}
Better still, use commands like
\gls{glsxtrpostlinkAddSymbolOnFirstUse} (see \sectionref{sec:postlinkhooks}).

The next most problematic nesting is the use of \gls{gls} in
abbreviations. It's far more of a problem if you only use the base
\sty{glossaries} package. For example:
\begin{codeenv}
\cmd{documentclass}\marg{book}
\strut
\gls{usepackage}\marg{glossaries}
\strut
\gls{newacronym}\marg{ssi}\marg{SSI}\marg{server-side includes}
\gls{newacronym}\marg{html}\marg{HTML}\marg{hypertext markup language}
\gls{newacronym}\marg{shtml}\marg{SHTML}\marg{\gls{gls}\marg{ssi} enabled \gls{gls}\marg{html}}\incorrect
\strut
\cmd{begin}\marg{document}
\gls{gls}\marg{shtml}.
\cmd{end}\marg{document}
\end{codeenv}
This results in:
\begin{result}
server-side includes (SSI) enabled hypertext markup language (HTML) (SHTML).
\end{result}
The \sty{glossaries-extra} package temporarily changes \gls{gls}
within the \idx{link-text} to avoid this type of problem.
\begin{codeenv}
\cmd{documentclass}\marg{book}
\strut
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{newabbreviation}\marg{ssi}\marg{SSI}\marg{server-side includes}
\gls{newabbreviation}\marg{html}\marg{HTML}\marg{hypertext markup language}
\gls{newabbreviation}\marg{shtml}\marg{SHTML}\marg{\gls{gls}\marg{ssi} enabled \gls{gls}\marg{html}}
\strut
\cmd{begin}\marg{document}
\gls{gls}\marg{shtml}.
\cmd{end}\marg{document}
\end{codeenv}
This now produces:
\begin{result}
SSI enabled HTML (SHTML).
\end{result}
This doesn't seem so bad, but now let's see what happens if the
\catattr{glossdesc} is set to \code{firstuc}:
\begin{codeenv}
\cmd{documentclass}\marg{book}
\strut
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{glssetcategoryattribute}\marg{abbreviation}\marg{\catattr{glossdesc}}\marg{firstuc}
\gls{newabbreviation}\marg{ssi}\marg{SSI}\marg{server-side includes}
\gls{newabbreviation}\marg{html}\marg{HTML}\marg{hypertext markup language}
\gls{newabbreviation}\marg{shtml}\marg{SHTML}\marg{\gls{gls}\marg{ssi} enabled \gls{gls}\marg{html}}\incorrect
\strut
\cmd{begin}\marg{document}
\gls{gls}\marg{shtml}.
\gls{printunsrtglossary}
\cmd{end}\marg{document}
\end{codeenv}
This now causes an error:
\begin{verbatim}
! Missing \endcsname inserted.
<to be read again> 
                   \protect 
\end{verbatim}
The problem here is that the first-letter upper-casing command is
being applied to \code{\gls{gls}\marg{ssi}}. This results in
\code{\gls{gls}\marg{\gls{MakeTextUppercase} ssi}} which has an
invalid label. A workaround is to insert an empty group before
the initial \gls{gls}:
\begin{codeenv}
\gls{newabbreviation}\marg{shtml}\marg{SHTML}\marg{\marg{}\gls{gls}\marg{ssi} enabled \gls{gls}\marg{html}}
\end{codeenv}
However, \gls{gls} functions normally within the glossary, so the
result is:
\begin{result}
\textbf{SSI} Server-side includes

\textbf{HTML} Hypertext markup language

\textbf{SHTML} server-side includes (SSI) enabled hypertext markup language (HTML)
\end{result}
Since neither \code{ssi} nor \code{html} have been referenced in the
document, the reference in the \code{shtml} description in the
glossary is the \idx{firstuse} for both of them, so they show the
full form, but the upper-casing can't be applied. This means that
the description for the \code{shtml} entry doesn't start with an
\idx{uppercase} letter. The best solution is to avoid using
\gls{gls} in the \field{long} field:
\begin{codeenv}
\cmd{documentclass}\marg{book}
\strut
\cmd{usepackage}[\styopt{record}]\marg{glossaries-extra}
\strut
\gls{glssetcategoryattribute}\marg{abbreviation}\marg{glossdesc}\marg{firstuc}
\strut
\gls[noindex]{glsdefpostdesc}\marg{abbreviation}\marg{\comment{}
 \gls{glsxtrifhasfield}\marg{\field{seealso}}\marg{\gls{glscurrententrylabel}}\comment{}
 \marg{ (\gls{emph}\marg{see also} \gls[noindex=false]{glsxtrseelist}\marg{\gls{glscurrentfieldvalue}})}\comment{}
 \marg{}\comment{}
}
\strut
\gls{newabbreviation}\marg{ssi}\marg{SSI}\marg{server-side includes}
\gls{newabbreviation}\marg{html}\marg{HTML}\marg{hypertext markup language}
\gls{newabbreviation}\oarg{\field{seealso}=\marg{ssi,html}}\marg{shtml}\marg{SHTML}
\marg{server-side includes enabled hypertext markup language}
\strut
\cmd{begin}\marg{document}
\gls{Gls}\marg{shtml}.
\gls{printunsrtglossary}
\cmd{end}\marg{document}
\end{codeenv}
I've used the \field{seealso} key here. (The value should be a
comma-separated list of labels.) It doesn't show
in the glossary by default as it needs an indexing application to add it
automatically to the \idx{locationlist}, so I've used the
\idx{postdescriptionhook} to append the cross-reference. The
\styopt{record} option is needed, otherwise the default
\gls{makeindex} setting will be assumed and an error will occur as
the associated \gls{makeindex} file hasn't been opened. If \bibgls\
support is added then the hook won't be needed.

\section{Shortcut Commands or Active Characters}
\label{sec:activeshortcuts}

Some packages, such as \sty{babel}, provide shortcut commands or
active characters that can be enabled through a particular setting. 
It's best not to use these in entry definitions.
Instead use the full command name. The main problem comes when the
shortcuts aren't enabled until the start of the \envfmt{document}
environment. For example, the \code{ngerman} language setting in
\sty{babel} makes the double quote character (\idx{doublequoteactivechar})
active and it becomes a shortcut for \gls{umlaut} (the umlaut accent
command):
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}[ngerman]\marg{babel}
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{newabbreviation}\marg{rna}\marg{RNA}\marg{ribonukleins"aure}\incorrect
\strut
\cmd{begin}\marg{document}
Explicit use: ribonukleins"aure.
Reference: \gls{gls}\marg{rna}.
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
Explicit use: ribonukleins\"aure. Reference: ribonukleins"aure (RNA).
\end{result}
This is because the double quote character still had its normal
meaning when the \code{rna} entry was defined, so the
\idx{doublequotechar} in the long form is an actual double quote
character not a shortcut for \gls{umlaut}.

Another problem occurs when you have a large file containing entry
definitions that will be shared by multiple documents. If shortcut
commands are used in the entry definitions then every document that
uses those entries must ensure that the appropriate shortcut
commands are set up before use. Also, when using \bibgls, it
recognises commands like \gls{umlaut} but not \sty{babel}
shorthands, so the sorting will be adversely affected if you simply
use \idx{doublequoteactivechar} instead of \gls{umlaut}.

For large files that are written once (with minor subsequent edits),
but reused many times for multiple documents, it's better to use the
actual command (that simply requires the appropriate package to be
loaded, if applicable, without specific options to enable it).


\section{Formatting Commands that Need Direct Access to the Text}
\label{sec:expandedfmt}

If you want to redefine any of the formatting commands
\gls{glstextformat}, \gls{glsxtrregularfont} or
\gls{glsxtrabbreviationfont}, remember that their argument isn't the
actual text but consists of intermediary commands
that determine the required text and any inner formatting, such as
the formatting applied by abbreviation styles.

With the \glsopt{hyperoutside} setting on, the outermost level
will be the command to apply the hyperlink with \gls{glstextformat}
(or the equivalent provided by \catattr{textformat}) 
inside the hyperlink text. (If hyperlinks aren't enabled the outer
command simply does the hyperlink text.)

With \glsopt[false]{hyperoutside}, the outermost level will be
\gls{glstextformat} (or equivalent) with the command that applies
the hyperlink inside the formatting argument.

The next level down sets up the abbreviation styles for the given
category (if appropriate). If the entry isn't an abbreviation or is
an abbreviation classified as regular then
\gls{glsxtrregularfont} is applied to the command that governs how
regular entries are formatted. Otherwise \gls{glsxtrabbreviationfont}
is applied to the command that governs how abbreviations are
formatted.

Finally, there are tests applied to determine if this is the
\idx{firstuse}, if the plural is required, if any case-changing is
required, if the final optional argument has been given, or if a
command such as \gls{glssymbol} has been used.  These tests
determine which field to obtain the \idx{link-text} from. With
abbreviations, any formatting required by the abbreviation style is
finally performed.

This makes it very difficult to apply a formatting command that
needs direct access to the actual text that needs to be displayed.
One possible method is to use:
\nosecformatdef{GlsXtrExpandedFmt}
which first (protected) fully expands \meta{text} and then performs
\meta{cs}\margm{expanded text} where \meta{cs} is a control
sequence. For example, the \isty{soul} package provides the command
\gls{ul} to underline text, but it needs to be able to parse its
argument to work. If I simply try to change the standard
\gls{underline} to \gls{ul} in the earlier example from
\sectionref{sec:glsformats}:
\begin{codeenv}
\cmd{renewcommand}\marg{\gls{glsxtrregularfont}}[1]\marg{\cmd{ul}\marg{\gls{param}1}}
\end{codeenv}
then this causes the error:
\begin{verbatim}
! Package soul Error: Reconstruction failed.
\end{verbatim}
Instead I need:
\begin{codeenv}
\cmd{renewcommand}\marg{\gls{glsxtrregularfont}}[1]\marg{\gls{GlsXtrExpandedFmt}\cmd{ul}\marg{\gls{param}1}}
\end{codeenv}
\emph{and also} \gls{ding} now needs protection:
\begin{codeenv}
\gls{newglossaryentry}\marg{fleuron}\comment{label}
\marg{
  \field{name} = \marg{fleuron},
  \field{symbol} = \marg{\gls{protect}\gls{ding}\marg{167}},
  \field{category} = \marg{ornament},
  \field{description} = \marg{typographic ornament}
}
\end{codeenv}

\section{Buffering Changes to the First Use Flag}
\label{sec:buffering}

The \sty{soul} commands, described above, also have problems if the
\idx{firstuseflag} is switched off within the argument. This can be
demonstrated with the following:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\cmd{usepackage}\marg{soul}
\cmd{usepackage}\marg{glossaries-extra}
\gls{newabbreviation}\marg{ssl}\marg{SSL}\marg{Secure Sockets Layer}
\cmd{begin}\marg{document}
\cmd{ul}\marg{Some text about \gls{gls}\marg{ssl}.}
\cmd{end}\marg{document}
\end{codeenv}
This produces the somewhat confusing error message:
\begin{verbatim}
Glossary entry `{ssl}' has not been defined.
\end{verbatim}
Enclosing \code{\gls{gls}\marg{ssl}} inside the argument of \csfmt{mbox} 
changes the error message to:
\begin{verbatim}
! Package soul Error: Reconstruction failed.
\end{verbatim}
The only way to avoid an error is to switch on the \gls{glsunset}
buffering, which modifies the internal command that normally changes
the \idx{firstuseflag}. Instead, the entry label is simply stored in
an internal list. The buffering is switched on with:
\nosecformatdef{GlsXtrStartUnsetBuffering}
The unstarred form of this command may result in multiple
occurrences of an entry in the buffer's internal list. The starred form,
which only adds an entry's label to the list if not already present,
is better if the list needs to contain unique items.

The current buffer can be iterated over using;
\nosecformatdef{GlsXtrForUnsetBufferedList}
where \meta{cs} is a command that takes a single argument (the
entry's label). Finally, entries in the buffer can be unset and the
buffer cleared with:
\nosecformatdef{GlsXtrStopUnsetBuffering}

The above example will work if it's changed to:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\cmd{usepackage}\marg{soul}
\cmd{usepackage}\marg{glossaries-extra}
\gls{newabbreviation}\marg{ssl}\marg{SSL}\marg{Secure Sockets Layer}
\cmd{begin}\marg{document}
\gls{GlsXtrStartUnsetBuffering}
\cmd{ul}\marg{Some text about \cmd{mbox}\marg{\gls{gls}\marg{ssl}}.}
\gls{GlsXtrStopUnsetBuffering}
\cmd{end}\marg{document}
\end{codeenv}
Note the need for \csfmt{mbox}, which can cause a problem with
line-breaking. Another problem is that if the entry is referenced
multiple times within the same buffer, each use of \gls{gls} (or its
\idxpl{variant}) will be treated as the \idx{firstuse}.

Another workaround is to use \glsopt{textformat} with a command that
uses \gls{GlsXtrExpandedFmt} (see \sectionref{sec:expandedfmt}). For
example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\cmd{usepackage}\marg{soul}
\cmd{usepackage}\marg{glossaries-extra}
\strut
\cmd{newrobustcmd}\marg{\cmd{gul}}[1]\marg{\comment{}
  \marg{\comment{}
   \cmd{def}\gls{glsxtrabbreviationfont}\gls{param}\gls{param}1\marg{\gls{GlsXtrExpandedFmt}\marg{\cmd{ul}}\marg{\gls{param}\gls{param}1}}\comment{}
   \cmd{def}\gls{glsxtrregularfont}\gls{param}\gls{param}1\marg{\gls{GlsXtrExpandedFmt}\marg{\cmd{ul}}\marg{\gls{param}\gls{param}1}}\comment{}
   \gls{param}1\comment{}
  }%
}
\strut
\gls{newabbreviation}\marg{ssl}\marg{SSL}\marg{Secure Sockets Layer}
\cmd{begin}\marg{document}
\cmd{ul}\marg{Some text about }\gls{gls}\oarg{\glsopt{textformat}=gul}\marg{ssl}.
\cmd{end}\marg{document}
\end{codeenv}

\chapter{Incorporating \bibgls}
\label{sec:bib2gls}

So far, the examples haven't actually used \bibgls, so what does it
actually do? Recall the example document in \sectionref{sec:group},
reproduced below:
\begin{codeenv}
\cmd{documentclass}\marg{scrartcl}
\cmd{usepackage}\marg{mhchem}
\cmd{usepackage}[\styopt[dot]{postpunc},\comment{full stop after description}
 \styopt{nostyles},\comment{don't load default style packages}
 \styopt[tree]{stylemods}\comment{load glossary-tree.sty and patch styles}
]\marg{glossaries-extra}
\strut
\gls{glsaddstoragekey}\marg{group}\marg{}\marg{\cmd{grouplabel}}
\gls{glsxtrsetgrouptitle}\marg{greek}\marg{Greek Symbols}
\strut
\gls{newglossaryentry}\marg{area}
\marg{
   \field{name} = \marg{\gls{ensuremath}\marg{A}},
   \field{description} = \marg{area},
   \field{group} = \marg{A}
}
\strut
\gls{newglossaryentry}\marg{amethyst}
\marg{
   \field{name} = \marg{amethyst},
   \field{description} = \marg{a purple type of quartz},
   \field{symbol} = \marg{\gls{ce}\marg{SiO2}},
   \field{group} = \marg{A}
}
\strut
\gls{newglossaryentry}\marg{circumference}
\marg{
   \field{name} = \marg{\gls{ensuremath}\marg{C}},
   \field{description} = \marg{circumference},
   \field{group} = \marg{C}
}
\strut
\gls{newglossaryentry}\marg{duck}
\marg{
   \field{name} = \marg{duck},
   \field{description} = \marg{a waterbird with webbed feet},
   \field{group} = \marg{D}
}
\strut
\gls{newglossaryentry}\marg{goose}
\marg{
   \field{name} = \marg{goose},
   \field{description} = \marg{a large waterbird with a long neck, short legs,
   webbed feet and a short broad bill},
   \field{group} = \marg{G}
}
\strut
\gls{newglossaryentry}\marg{radius}
\marg{
   \field{name} = \marg{\gls{ensuremath}\marg{r}},
   \field{description} = \marg{radius},
   \field{group} = \marg{R}
}
\strut
\gls{newglossaryentry}\marg{pi}
\marg{
   \field{name} = \marg{\gls{ensuremath}\marg{\cmd{pi}}},
   \field{description} = \marg{Archimedes' constant},
   \field{group} = \marg{greek}
}
\strut
\cmd{begin}\marg{document}
\gls{printunsrtglossary}\oarg{\printglossopt[indexgroup]{style}}
\cmd{end}\marg{document}
\end{codeenv}
The document preamble is quite cluttered. It could be tidied up by
moving all the \gls{newglossaryentry} code into a separate file
called, say, \filefmt{entries.tex}. The main document code can now
be simplified to:
\begin{codeenv}
\cmd{documentclass}\marg{scrartcl}
\cmd{usepackage}\marg{mhchem}
\cmd{usepackage}[
 \styopt{record},\comment{create \field{group} field and other stuff}
 \styopt[dot]{postpunc},\comment{full stop after description}
 \styopt{nostyles},\comment{don't load default style packages}
 \styopt[tree]{stylemods}\comment{load glossary-tree.sty and patch styles}
]\marg{glossaries-extra}
\strut
\gls{glsxtrsetgrouptitle}\marg{greek}\marg{Greek Symbols}
\strut
\gls[noindex=false]{input}\marg{entries}\comment{input entries.tex}
\strut
\cmd{begin}\marg{document}
\gls{printunsrtglossary}\oarg{\printglossopt[indexgroup]{style}}
\cmd{end}\marg{document}
\end{codeenv}
This is much neater, but maintaining the \filefmt{entries.tex} file is
quite troublesome. Each entry must be defined in the correct order
(that matches the desired listing in \gls{printunsrtglossary}) and
only those entries that should appear in \gls{printunsrtglossary}
should be defined (unless you want the laborious task of filtering
them out, as in \sectionref{sec:printglossagain}). The \field{group}
field needs setting for every entry, and if the \field{location}
field also needs setting then the \filefmt{entries.tex} file will
need to be modified every time new document edits cause a shift in
the page numbers.

With \bibgls, you write all the entry definitions (without the
\field{group} or \field{location} fields set) in one or more
\ext{bib} files. It's then \bibgls\ that creates the equivalent of
the above \filefmt{entries.tex} file with all the entry definitions
in the correct order and with the \field{group} or \field{location}
fields set, if appropriate. To avoid accidentally overwriting an
important document file, \bibgls\ uses the extension \ext{glstex}
rather than \ext{tex} (but it's still a file containing \LaTeX\ code
that defines the entries using \gls{newabbreviation} or
\gls{newglossaryentry}\footnote{Actually it uses
\gls{longnewglossaryentry*} to allow for multi-paragraph descriptions,
and \gls{longnewglossaryentry*} and \gls{newabbreviation} are used
indirectly through helper commands.}).

Instead of using \gls{input} in the document preamble, you now need
to use:
\nosecformatdef{GlsXtrLoadResources}
The \ext{glstex} file doesn't exist on the first \LaTeX\ run as
\bibgls\ can only create the file once the \ext{aux} file has been
created (since the \ext{aux} file contains all the information about
which entries to select, the name of the \ext{bib} files where their
definitions are stored and how to order them).
So \gls{GlsXtrLoadResources} tests if the \ext{glstex} file exists
before trying to input it. The \styopt{record} option is necessary
because it:
\begin{itemize}
\item enables the \styopt[warn]{undefaction} option (the entries
aren't defined on the first \LaTeX\ run);
\item creates the \field{group} and \field{location} fields;
\item disables the \gls{makeindex}\slash\gls{xindy} indexing and
instead writes the indexing information as a record in the \ext{aux}
file;
\item loads \sty{glossaries-extra-bib2gls} (which provides
extra commands specific to \bibgls).
\end{itemize}
Each time you use a command like \gls{gls} or \gls{glssymbol} (but
not like \gls{glsentrysymbol}) in the document, a record is added to
the \ext{aux} file containing the entry's label, the location (by
default the page number) where the entry was used, and extra
information including how to format the location. The default
behaviour of \bibgls\ is to only select those entries that have
records in the \ext{aux} file and any dependent entries.

The example above doesn't include any references (commands like
\gls{gls}), so \bibgls\ won't select any entries and the
\ext{glstex} file won't contain any definitions. This means that the
glossary will be empty. If you want all entries from the specified
\ext{bib} files selected then you need to change the \csopt{selection}
setting:
\begin{codeenv}
\gls{GlsXtrLoadResources}\oarg{\csopt[all]{selection}}
\end{codeenv}
This doesn't explicitly name any \ext{bib} file. The default is 
\code{\gls{jobname}\ext{bib}} but you can change this with the
\csopt{src} option. For example, if the entries are defined in
\filefmt{entries.bib} (regular terms), \filefmt{symbols.bib}
(symbols) and \filefmt{abbrvs.bib} (abbreviations) then you need 
to use:
\begin{codeenv}
\gls{GlsXtrLoadResources}\oarg{
  \csopt[entries,symbols,abbrvs]{src},\comment{bib files}
  \csopt[all]{selection}\comment{select all entries}
}
\end{codeenv}

You can have multiple instances of \gls{GlsXtrLoadResources}, but
remember that each instance inputs a file containing definitions, and
the glossary produced with \gls{printunsrtglossary} follows the same
order. This means that you can have blocks within the same glossary
that use different sorting methods. For example:
\begin{codeenv}\renewcommand{\glslinkpresetkeys}{}%
\gls{GlsXtrLoadResources}\oarg{
  \csopt[symbols]{src},\comment{bib file}
  \csopt[letter-case]{sort},\comment{sort according to character code}
  \csopt[symbol]{category},\comment{set this as the \field{category} field}
  \csopt[glssymbols]{group}\comment{set this as the \field{group} field}
}
\gls{GlsXtrLoadResources}\oarg{
  \csopt[entries,abbrvs]{src},\comment{bib files}
  \csopt[en-GB]{sort}
}
\end{codeenv}
The first instance fetches the data from \filefmt{symbols.bib},
sorts the entries according to the character code, sets the
\field{category} field to \code{symbol}, and sets the
\field{group} field to \code{glssymbols} for each definition
written to the \ext{glstex} file. The \code{glssymbols} group label is recognised by
the \sty{glossaries} package, and the title is obtained from the
language-sensitive \gls{glssymbolsgroupname} command (\qt{Symbols}
in English). So the glossary will start with a symbols group
that contains all the entries selected from \filefmt{symbols.bib}.
The rest of the glossary is obtained from the data selected from the
\filefmt{entries.bib} and \filefmt{abbrvs.bib} file sorted according
to the en-GB locale. These entries will have the \field{group} field
set by the locale's sort rule.

The document build now needs to include a call to \bibgls. For
example, if the main document file is called \filefmt{myDoc.tex}
then the build process is:
\begin{verbatim}
pdflatex myDoc
bib2gls --group myDoc
pdflatex myDoc
\end{verbatim}
Omit the \longarg{group} switch if you want the \field{group} field
left empty, and replace \code{pdflatex} with \code{xelatex} etc, as
appropriate.

\section{The \extfmt{bib} Format}
\label{sec:bibentries}

The \ext{bib} files define entry data in the form:
\begin{codeenv}
\gls[noindex=false]{atchar}\meta{entry type}\marg{\meta{id},
  \meta{field$_1$} = \margm{value},
  \ldots
  \meta{field$_n$} = \margm{value}
}
\end{codeenv}
where \meta{id} is the entry's label. The most basic entry type is
\atentry{entry}. For example:
\begin{codeenv}
\atentry{entry}\marg{goose,
  \field{name} = \marg{goose},
  \field{plural} = \marg{geese},
  \field{description} = \marg{a large waterbird with a long neck, short legs,
   webbed feet and a short broad bill}
}
\end{codeenv}
This is analogous to:
\begin{codeenv}
\gls{newglossaryentry}\marg{goose}
\marg{
  \field{name} = \marg{goose},
  \field{plural} = \marg{geese},
  \field{description} = \marg{a large waterbird with a long neck, short legs,
   webbed feet and a short broad bill}
}
\end{codeenv}
You can use any of the defined keys, such as \field{symbol}:
\begin{codeenv}
\atentry{entry}\marg{amethyst,
  \field{name} = \marg{amethyst},
  \field{description} = \marg{a purple type of quartz},
  \field{symbol} = \marg{\gls{ce}\marg{SiO2}}
}
\end{codeenv}
but avoid using internal fields. If you define custom keys in your
document, make sure you define them all before the first instance of
\gls{GlsXtrLoadResources} as all the recognised keys are written to
the \ext{aux} file for \bibgls\ to detect. Any unrecognised fields
in the \ext{bib} file are ignored.

\begin{important}
The \atentry{entry} type is intended mainly for words or phrases,
optionally with an associated \field{symbol}. If
the \field{name} field contains symbols or other non-alphabetic
content (such as punctuation that shouldn't be ignored by the sort
comparator) see \sectionref{sec:@symbol}.
\end{important}

\subsection{Defining Terms with Optional Descriptions}
\label{sec:@index}

The \atentry{entry} type requires the \field{description} field and
either the \field{name} or \field{parent} field. There's a similar
command that doesn't have any required fields: \atentry{index}. If
the \field{name} isn't supplied, it's assumed to be the same as the
\meta{id}. If the \field{description} isn't supplied it's assumed to
be empty. This type behaves like \atentry{entry}, but it sets the
default \field{category} to \code{index}.  So:
\begin{codeenv}
\atentry{index}\marg{duck}
\end{codeenv}
is analogous to:
\begin{codeenv}
\gls{newglossaryentry}\marg{duck}
\marg{
 \field{name}=\marg{duck},
 \field{description}=\marg{},
 \field{category}=\marg{index}
}
\end{codeenv}
and
\begin{codeenv}
\atentry{index}\marg{goose,
  \field{plural} = \marg{geese}
}
\end{codeenv}
is analogous to:
\begin{codeenv}
\gls{newglossaryentry}\marg{goose}
\marg{
 \field{name}=\marg{goose},
 \field{plural}=\marg{geese},
 \field{description}=\marg{},
 \field{category}=\marg{index}
}
\end{codeenv}
If the name contains content that can't be used in a label (see
\sectionref{sec:labels}), then
you need the \field{name} field. For example:
\begin{codeenv}
\atentry{index}\marg{chateau,
  \field{name} = \marg{ch\gls[noindex=false]{cs.circum}ateau},
  \field{plural} = \marg{ch\gls{cs.circum}ateaux}
}
\end{codeenv}
is analogous to:
\begin{codeenv}
\gls{newglossaryentry}\marg{chateau}
\marg{
 \field{name}=\marg{ch\gls{cs.circum}ateau},
 \field{plural}=\marg{ch\gls{cs.circum}ateaux},
 \field{description}=\marg{},
 \field{category}=\marg{index}
}
\end{codeenv}
There's a similar entry type \atentry{indexplural} that sets the
\field{name} field (if not provided) to the plural form, which is 
obtained from the \field{plural} field, if set. Otherwise it's 
obtained by appending the plural suffix (\qt{s}) to the \field{text} 
field. If the \field{text} field isn't set it's obtained from the label. 
The other difference is that it sets the default \field{category} field to
\code{indexplural}.  For example, 
\begin{codeenv}
\atentry{indexplural}\marg{duck}
\end{codeenv}
is analogous to:
\begin{codeenv}
\gls{newglossaryentry}\marg{duck}
\marg{
 \field{name}=\marg{ducks},
 \field{text}=\marg{duck},
 \field{description}=\marg{},
 \field{category}=\marg{indexplural}
}
\end{codeenv}
and
\begin{codeenv}
\atentry{indexplural}\marg{goose,
  \field{plural} = \marg{geese}
}
\end{codeenv}
is analogous to:
\begin{codeenv}
\gls{newglossaryentry}\marg{goose}
\marg{
 \field{name}=\marg{geese},
 \field{text}=\marg{goose},
 \field{plural}=\marg{geese},
 \field{description}=\marg{},
 \field{category}=\marg{indexplural}
}
\end{codeenv}

The \csopt[firstuc]{name-case-change} resource option converts the
first letter of the \field{name} field to \idx{uppercase}, so with
\begin{codeenv}
\gls{GlsXtrLoadResources}\oarg{\csopt[firstuc]{name-case-change}}
\end{codeenv}
then 
\begin{codeenv}
\atentry{index}\marg{duck}
\end{codeenv}
is now analogous to:
\begin{codeenv}
\gls{newglossaryentry}\marg{duck}
\marg{
 \field{name}=\marg{Duck},
 \field{text}=\marg{duck},
 \field{description}=\marg{},
 \field{category}=\marg{index}
}
\end{codeenv}
and
\begin{codeenv}
\atentry{indexplural}\marg{goose,
  \field{plural} = \marg{geese}
}
\end{codeenv}
is now analogous to:
\begin{codeenv}
\gls{newglossaryentry}\marg{goose}
\marg{
 \field{name}=\marg{Geese},
 \field{text}=\marg{goose},
 \field{plural}=\marg{geese},
 \field{description}=\marg{},
 \field{category}=\marg{indexplural}
}
\end{codeenv}
and
\begin{codeenv}
\atentry{entry}\marg{amethyst,
  \field{name} = \marg{amethyst},
  \field{description} = \marg{a purple type of quartz},
  \field{symbol} = \marg{\gls{ce}\marg{SiO2}}
}
\end{codeenv}
is now analogous to:
\begin{codeenv}
\gls{newglossaryentry}\marg{amethyst}
\marg{
 \field{name}=\marg{Amethyst},
 \field{text}=\marg{amethyst},
 \field{description}=\marg{a purple type of quartz},
 \field{symbol} = \marg{\gls{ce}\marg{SiO2}}
}
\end{codeenv}

\subsection{Defining Abbreviations}
\label{sec:@abbreviation}

Abbreviations can be defined with \atentry{abbreviation}. For
example:
\begin{codeenv}
\atentry{abbreviation}\marg{html,
  \field{short} = \marg{HTML},
  \field{long} = \marg{hypertext markup language}
}
\end{codeenv}
which is analogous to:
\begin{codeenv}
\gls{newabbreviation}\marg{html}\marg{HTML}\marg{hypertext markup language}
\end{codeenv}
(which sets the \field{category} to \code{abbreviation}).
Alternatively, you can use \atentry{acronym}. For example:
\begin{codeenv}
\atentry{acronym}\marg{html,
  \field{short} = \marg{HTML},
  \field{long} = \marg{hypertext markup language}
}
\end{codeenv}
which is analogous to:
\begin{codeenv}
\gls{newacronym}\marg{html}\marg{HTML}\marg{hypertext markup language}
\end{codeenv}
(which sets the \field{category} to \code{acronym}).
If you decide to use one of the abbreviation styles that formats the
\field{short} field with \gls{textsc} (for example,
\abbrstyle{long-short-sc}) then the \field{short} value needs to be
in \idx{lowercase}. (Remember that \gls{textsc} only changes
\idx{lowercase} characters to small capitals. For example,
\code{\gls{textsc}\marg{html}} is displayed as \textsc{html} but
\code{\gls{textsc}\marg{HTML}} is displayed as \textsc{HTML}.)
This can easily be accomplished with the
\csopt{short-case-change} resource option. For example:
\begin{codeenv}
\gls{GlsXtrLoadResources}\oarg{\csopt[lc]{short-case-change}}
\end{codeenv}
Recall from \sectionref{sec:abbreviations} that the abbreviation
style must be set \emph{before} the abbreviations are defined. This
means that if you want to use \gls{setabbreviationstyle} it must
come before \gls{GlsXtrLoadResources}.

The default sort value used by \bibgls\ is usually taken from the
\field{name} field. This typically isn't supplied with abbreviations.
The actual value depends on the abbreviation style, which \bibgls\
doesn't know about, so \bibgls\ uses the \field{short}
field instead for abbreviations. If you want to change this, for
example, if you are using the \abbrstyle{long-noshort-desc} style,
then use the \csopt{abbreviation-sort-fallback} option. For example:
\begin{codeenv}
\gls{GlsXtrLoadResources}\oarg{\csopt[long]{abbreviation-sort-fallback}}
\end{codeenv}

\subsection{Defining Symbols}
\label{sec:@symbol}

If the \field{name} field contains the symbol (rather than having a
textual \field{name} and the symbol in \field{symbol}) then the
notation can be defined with \atentry{symbol}. For example:
\begin{codeenv}
\atentry{symbol}\marg{pi,
  \field{name} = \marg{\gls{ensuremath}\marg{\cmd{pi}}},
  \field{description} = \marg{Archimedes' constant}
}
\end{codeenv}
This behaves much like \atentry{entry} but there are two significant
differences: the \field{category} defaults to \code{symbol} and the
default value used when sorting is the label not the value of the \field{name}
field. So in this case, the sort value defaults to \code{pi}.
Therefore the above is analogous to:
\begin{codeenv}
\gls{newglossaryentry}\marg{pi}
\marg{
  \field{name} = \marg{\gls{ensuremath}\marg{\cmd{pi}}},
  \field{description} = \marg{Archimedes' constant},
  \field{category} = \marg{symbol},
  \field{sort} = \marg{pi}
}
\end{codeenv}
This is essentially like \gls{glsxtrnewsymbol} but it doesn't set
the \field{type} field.

You can change the default value used for sorting symbols with the
\csopt{symbol-sort-fallback} option. For example, to sort symbols according
to the \field{name} field:
\begin{codeenv}\renewcommand{\glslinkpresetkeys}{}%
\gls{GlsXtrLoadResources}\oarg{
 \csopt[name]{symbol-sort-fallback},
 \csopt[none]{break-at}
}
\end{codeenv}
This means that the sort value for the above example entry is now
\code{\gls{ensuremath}\marg{\csfmt{pi}}}, which \bibgls's \TeX\
interpreter converts to the Unicode symbol \hex{1D70B} (mathematical
italic small pi, $\pi$). The interpreter used by \bibgls\ recognises
all the standard mathematical Greek commands, and also the missing
Greek commands \gls{omicron}, \gls{Alpha} etc (which are provided by
\sty{glossaries-extra-bib2gls}). Using these commands rather than
the Latin equivalent ensures correct sorting (\gls{omicron} comes
between \csfmt{xi} and \csfmt{pi}, but \code{o} comes between \code{n}
and \code{p}). See \sectionref{sec:texparserlib} (\TeX\ Parser
Library) in the \bibgls\ user manual for further details.

\begin{important}
The default sort method is designed for words and phrases, so
non-letters, such as punctuation characters, are discarded.
If your sort values include symbols that need to be taken into
account by the comparator, use \csopt[none]{break-at} to prevent
them from being discarded.
\end{important}

Alternatively, you may prefer to sort symbols according to the
description:
\begin{codeenv}\renewcommand{\glslinkpresetkeys}{}%
\gls{GlsXtrLoadResources}\oarg{\csopt[description]{symbol-sort-fallback}}
\end{codeenv}

There's a similar entry type \atentry{number}, which behaves much
like \atentry{symbol} except that it sets the default
\field{category} to \code{number}. It also follows the
\csopt{symbol-sort-fallback} setting. For example, the \code{pi}
entry could be defined as:
\begin{codeenv}
\atentry{symbol}\marg{pi,
  \field{name} = \marg{\gls{ensuremath}\marg{\cmd{pi}}},
  \field{description} = \marg{Archimedes' constant},
  \fieldfmt{value} = \marg{3.141592654}
}
\end{codeenv}
I've used a custom field here (\fieldfmt{value}) that \bibgls\ will
ignore by default. I can instruct \bibgls\ to convert this to a
known field with \csopt{field-aliases}. For example:
\begin{codeenv}
\gls{GlsXtrLoadResources}\oarg{\csopt[value=user1]{field-aliases}}
\end{codeenv}
This makes \bibgls\ treat;
\begin{codeenv}
  \fieldfmt{value} = \marg{3.141592654}
\end{codeenv}
as though it had been:
\begin{codeenv}
  \fieldfmt{user1} = \marg{3.141592654}
\end{codeenv}
This can now be used in one of the hooks (described in
\sectionref{sec:glsformats}). For example, the
\idx{postdescriptionhook}:
\begin{codeenv}\renewcommand{\glslinkpresetkeys}{}%
\gls{glsdefpostdesc}\marg{number}\marg{\comment{check if \field{user1} field given:}
  \gls{glsxtrifhasfield}\marg{\field{useri}}\marg{\gls{glscurrententrylabel}}
  \marg{ (\gls{glscurrentfieldvalue})}
  \marg{}\comment{not provided}
}
\end{codeenv}
It can also be used if you want to order the entries numerically.
For example:
\begin{codeenv}\renewcommand{\glslinkpresetkeys}{}%
\gls{GlsXtrLoadResources}\oarg{
 \csopt[value=user1]{field-aliases},
 \csopt[double]{sort},\comment{use double-precision numeric comparisons}
 \csopt[user1]{sort-field}
}
\end{codeenv}
This uses \csopt{sort-field} to set the field used for sorting. This
affects all entry types.

There are more examples in \sectionref{sec:examples} of the main
\bibgls\ user manual.

\section{Indexing}
\label{sec:record}

By default, \bibgls\ selects entries from the specified \ext{bib}
files that have been directly indexed in the document or that are
dependencies of selected entries. Indexing is performed through
commands like \gls{gls} and \gls{glssymbol} (but not by commands
like \gls{glsentrysymbol}). The \styopt{record} package option
ensures that the indexing is done that matches the requirements of
\bibgls\ (rather than the default \gls{makeindex} syntax).

Each instance of \gls{gls}, \gls{glssymbol} etc writes a
\pidx{record} to the \ext{aux} file, that includes the entry's
label, the location in the document where the record was triggered
and the associated format to encapsulate the location. For example,
if \code{\gls{gls}\marg{duck}} appears on page~3, the record label
is \code{duck}, the location is~3 and the format is the default 
\gls{glsnumberformat}.

The format can be changed with the \glsopt{format} key. For example:
\begin{codeenv}
\gls{gls}\oarg{\glsopt{format}=hyperbf}\marg{duck}
\end{codeenv}
This sets the format to \code{hyperbf}, which makes a bold
hyperlink, if \sty{hyperref} has been loaded, otherwise it just uses
\gls{textbf}. The value of the \glsopt{format} option should be the
name (without a leading backslash) of a text-block command that
takes a single argument (the location to be formatted). The
\sty{glossaries} package provides some commands like \gls{hyperbf}
that may be used to ensure a hyperlink (if supported). The basic
command is:
\nosecformatdef{glshypernumber}
which provides the hyperlink (if enabled) otherwise it just does its
argument. So, if you want, for example, an underlined hyperlink:
\begin{codeenv}
\cmd{newcommand}\marg{\cmd{hyperul}}[1]\marg{\gls[noindex=false]{underline}\marg{\gls{glshypernumber}\marg{\gls{param}1}}}
\end{codeenv}
Now you can use \glsopt[hyperul]{format}.

There's a special command \gls{glsignore} that ignores its argument.
With \gls{makeindex} and \gls{xindy}, this can lead to spurious
commas in the \idx{locationlist}, because the location is still
included in the list, even though the location itself isn't
displayed (since it's discarded by \gls{glsignore}). However, \bibgls\
recognises \glsopt[glsignore]{format} as a special \idx{ignoredrecord}. This
indicates that \bibgls\ should select that particular entry but not
include that record in the \idx{locationlist}.

If a selected entry depends on another entry that hasn't been
indexed, for example, a parent entry, then the dependent entry will
automatically be selected as well, by default. The dependent entry
won't have a \idx{locationlist} if it hasn't been indexed anywhere.
If you don't want the \idxpl{locationlist} to appear in a particular
glossary, use \printglossopt{nonumberlist} in the optional argument
of \gls{printunsrtglossary}.

If you want to index an entry without actually displaying any text,
you can use:
\nosecformatdef{glsadd}
where \meta{label} is the entry's label.  The \glsaddopt{format} key
is again available in \meta{options}. For example:
\begin{codeenv}
\cmd{renewcommand}\marg{\gls{glsextrapostnamehook}}[1]\marg{\comment
  \gls{glsadd}\oarg{\glsaddopt{format}=hyperbf}\marg{\gls{param}1}\comment{}
}
\end{codeenv}
This automatically indexes the given entry in the
\idx{postnamehook}. This is redundant if you only have a single
glossary, but may be useful if the entry is repeated in a later
list. Alternatively, if you are using a dual entry type (see
\sectionref{sec:dualentry} in the main \bibgls\ user manual), the
hook could check for the existence of the dual label (identified by
the \csopt{dual-field} resource option) and use that instead. For
example:
\begin{codeenv}\renewcommand{\glslinkpresetkeys}{}%
\cmd{renewcommand}\marg{\gls{glsextrapostnamehook}}[1]\marg{\comment
  \gls{glsxtrifhasfield}\marg{\gls{GlsXtrDualField}}\marg{\gls{param}1}
  \marg{\comment{}
    \gls{glsadd}\oarg{\glsaddopt{format}=hyperbf}\marg{\gls{glscurrentfieldvalue}}\comment{}
  }\comment{}
  \marg{}\comment{no dual}
}
\end{codeenv}

If you want to index multiple entries at the same time with the same
set of options, you can use:
\nosecformatdef{glsaddeach}
This just iterates through the comma-separated list of labels and
performs \gls{glsadd}\oargm{options}\margm{label} for each label in
\meta{label list}. For example, to ensure that \bibgls\ selects the
entries with the labels \code{duck}, \code{goose} and \code{parrot},
even if they aren't referenced in the document:
\begin{codeenv}
\gls{glsaddeach}\oarg{\glsaddopt[glsignore]{format}}\marg{duck,goose,parrot}
\end{codeenv}
To select all entries, regardless of whether or not they have been
indexed, use the \csopt[all]{selection} resource option. There are
other selection criteria. See the main \bibgls\ user manual for
further details.

\section{Aliasing Fields and Entry Types}
\label{sec:resourcealias}

In \sectionref{sec:abbrvtrans}, the \field{user1} key was used to
store a translation:
\begin{codeenv}
\gls{newabbreviation}\oarg{\field{user1}=\marg{ribonucleic acid}}
 \marg{rna}\marg{RNA}\marg{ribonukleins\gls{umlaut}aure}
\end{codeenv}
You can also use the generic user fields in \ext{bib} files, but
a more flexible approach is to use a semantic naming scheme in the
\ext{bib} file and use resource aliasing to convert these custom
field names into recognised keys. For example, the above
abbreviation could be written in the \ext{bib} file as:
\begin{codeenv}
\atentry{abbreviation}\marg{rna,
  \field{short} = \marg{RNA},
  \field{long} = \marg{ribonukleins\gls{umlaut}aure},
  \fieldfmt{translation} = \marg{ribonucleic acid}
}
\end{codeenv}
The custom \fieldfmt{translation} field will be ignored by \bibgls,
unless it's first defined in the document or aliased in the resource
options:
\begin{codeenv}\renewcommand{\glslinkpresetkeys}{}%
\gls{GlsXtrLoadResources}\oarg{
 \csopt[abbrvs]{src},\comment{entries defined in abbrvs.bib}
 \comment{treat \fieldfmt{translation} as though it's \field{user1}:}
 \csopt[translation=user1]{field-aliases}
}
\end{codeenv}
This makes \bibgls\ behave as though the entry was defined in the
\bibgls\ file as:
\begin{codeenv}
\atentry{abbreviation}\marg{rna,
  \field{short} = \marg{RNA},
  \field{long} = \marg{ribonukleins\gls{umlaut}aure},
  \field{user1} = \marg{ribonucleic acid}
}
\end{codeenv}
The definition is now the same as the above example from
\sectionref{sec:abbrvtrans}. The \ext{bib} entry type can also be
aliased. Here's a modified version:
\begin{codeenv}
\atentryfmt{foreignabbreviation}\marg{rna,
  \field{short} = \marg{RNA},
  \fieldfmt{nativelong} = \marg{ribonukleins\gls{umlaut}aure},
  \fieldfmt{foreignlong} = \marg{ribonucleic acid}
}
\end{codeenv}
and here are the aliases:
\begin{codeenv}\renewcommand{\glslinkpresetkeys}{}%
\gls{GlsXtrLoadResources}\oarg{
 \csopt[abbrvs]{src},\comment{entries defined in abbrvs.bib}
 \comment{treat \atentryfmt{foreignabbreviation} as though it's \atentry{abbreviation}:}
 \csopt[foreignabbreviation=abbreviation]{entry-type-aliases},
 \csopt[nativelong=long,foreignlong=user1]{field-aliases}
}
\end{codeenv}
This has the same result, but suppose another document is in English
rather than German:
\begin{codeenv}\renewcommand{\glslinkpresetkeys}{}%
\gls{GlsXtrLoadResources}\oarg{
 \csopt[abbrvs]{src},\comment{entries defined in abbrvs.bib}
 \csopt[foreignabbreviation=abbreviation]{entry-type-aliases},
 \csopt[foreignlong=long]{field-aliases}
}
\end{codeenv}
Now the \field{long} field is set to the English version, and the
German long form is ignored.

Here's another example where the native language is now English:
\begin{codeenv}\renewcommand{\glslinkpresetkeys}{}%
\atentry{abbreviation}\marg{iso,
  \field{short} = \marg{ISO},
  \field{long} = \marg{International Organization for Standardization}
}
\strut
\atentryfmt{foreignabbreviation}\marg{abnt,
  \field{short} = \marg{ABNT},
  \fieldfmt{foreignlong} = \marg{Associa\gls{c}\marg{c}\gls{cs.tilde}ao Brasileria de Normas T\cs{acute}ecnicas},
  \fieldfmt{nativelong} = \marg{Brazilian National Standards Organization},
  \fieldfmt{language} = \marg{pt-BR}
}
\strut
\atentryfmt{foreignabbreviation}\marg{din,
  \field{short} = \marg{DIN},
  \fieldfmt{foreignlong} = \marg{Deutsches Institut f\gls{umlaut}ur Normung e.V.},
  \fieldfmt{nativelong} = \marg{German Institute for Standardization},
  \fieldfmt{language} = \marg{de-DE-1996}
}
\end{codeenv}
The aliasing is again identified in the resource options:
\begin{codeenv}\renewcommand{\glslinkpresetkeys}{}%
\gls{GlsXtrLoadResources}\oarg{
 \csopt[abbrvs]{src},\comment{entries defined in abbrvs.bib}
 \csopt[foreignabbreviation=abbreviation]{entry-type-aliases},
 \csopt[nativelong=long,foreignlong=user1,language=user2]{field-aliases},
 \csopt[same as original entry]{category}
}
\end{codeenv}
This has an extra setting that assigns the \field{category} field to
the original entry type (before any aliasing occurred) without the
leading \gls{atchar} (and converted to \idx{lowercase}). This makes
\bibgls\ act as though the abbreviations had actually been defined
as:
\begin{codeenv}
\atentry{abbreviation}\marg{iso,
  \field{short} = \marg{ISO},
  \field{long} = \marg{International Organization for Standardization},
  \field{category} = \marg{abbreviation}
}
\strut
\atentryfmt{abbreviation}\marg{abnt,
  \field{short} = \marg{ABNT},
  \field{user1} = \marg{Associa\gls{c}\marg{c}\gls{cs.tilde}ao Brasileria de Normas T\cs{acute}ecnicas},
  \field{long} = \marg{Brazilian National Standards Organization},
  \field{user2} = \marg{pt-BR},
  \field{category} = \marg{foreignabbreviation}
}
\strut
\atentryfmt{abbreviation}\marg{din,
  \field{short} = \marg{DIN},
  \field{user1} = \marg{Deutsches Institut f\gls{umlaut}ur Normung e.V.},
  \field{long} = \marg{German Institute for Standardization},
  \field{user2} = \marg{de-1996},
  \field{category} = \marg{foreignabbreviation}
}
\end{codeenv}
which is now the same as an earlier example in
\sectionref{sec:abbrvtrans}.
If I don't need a particular custom field (such as
\fieldfmt{language} in the above), I can simply omit it from the
aliasing, but it's available for other documents if the need arises.
Here's the complete document modified from
\sectionref{sec:abbrvtrans}:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}[main=british,brazilian,ngerman]\marg{babel}
\cmd{usepackage}[\styopt{record}]\marg{glossaries-extra}
\strut
\gls{setabbreviationstyle}\oarg{foreignabbreviation}\marg{long-short-user}
\strut
\gls{GlsXtrLoadResources}\oarg{
 \csopt[abbrvs]{src},\comment{entries defined in abbrvs.bib}
 \csopt[foreignabbreviation=abbreviation]{entry-type-aliases},
 \csopt[nativelong=long,foreignlong=user1,language=user2]{field-aliases},
 \csopt[same as original entry]{category}
}
\strut
\cmd{renewcommand}*\marg{\gls{glsxtruserparen}}[2]\marg{\comment{}
  \gls{glsxtrfullsep}\marg{\gls{param}2}\comment{}
  \gls{glsxtrparen}
  \marg{\gls{param}1\comment{}
   \gls{ifglshasfield}\marg{\gls{glsxtruserfield}}\marg{\gls{param}2}\comment{}
   \marg{, \gls{emph}\marg{\gls{GlsXtrForeignText}\marg{\gls{param}2}\marg{\gls{glscurrentfieldvalue}}}}\comment{}
   \marg{}\comment{}
  }\comment{}
}
\strut
\cmd{begin}\marg{document}
\gls{gls}\marg{abnt}, \gls{gls}\marg{din}.
\cmd{end}\marg{document}
\end{codeenv}

Here's another example where field and entry aliasing can make the
\ext{bib} data more flexible:
\begin{codeenv}
\atentryfmt{mineral}\marg{amethyst,
 \fieldfmt{mineralname} = \marg{amethyst},
 \fieldfmt{mineraldescription} = \marg{a purple type of quartz},
 \fieldfmt{mineralformula} = \marg{\gls{ce}\marg{SiO2}}
}
\end{codeenv}
For one document, I might use:
\begin{codeenv}
\gls{GlsXtrLoadResources}\oarg{
  \csopt[entries]{src},\comment{data in entries.bib}
  \csopt[mineral=symbol]{entry-type-aliases},
  \csopt[
    mineralformula=name,
    mineralname=description
  ]{field-aliases},
 \csopt[same as original entry]{category}
}
\end{codeenv}
This makes the \code{amethyst} entry behave as though it was defined
as:
\begin{codeenv}
\atentry{symbol}\marg{amethyst,
 \field{description} = \marg{amethyst},
 \field{name} = \marg{\gls{ce}\marg{SiO2}},
 \field{category} = \marg{mineral}
}
\end{codeenv}
Another document might have:
\begin{codeenv}
\gls{GlsXtrLoadResources}\oarg{
  \csopt[entries]{src},\comment{data in entries.bib}
  \csopt[mineral=entry]{entry-type-aliases},
  \csopt[
    mineralformula=symbol,
    mineralname=name
    mineraldescription=description
  ]{field-aliases},
 \csopt[same as original entry]{category}
}
\end{codeenv}
which now makes the \code{amethyst} entry behave as though it was defined
as:
\begin{codeenv}
\atentry{entry}\marg{amethyst,
 \field{name} = \marg{amethyst},
 \field{description} = \marg{a purple type of quartz},
 \field{symbol} = \marg{\gls{ce}\marg{SiO2}},
 \field{category} = \marg{mineral}
}
\end{codeenv}

See \sectionref{sec:examples} in the main \bibgls\ user manual for
more examples of aliasing fields and entry types.

\bibliographystyle{plain}
\bibliography{bib2gls-cite}

\printunsrtglossary*
 [style=treegroup,title={Command Summary},nonumberlist]
{%
 \renewcommand*{\printunsrtglossaryentryprocesshook}[1]{%
   \glsifcategory{#1}{command}{}{\printunsrtglossaryskipentry}%
 }%
 \glssetcategoryattribute{command}{glossdesc}{firstuc}%
 \renewcommand*{\csfmtfont}[1]{\texttt{\color{cs}#1}}%
 \renewcommand{\glstreenamefmt}{\texttt}%
 \renewcommand{\glstreegroupheaderfmt}{\textbf}%
 \renewcommand{\glstreesubitem}{\glspar\parindent=2em\hangindent2em}%
 \renewcommand{\glstreepredesc}{\glsadd{\glscurrententrylabel}%
   \nopagebreak\glstreesubitem}%
 \glsdefpostname{command}{\glsentryuseri{\glscurrententrylabel}}%
 \glsdefpostdesc{command}{.\nopagebreak\glstreesubitem
  \Glsentryuserii{\glscurrententrylabel}.%
  \glspar\medskip}%
}

\renewcommand*{\glstarget}[2]{%
 \glsifcategory{#1}{command}{#2}%
 {%
   \glsifcategory{#1}{standalone}{#2}%
   {\glsdohypertarget{\glolinkprefix#1}{#2}}%
 }%
}
\renewcommand{\glstreeitem}{\par\parindent0pt}
\renewcommand*{\glsxtrbookindexprelocation}[1]{%
  \glsxtrifhasfield{location}{#1}%
  {\enspace
   \textcolor{lightgray}{\nolinebreak\cleaders\hbox to .5em{\hss.\hss}\hfill}%
   \enspace}%
  {}%
}
\renewcommand*{\printunsrtglossaryentryprocesshook}[1]{%
  \glsxtriflabelinlist{\glscategory{#1}}{standalone,hierarchical,homograph}%
  {\printunsrtglossaryskipentry}{}%
}%
\printunsrtglossary[style=bookindex,title=Index]
\end{document}
