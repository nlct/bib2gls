% arara: xelatex
% arara: bib2gls: {group: on}
% arara: bibtex
% arara: xelatex
% arara: bib2gls if found ("log", "has not been defined")
% arara: xelatex if found ("log", "has not been defined")
% arara: xelatex if found ("log", "Rerun")
\documentclass[titlepage=false,fontsize=12pt,captions=tableheading]{scrreprt}

\usepackage[no-math]{fontspec}
\setmainfont{Linux Libertine O}

\newfontface\cyrillicmono{FreeMono}[Scale=MatchLowercase]
\newcommand{\textcyrillicmono}[1]{{\cyrillicmono #1}}

\usepackage[x11names]{xcolor}
\usepackage{upquote}
\usepackage{hologo}
\usepackage{pifont}
\usepackage{graphicx}
\usepackage{datetime2}
\usepackage{siunitx}
\usepackage{mhchem}

\usepackage{xr-hyper}
\usepackage[hidelinks]{hyperref}
\usepackage[record,subentrycounter,nostyles,stylemods={bookindex},style=index]{glossaries-extra}

\definecolor{field}{named}{DarkSlateGray4}
\definecolor{cs}{named}{DarkSeaGreen4}
\definecolor{styopt}{named}{DarkOrchid4}
\definecolor{entry}{named}{SteelBlue4}
\definecolor{comment}{named}{gray}
\definecolor{attribute}{named}{Purple4}
\definecolor{style}{named}{Blue4}

\newcommand{\dhyphen}{%
 \texorpdfstring
 {\discretionary{}{}{}\texttt{-}}%
 {-}%
}

\renewrobustcmd{\-}{%
 \discretionary
 {{\rmfamily\char\ifnum\hyphenchar\font<0
  \defaulthyphenchar\else\hyphenchar\font\fi
 }}%
 {}{}%
}

\setabbreviationstyle[common]{short-nolong}
\setabbreviationstyle[markwordsexample]{long-hyphen-short-hyphen}
\glssetcategoryattribute{markwordsexample}{markwords}{true}
\GlsXtrEnableInitialTagging{taggingexample}{\itag}
\glssetcategoryattribute{discardperiodexample}{discardperiod}{true}
\glssetcategoryattribute{initialism}{insertdots}{true}
\glssetcategoryattribute{initialism}{discardperiod}{true}
\glssetcategoryattribute{initialism}{retainfirstuseperiod}{true}
\setabbreviationstyle[initialism]{short-long}
\setabbreviationstyle[abbrvtrans]{long-short-user}
\setabbreviationstyle[longshortem]{long-short-em}
\setabbreviationstyle[shortsc]{short-sc-nolong}

\newcommand{\bibglspassim}{}
\newcommand{\bibglsseealsosep}{\par\hangindent .75em\parindent .75em\relax}

\GlsXtrLoadResources[
 src={bib2gls},
 max-loc-diff=3,
 entry-type-aliases={dualindexentry=index},
 field-aliases={note=user2},
 symbol-sort-fallback={name},
 break-at={none},
 sort-replace={{,? +}{|},{\glshex2423}{ },
  {([a-zA-Z])\string\.}{\glscapturedgroup1}}
]

\DTMsavetimestamp{creation}{2017-01-20T15:39:00Z}

\IfFileExists{../java/Bib2Gls.java}
{
  \DTMsavefilemoddate{moddate}{../java/Bib2Gls.java}
}
{
  \DTMsavenow{moddate}
}

\newcommand{\bibgls}{\appfmt{bib2gls}}

\newcommand*{\BibTeX}{\hologo{BibTeX}}
\newcommand*{\eTeX}{\hologo{eTeX}}
\newcommand*{\XeLaTeX}{\hologo{XeLaTeX}}
\newcommand*{\LuaLaTeX}{\hologo{LuaLaTeX}}
\newcommand*{\pdfLaTeX}{\hologo{pdfLaTeX}}

\newcommand*{\ctanfile}[2]{%
 \href{http://mirrors.ctan.org/macros/latex/contrib/#1/#2}{\nolinkurl{#2}}%
}

\newcommand{\qt}[1]{``#1''}

\newcommand{\qtt}[1]{\qt{\,\texttt{#1}\,}}

\newcommand{\incorrect}{\marginpar{\textcolor{red}{\ding{55}}}}
\newcommand{\correct}{\marginpar{\textcolor{green}{\ding{52}}}}

\newenvironment{result}%
{%
 \renewcommand{\glslinkpresetkeys}{\setkeys{glslink}{hyper=false,local}}%
 \begin{quotation}%
 \marginpar
  [\raisebox{-2.5ex}{\ding{43}}]%
  {\raisebox{-2.5ex}{\reflectbox{\ding{43}}}}%
 \ignorespaces
}
{\end{quotation}\ignorespacesafterend}

\newcommand{\dequals}{%
 \texorpdfstring
 {\discretionary{}{}{}\texttt{=}\discretionary{}{}{}}%
 {=}%
}

\newcommand{\dcomma}{%
 \texorpdfstring
 {\texttt{,}\discretionary{}{}{}}%
 {,}%
}

\newcommand{\dcolon}{%
 \texorpdfstring
 {\texttt{:}\discretionary{}{}{}}%
 {:}%
}

\pdfstringdefDisableCommands{%
  \def\dhyphen{-}%
  \def\dcolon{:}%
  \def\dcomma{,}%
  \def\dequals{,}%
  \let\-\empty
}

\newcommand*{\csfmtfont}[1]{\texttt{#1}}

\newcommand*{\csfmt}[1]{%
 \texorpdfstring
 {\csfmtfont{\char`\\ #1}}%
 {\string\\#1}%
}

\newcommand*{\appfmt}[1]{\texorpdfstring{\texttt{#1}}{#1}}
\newcommand*{\styfmt}[1]{\texorpdfstring{\textsf{#1}}{#1}}
\newcommand*{\envfmt}[1]{\texorpdfstring{\textsf{#1}}{#1}}
\newcommand*{\optfmt}[1]{\texorpdfstring{\texttt{#1}}{#1}}
\newcommand*{\csoptfmt}[1]{\texorpdfstring{\textcolor{cs}{\optfmt{#1}}}{#1}}
\newcommand*{\styoptfmt}[1]{\texorpdfstring{\textcolor{styopt}{\optfmt{#1}}}{#1}}
\newcommand*{\fieldfmt}[1]{\texorpdfstring{\texttt{\color{field}#1}}{#1}}
\newcommand*{\entryfmt}[1]{\texorpdfstring{\texttt{\color{entry}#1}}{#1}}
\newcommand*{\atentryfmt}[1]{\entryfmt{@#1}}
\newcommand*{\abbrstylefmt}[1]{\texorpdfstring{\textsf{\color{style}#1}}{#1}}
\newcommand*{\glostylefmt}[1]{\texorpdfstring{\textsf{#1}}{#1}}
\newcommand*{\catattrfmt}[1]{\texorpdfstring{\textsf{\color{attribute}#1}}{#1}}
\newcommand*{\counterfmt}[1]{\texorpdfstring{\textsf{#1}}{#1}}
\newcommand*{\filefmt}[1]{\texorpdfstring{\texttt{#1}}{#1}}
\newcommand*{\metafilefmt}[3]{%
  \filefmt{#1}\discretionary{}{}{}\meta{#2}\discretionary{}{}{}\filefmt{#3}%
}

\newcommand*{\extfmt}[1]{\filefmt{.#1}}%

\newcommand*{\argor}{\texorpdfstring{\protect\textbar}{|}}

\newrobustcmd*{\texmeta}[1]{{\normalfont\normalcolor$\langle$\emph{#1}$\rangle$}}

\newcommand*{\meta}[1]{%
 \texorpdfstring{\ifmmode\text{\texmeta{#1}}\else\texmeta{#1}\fi}{#1}%
}

\newcommand*{\oarg}[1]{\discretionary{}{}{}[#1]}
\newcommand*{\oargm}[1]{\oarg{\meta{#1}}}

\newcommand*{\marg}[1]{\texorpdfstring
 {\discretionary{}{}{}\char`\{#1\char`\} }%
 {\{#1\}}%
}

\newcommand*{\margm}[1]{\marg{\meta{#1}}}

\newcommand{\switcharg}{}
\newcommand{\switchalt}{}

\makeatletter
\newcommand{\code}[1]{\texorpdfstring{{\ttfamily\obeyspaces #1}}{#1}}
\newenvironment{codeenv}
 {%
 \renewcommand{\glslinkpresetkeys}{\setkeys{glslink}{noindex}}%
   \def\cmd{\char`\\}%
   \def\comment##1{\textcolor{comment}{\%\ ##1}}%
   \renewcommand*{\styfmt}[1]{##1}%
   \renewcommand*{\counterfmt}[1]{##1}%
   \renewcommand*{\catattrfmt}[1]{\textcolor{attribute}{##1}}%
   \renewcommand*{\abbrstylefmt}[1]{\textcolor{style}{##1}}%
   \renewcommand*{\csfmtfont}[1]{\textcolor{cs}{##1}}%
    \begin{flushleft}\textcolor{lightgray}{\hrulefill}\par\nopagebreak
     \medskip\nopagebreak
     \ttfamily\obeylines\frenchspacing\@vobeyspaces}
 {\nopagebreak\textcolor{lightgray}{\hrulefill}%
  \end{flushleft}\ignorespacesafterend}
\makeatother

\newcommand{\primary}{\emph}
\newcommand{\primaryloc}[1]{\underline{\hyperbf{#1}}}

\newcommand{\pidx}[1][]{\gls[textformat=primary,format=primaryloc,#1]}
\newcommand{\pidxpl}[1][]{\glspl[textformat=primary,format=primaryloc,#1]}
\newcommand{\pIdx}[1][]{\Gls[textformat=primary,format=primaryloc,#1]}
\newcommand{\pIdxpl}[1][]{\Glspl[textformat=primary,format=primaryloc,#1]}

\newcommand{\idx}{\gls}
\newcommand{\idxpl}{\glspl}
\newcommand{\Idx}{\Gls}
\newcommand{\Idxpl}{\Glspl}

\newcommand{\ext}{\gls}

\newcommand*{\iext}[1]{%
 \glsxtrtitleorpdforheading{\idx{#1}}{.#1}{\extfmt{#1}}%
}

\newcommand{\sty}{\gls}

\newcommand*{\isty}[1]{%
  \texorpdfstring{\idx{#1}}{#1}%
}

\newcommand*{\env}[1]{%
  \texorpdfstring{\idx{env.#1}}{#1}%
}

\newcommand*{\abbrstyle}[2][]{%
  \texorpdfstring{\idx[#1]{#2}}{#2}%
}

\newcommand*{\glostyle}[1]{%
  \texorpdfstring{\idx{glostyle.#1}}{#1}%
}

\newcommand*{\catattr}[1]{%
  \texorpdfstring{\idx{#1}}{#1}%
}

\newcommand*{\counter}[1]{%
  \texorpdfstring{\idx{ctr.#1}}{#1}%
}

\newcommand*{\styopt}[2][]{%
  \texorpdfstring%
  {%
    \gls{styopt.#2}\styoptfmt{\ifblank{#1}{}{\dequals\marg{#1}}}%
  }%
  {#2\ifblank{#1}{}{=#1}}%
}

\newcommand*{\keyvallist}{%
 \texorpdfstring
 {key\dequals value list}%
 {key=value list}%
}

\newcommand{\nosecformatdef}[1]{%
  \begin{definition}
   \gls[format=primaryloc]{#1}%
   \glsentryuseri{#1}%
  \end{definition}\ignorespaces
}

\newcommand*{\cs}{\gls}

\newcommand*{\ics}{\cs}

\newcommand*{\icswithargs}[2][]{\cs{#2}\glsentryuseri{#2}}

\newcommand*{\postdeschook}[2][]{%
 \glslink[#1]{idx.glsxtrpostdesccategory}{\csfmt{glsxtrpostdesc#2}}}

\newcommand*{\postlinkhook}[2][]{%
 \glslink[#1]{idx.glsxtrpostlinkcategory}{\csfmt{glsxtrpostlink#2}}}


\glsxtrnewgls{file.}{\exfile}

\newcommand*{\csopt}[2][]{\gencsopt{#1}{opt}{#2}}%
\newcommand*{\glsopt}[2][]{\gencsopt{#1}{gls}{#2}}%
\newcommand*{\glsaddopt}[2][]{\gencsopt{#1}{glsadd}{#2}}%
\newcommand*{\printglossopt}[2][]{\gencsopt{#1}{printgloss}{#2}}%

\newcommand*{\gencsopt}[3]{%
  \texorpdfstring%
  {%
    \gls{#2.#3}%
    \csoptfmt{\ifblank{#1}{}{\dequals\marg{#1}}}%
  }%
  {#3\ifblank{#1}{}{=#1}}%
}

\newcommand*{\field}[1]{%
 \texorpdfstring
 {\gls{field.#1}}%
 {#1}%
}

\newcommand*{\atentry}[2][]{%
 \texorpdfstring
 {\gls[#1]{entry.#2}}%
 {#2}%
}

\newrobustcmd{\longswitch}{\string-{}\string-}

\newcommand*{\longargfmt}[1]{%
 \texorpdfstring{\texttt{\longswitch #1}}%
 {\string-\string-#1}%
}

\newcommand*{\shortargfmt}[1]{%
 \texorpdfstring{\texttt{\string-#1}}%
 {\string-#1}%
}

\newcommand*{\longarg}[1]{%
  \texorpdfstring
  {\gls{switch.#1}}%
  {\string-\string-#1}%
}

\definecolor{defbackground}{rgb}{1,1,0.75}

\newsavebox\borderedboxcontents
\newlength\borderedboxwidth

\newenvironment{definition}%
{%
  \setlength{\fboxsep}{4pt}\setlength{\fboxrule}{1.25pt}%
  \begin{lrbox}{\borderedboxcontents}%
   \setlength\borderedboxwidth\linewidth
   \addtolength\borderedboxwidth{-2\fboxrule}%
   \addtolength\borderedboxwidth{-2\fboxsep}%
   \begin{minipage}{\borderedboxwidth}
   \flushleft\ttfamily\ignorespaces
}%
{%
   \end{minipage}%
  \end{lrbox}\par\medskip\noindent
  \fcolorbox{black}{defbackground}{\usebox\borderedboxcontents}%
  \medskip\par\noindent
  \ignorespacesafterend
}

\newenvironment{important}{%
  \setlength{\fboxrule}{4pt}%
  \setlength\borderedboxwidth{\linewidth}%
  \addtolength\borderedboxwidth{-2\fboxsep}%
  \addtolength\borderedboxwidth{-2\fboxrule}%
  \begin{lrbox}{\borderedboxcontents}%
    \begin{minipage}{\borderedboxwidth}%
    \raggedright
    \setlength\parindent{1em}%
    \noindent\ignorespaces
}%
{%
    \end{minipage}%
  \end{lrbox}%
  \par\vskip10pt\noindent
  \fcolorbox{red}{white}{\usebox{\borderedboxcontents}}\par\vskip10pt
  \noindent\ignorespacesafterend
}

\newcommand*{\sectionref}[1]{section~\ref{#1}}
\newcommand*{\Sectionref}[1]{Section~\ref{#1}}

\newcommand{\doglossaryentry}[1]{%
  \glsxtrglossentry{#1} & \glsentrydesc{#1}\glspostdescription\\%
}
\newcounter{localglossary}
\newenvironment{localglossary}
{%
  \stepcounter{localglossary}%
  \renewcommand{\glolinkprefix}{\thelocalglossary.}%
  \GlsXtrStartUnsetBuffering*
}
{%
  \par
  \begin{tabular}{ll}
  \GlsXtrForUnsetBufferedList\doglossaryentry
  \end{tabular}
  \GlsXtrStopUnsetBuffering
  \par
}
\pagestyle{headings}

\newcommand{\glossarytitle}{Index}
\externaldocument{bib2gls}

\newcommand{\addr}[1]{\\\href{https://www.#1/}{\nolinkurl{#1}}}
\title{\bibgls\ and \styfmt{glossaries-extra}: A Guide for Beginners}
\author{Nicola Talbot\addr{dickimaw-books.com}}
\date{\DTMusedate{moddate}}

\makeatletter
\begingroup
 \renewcommand{\addr}[1]{}
 \let\texorpdfstring\@secondoftwo
 \DTMsetstyle{pdf}
 \protected@edef\x{\endgroup
   \noexpand\hypersetup{%
     pdfinfo={
       Title={\@title},
       Author={\@author},
       CreationDate={\DTMuse{creation}},
       ModDate={\DTMuse{moddate}},
     }%
   }%
 }\x

\makeatother

\begin{document}
\maketitle
\pagenumbering{alph}
\thispagestyle{empty}

\begin{abstract}
This document is an introductory guide to \bibgls\ and the
\sty{glossaries-extra} package to help you get started. For
further information, including more complex commands and settings,
see the main \bibgls\ user manual (\filefmt{bib2gls.pdf},
in the same directory as this document),
the \isty{glossaries-extra} user manual,
(distributed with the \sty{glossaries-extra}
package~\cite{glossaries-extra})
and the \isty{glossaries} user manual
(distributed with the \sty{glossaries} package~\cite{glossaries}).

The \sty{glossaries} package is the \emph{base} package. The 
\sty{glossaries-extra} package internally loads the \sty{glossaries} package 
and extends it, providing extra options or modifying the base
commands to increase flexibility. If you want to use \bibgls, you
must load \sty{glossaries-extra}, which provides the interface
required by \bibgls.
This document doesn't cover the other indexing methods described in
the base package.
\end{abstract}

\clearpage
\pagenumbering{roman}
\tableofcontents

\clearpage
\pagenumbering{arabic}

\chapter{Introduction}
\label{sec:beginintro}

The \sty{glossaries} package provides a way of defining terms,
notation or abbreviations that can then be used in the document.
This ensures consistent naming and formatting. (With the help of the
\sty{hyperref} package, it's also possible to create hyperlinks from
the reference to a place in the document that provides a definition
of the term, but more about that later.) Each entry (term,
notation or abbreviation) is defined using:
\nosecformatdef{newglossaryentry}
Here's a simple example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries}
\strut
\gls{newglossaryentry}\marg{duck}\comment{label}
\marg{\comment{ information about this term:}
  \field{name}=\marg{duck},\comment{ display name}
  \field{description}=\marg{a waterbird with webbed feet}\comment{description}
}
\strut
\gls{newglossaryentry}\marg{goose}\comment{ label}
\marg{\comment{information about this term:}
  \field{name}=\marg{goose},\comment{display name}
  \field{plural}=\marg{geese},\comment{plural form}
  \field{description}=\marg{a large waterbird with a long neck, short legs,
   webbed feet and a short broad bill}
}
\strut
\cmd{begin}\marg{document}
The pond contained a \gls{gls}\marg{duck} (\gls{glsentrydesc}\marg{duck}) and 
a \gls{gls}\marg{goose} (\gls{glsentrydesc}\marg{goose}). \gls{Glspl}\marg{duck} and 
\gls{glspl}\marg{goose} are fowl.
\cmd{end}\marg{document}
\end{codeenv}
The resulting text is:
\begin{result}
The pond contained a \gls{ex1.duck} (\glsentrydesc{ex1.duck}) and 
a \gls{ex1.goose} (\glsentrydesc{ex1.goose}). \Glspl{ex1.duck} and
\glspl{ex1.goose} are fowl.
\end{result}
For convenience, the text produced by commands such as \cs{gls} is called the 
\pidx{link-text} (even if there are no hyperlinks).

The first argument of \gls{newglossaryentry} is a label that
uniquely identifies the term (see \sectionref{sec:labels}). The
second argument is a comma-separated list of
\meta{setting}\dequals\meta{value} assignments.  Each \meta{setting}
is referred to as a \qt{key} in the \isty{glossaries} manual or as a
\qt{field} in the \bibgls\ manual. A list of the available base keys
can be found in the \isty{glossaries} user manual.  The
\isty{glossaries-extra} package provides some additional keys that
are described in the \sty{glossaries-extra} manual. The \bibgls\
user manual summarises all keys (fields) in \sectionref{sec:fields}.

\begin{important}
If the field value contains commas or equal signs the value must be grouped
to hide those characters from the \meta{key}\dequals\meta{value} parser.
\end{important}

The two main keys are \field{name} and \field{description}. The
\field{name} identifies how the term should be displayed in the
glossary (see \sectionref{sec:displaygloss}). It also provides the
default singular term, if not explicitly given. The default plural
is obtained by appending \qt{s} to the singular form. If this isn't
correct (as with \qt{geese}), then the plural form can be specified
with the \field{plural} key.

The description (set with the \field{description} key) is usually
only displayed in the glossary, but you can display it in the text
using:
\nosecformatdef{glsentrydesc}
as in the above example. This simply expands to the value of the
\field{description} field (or does nothing if there's no entry
associated with the given label).

The main command used to reference a term is:
\nosecformatdef{gls}
In the above example, \gls{gls} just displays the singular form, but you
can provide alternative text to use the first time a term is
referenced (see \sectionref{sec:firstuse}). The plural form is obtained with
the \pidx{variant} command:
\nosecformatdef{glspl}
There are other \idxpl{variant} of \gls{gls} that perform
\glslink{case-change}{case-changing}.
If you want to start a sentence with an entry then you can use:
\nosecformatdef{Gls}
for the singular form and
\nosecformatdef{Glspl}
for the plural form. For all capitals, use:
\nosecformatdef{GLS}
for the singular form and
\nosecformatdef{GLSpl}
for the plural form. Any mention of \gls{gls} and its
\idxpl{variant} in this guide or in the user manuals means that the
comments applied to \gls{gls} also apply to the plural and
case-changing versions.

The \meta{insert} optional argument is provided to insert additional material.
For example:
\begin{codeenv}
The \gls{gls}\marg{goose} liked the \gls{gls}\marg{duck}['s] hat.
\end{codeenv}
which produces (assuming the above definitions):
\begin{result}
The \gls{ex1.goose} liked the \gls{ex1.duck}['s] hat.
\end{result}
In some cases, there may not be a noticeable difference between the
above and the following:
\begin{codeenv}
The \gls{gls}\marg{goose} liked the \gls{gls}\marg{duck}'s hat.
\end{codeenv}
It depends on other settings, such as whether or not hyperlinks have
been enabled. (The inserted material is commonly moved inside the
hyperlink.) Take care if you need a literal open square bracket
following \code{\cs{gls}\margm{label}} as you need to prevent it from being
interpreted as the optional \meta{insert} argument. For example:
\begin{codeenv}
The \gls{gls}\marg{goose} liked the \gls{gls}\marg{duck}\marg{['s]} hat.
\end{codeenv}
which now produces:
\begin{result}
The \gls{ex1.goose} liked the \gls{ex1.duck}{['s]} hat.
\end{result}
An alternative in this case could be to define:
\begin{codeenv}
\cmd{newcommand}*\marg{\cmd{missing}}[1]\marg{[\gls*{param}1]}
\end{codeenv}
and then use:
\begin{codeenv}
The \gls{gls}\marg{goose} liked the \gls{gls}\marg{duck}\cmd{missing}\marg{'s} hat.
\end{codeenv}
This conveniently hides the open square bracket from \cs{gls}.

\begin{important}
Commands like \gls{gls} are \idx{robust}. Commands like
\gls{glsentrydesc} are \idx{expandable}. (See \sectionref{sec:robust}.)
If you want the entry to appear in a PDF bookmark, you need to use an 
expandable command to reference it.
\end{important}

There are some helper commands that internally use
\gls{newglossaryentry}, such as \cs{newabbreviation} (described in
\sectionref{sec:abbreviations}) and \cs{glsxtrnewsymbol} (described
in \sectionref{sec:symbols}). If the description contains explicit paragraph
breaks then:
\nosecformatdef{longnewglossaryentry}
is required instead.

\section{Labels}
\label{sec:labels}

The label used to identify the entry can't contain any special characters, such
as \gls{commentchar} (percent), \gls{ampchar} (ampersand), \gls{param} (hash),
\gls{mshiftchar} (dollar), or \gls{nbspchar} (tilde).  Be careful of packages
that make other characters active (such as \isty{babel} with its shortcuts). If
you are using \isty{inputenc}, this also includes extended Latin characters and
characters from other scripts. If you want to include UTF-8 characters in the
label then you must use a \TeX\ engine with native Unicode support (that is,
\XeLaTeX\ or \LuaLaTeX).

For example, with no UTF-8 support (not even \sty{inputenc}):
\begin{codeenv}
\gls{newglossaryentry}\marg{elite}\comment{label (no UTF-8 support)}
\marg{
  \field{name} = \marg{\marg{\gls{acute}e}lite},
  \field{description} = \marg{group of people regarded as
  the best of a particular society or organisation}
}
\end{codeenv}
or with \sty{inputenc}:
\begin{codeenv}
\gls{newglossaryentry}\marg{elite}\comment{label (UTF-8 not natively supported)}
\marg{
  \field{name} = \marg{élite},
  \field{description} = \marg{group of people regarded as
  the best of a particular society or organisation}
}
\end{codeenv}
Whereas with \XeLaTeX\ or \LuaLaTeX\ you can do:
\begin{codeenv}
\gls{newglossaryentry}\marg{élite}\comment{label (UTF-8 natively supported)}
\marg{
  \field{name} = \marg{élite},
  \field{description} = \marg{group of people regarded as
  the best of a particular society or organisation}
}
\end{codeenv}

You may have noticed the grouping of the initial (accented) letter
in the \gls{ASCII} example (\code{\marg{\gls{acute}e}lite}). This is
necessary to ensure that the first-letter case-changing commands,
such as \ics{Gls}, work. It also used to be required around the
\qtt{é} with \sty{inputenc}, but if you have up-to-date versions of
\sty{glossaries} and \sty{datatool} then it should no longer be
necessary. No special treatment is needed with \XeLaTeX\ or
\LuaLaTeX\ where \qtt{é} is a single token.

If you can't use extended characters in the label (because you're
not using \XeLaTeX\ or \LuaLaTeX), then simply stripping the accents
to create an \gls{ASCII} alternative may be sufficient, but take
care if this may cause a conflict. For example:
\begin{codeenv}
\gls{newglossaryentry}\marg{resume}\comment{label}
\marg{
  \field{name} = \marg{resume},
  \field{description} = \marg{continue after an interruption}
}
\strut
\gls{newglossaryentry}\marg{resumee}\comment{label}
\marg{
  \field{name} = \marg{r\gls{acute}esum\gls{acute}e},
  \field{description} = \marg{summary of something or curriculum vitae}
}
\end{codeenv}
For languages that use a non-Latin script, if you can't or don't
want to use \XeLaTeX\ or \LuaLaTeX, then you need to decide the most
appropriate \gls{ASCII} naming scheme.
For example:
\begin{codeenv}
\gls{newglossaryentry}\marg{goose}\comment{using translation for label}
\marg{
  \field{name} = \marg{\textcyrillicmono{гусь}},
  \field{plural} = \marg{\textcyrillicmono{гуси}},
  \field{description} = \marg{\textnormal{\ldots}}
}
\end{codeenv}
or
\begin{codeenv}
\gls{newglossaryentry}\marg{hus}\comment{using closest ASCII match for label}
\marg{
  \field{name} = \marg{\textcyrillicmono{гусь}},
  \field{plural} = \marg{\textcyrillicmono{гуси}},
  \field{description} = \marg{\textnormal{\ldots}}
}
\end{codeenv}

In addition to labels identifying entries, there are also labels
that identify other things, such as a glossary, category or letter
group. The same restrictions apply to those labels.

\section{First Use}
\label{sec:firstuse}

Each entry has a \pidx{firstuseflag} (boolean variable) that
determines whether or not the entry has been referenced in the
document.  Commands like \gls{gls} and \gls{glspl} change the flag
to indicate that the entry has been used. Commands like
\gls{glsentrydesc} don't. Here's a modification of the earlier
example document that provides different versions depending on 
whether or not the entry has already been referenced:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries}
\strut
\gls{newglossaryentry}\marg{duck}\comment{label}
\marg{\comment{information about this term:}
  \field{name}   = \marg{Duck (noun)},\comment{display name}
  \field{first}  = \marg{duck (quack, quack)},\comment{first use singular}
  \field{firstplural} = \marg{ducks (quack, quack)},\comment{first use plural}
  \field{text}   = \marg{duck},\comment{subsequent use singular}
  \field{description} = \marg{a waterbird with webbed feet}\comment{description}
}
\strut
\gls{newglossaryentry}\marg{goose}\comment{label}
\marg{\comment{information about this term:}
  \field{name}   = \marg{Goose (noun, pl.\ geese)},\comment{display name}
  \field{first}  = \marg{goose (honk, honk)},\comment{first use singular}
  \field{firstplural} = \marg{geese (honk, honk)},\comment{first use plural}
  \field{text}   = \marg{goose},\comment{subsequent use singular}
  \field{plural} = \marg{geese},\comment{subsequent use plural}
  \field{description}=\marg{a large waterbird with a long neck, short legs,
   webbed feet and a short broad bill}
}
\strut
\cmd{begin}\marg{document}
The pond contained a \gls{gls}\marg{duck}\cmd{footnote}\marg{\gls{glsentryname}\marg{duck}:
\gls{glsentrydesc}\marg{duck}} and two 
\gls{glspl}\marg{goose}\cmd{footnote}\marg{\gls{glsentryname}\marg{goose}: 
\gls{glsentrydesc}\marg{goose}}. \gls{Glspl}\marg{duck} and \gls{glspl}\marg{goose} are fowl.
\cmd{end}\marg{document}
\end{codeenv}
This now produces:
\begin{result}
The pond contained a \gls{ex2.duck}\footnote{\glsentryname{ex2.duck}:
\glsentrydesc{ex2.duck}} and two
\glspl{ex2.goose}\footnote{\glsentryname{ex2.goose}: 
\glsentrydesc{ex2.goose}}. \Glspl{ex2.duck} and \glspl{ex2.goose} are fowl.
\end{result}
This uses:
\nosecformatdef{glsentryname}
which works in a similar way to \gls{glsentrydesc}. In this case,
\gls{glsentryname} simply expands to the value of the \field{name}
key. There's also a case-changing version:
\nosecformatdef{Glsentryname}
which changes the initial character to \idx{uppercase},
but (unlike \cs{glsentryname}) this command isn't expandable. If,
for example, I had instead set the duck's \field{name} key using:
\begin{codeenv}
\field{name} = \marg{duck (noun)}
\end{codeenv}
then I would need to use \code{\gls{Glsentryname}\marg{duck}}
instead.

So on \pidx{firstuse}, \cs{gls} uses the value of the \field{first} key
and \cs{glspl} uses the value of the \field{firstplural} key. On
\pidx{subsequentuse}, \cs{gls} uses the value of the \field{text} key and
\cs{glspl} uses the value of the \field{plural} key. \pIdx{regular}
abbreviations also follow this usage. \pIdx{non-regular}
abbreviations follow a different behaviour for \gls{gls} (and its
\idxpl{variant}) that's determined by the abbreviation style.

If the first use for a particular group of terms always has the
same pattern (such as following the term with a brief description or
alternative representation), then it's simpler to use one of the
automated methods provided, such as the abbreviation mechanism
(\sectionref{sec:abbreviations}) or changing the formatting
(\sectionref{sec:glsformats}).

\section{Categories}
\label{sec:categories}

The \isty{glossaries-extra} extension package provides the
\field{category} key, which isn't available with just the base
\sty{glossaries} package. The value of this key must be a
label as it's used to construct command names. You can choose
whatever label you like (as long as it conforms to the valid
labelling scheme, described in \sectionref{sec:labels}). If you
don't specify a category, then \gls{newglossaryentry} and
\gls{longnewglossaryentry} assume \code{general}. The helper
commands, such as \gls{newabbreviation}, have different defaults.

For example:
\begin{codeenv}
\gls{newglossaryentry}\marg{amethyst}
\marg{
   \field{name} = \marg{amethyst},
   \field{description} = \marg{a purple type of quartz},
   \field{category} = \marg{mineral}
}
\end{codeenv}
The value of the \field{category} field for a given entry can be obtained
with:
\nosecformatdef{glscategory}
where \meta{label} identifies the entry. This command is expandable
and does nothing if the entry hasn't been defined. You can test the
value of the \field{category} field using:
\nosecformatdef{glsifcategory}
This checks if the \field{category} field for the entry given by
\meta{label} is set to \meta{category}, but doesn't perform any
expansion. It generates an error if the entry doesn't exist (or
warning with \styopt[warn]{undefaction}).

The category allows you to apply certain types of formatting, such
as the \idx{postlinkhook} (\sectionref{sec:postlinkhooks}).
For abbreviations, the category also governs the abbreviation style (see
\sectionref{sec:abbreviations}) and can be used for filtering.
Categories may be assigned \pidxpl{attribute} that can also be used
to modify formatting or styles. 

Unlike the \idx{postlinkhook}, which
needs to be defined before an entry is \emph{used} (with commands like
\gls{gls}), some \idxpl{attribute} need to be set before the entry
is \emph{defined}, so it's best to set them up as soon as possible in the
preamble (after loading \sty{glossaries-extra}).

\section{Adding Extra Information}
\label{sec:userkeys}

In addition to the \field{name} and \field{description} keys,
there's also a \field{symbol} key which allows you to store an
associated symbol. The value can be obtained with:
\nosecformatdef{glssymbol}
(which is robust and recognises the \idx{postlinkhook}) or with:
\nosecformatdef{glsentrysymbol}
(which behaves like \gls{glsentrydesc} and \gls{glsentryname}).
Neither of the above commands affect the \idx{firstuseflag}.
For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}[hidelinks]\marg{hyperref}
\cmd{usepackage}\marg{glossaries}
\strut
\gls{newglossaryentry}\marg{pi}\comment{label}
\marg{\comment{settings:}
   \field{name}   = \marg{Archimedes' constant},
   \field{symbol} = \marg{\gls[noindex=false]{ensuremath}\marg{\cmd{pi}}},
   \field{description} = \marg{ratio of a circle's circumference to its 
diameter}
}
\strut
\gls{newglossaryentry}\marg{thetai}\comment{label}
\marg{\comment{settings:}
   \field{name}   = \marg{theta parameter},
   \field{symbol} = \marg{\gls{ensuremath}\marg{\cmd{theta}\gls{sbchar}i}},
   \field{description} = \marg{one of the model parameters}
}
\strut
\cmd{begin}\marg{document}
\gls{gls}\marg{pi} (\gls{glssymbol}\marg{pi}). Compare \gls{mshiftchar}\gls{glssymbol}\marg{thetai}\gls[noindex=false]{spchar}2\gls{mshiftchar}
with \gls{mshiftchar}\gls{glssymbol}\marg{thetai}[\gls{spchar}2]\gls{mshiftchar}.
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
\gls{ex.pi} (\glssymbol{ex.pi}). Compare $\glssymbol{ex.thetai}^2$
with $\glssymbol{ex.thetai}[^2]$.
\end{result}
Note that in this case there is now a difference between using the
final optional \meta{insert} argument and simply appending the extra
material. This is a result of the hyperlink that causes an
interruption between the subscript \code{\gls{sbchar}i} and the following
superscript \code{\gls{spchar}2}. (In this case, there's no target for the
hyperlinks. That's covered in \sectionref{sec:displaygloss}.)

If you have additional information, such as a translation,
associated image or citation, then you can supply this with the six
user keys:
\field{user1}\glsaddeach{field.user2,field.user3,field.user4,field.user5}, 
\ldots, \field{user6}. The value of the
first field can be obtained with:
\nosecformatdef{glsuseri}
(which behaves like \gls{glssymbol}) or with:
\nosecformatdef{glsentryuseri}
(which behaves like \gls{glsentrysymbol}).
\glsaddeach{glsuserii,glsuseriii,glsuseriv,glsuserv,%
glsentryuserii,glsentryuseriii,glsentryuseriv,glsentryuserv}%
The other fields are similarly obtained using \idx{lowercase} Roman
numerals, so the sixth field can be obtained with:
\nosecformatdef{glsuservi}
(which behaves like \gls{glssymbol}) or with:
\nosecformatdef{glsentryuservi}
(which behaves like \gls{glsentrysymbol}).
For example:
\begin{codeenv}
\gls{newglossaryentry}\marg{polly.parrot}\comment{label}
\marg{\comment{}
   \field{name} = \marg{Polly Parrot},
   \field{description} = \marg{Senior assistant at the International Society 
of Duck and Geese},
   \field{user1} = \marg{British},\comment{nationality}
   \field{user2} = \marg{1970-12-31},\comment{date of birth}
   \field{user3} = \marg{female},\comment{gender}
   \field{user4} = \marg{43 The Lane, Some Town, Noshire AB1 2XY},\comment{address}
   \field{user5} = \marg{polly.parrot@example.com}\comment{email}
}
\end{codeenv}

Alternatively you can define your own custom keys. If you don't need
commands equivalent to \gls{glssymbol}, then you can use:
\nosecformatdef{glsaddstoragekey}
where \meta{key} is the name of the new key, \meta{default value} is
the default value if the key isn't explicitly set and \meta{no link
cs} is the name of the command to access the field value (equivalent
to \gls{glsentrysymbol}). If you want commands equivalent to
\gls{glssymbol} that have the \meta{options} and \meta{insert}
optional arguments and obey the \idx{postlinkhook}, then use
\nosecformatdef{glsaddkey}
The first three arguments are as for \gls{glsaddstoragekey}.
The next argument \meta{no link ucfirst cs} is like \meta{no link
cs} but converts the first letter to \idx{uppercase} (analogous to
\gls{Glsentryname}). The final three commands behave like
\gls{glssymbol}, but \meta{link ucfirst cs} converts the first
letter to \idx{uppercase} and \meta{link allcaps cs} converts the entire
value to \idx{uppercase}.

The new keys must be defined before the entries are defined (and
the key definitions must come before the first \idx{resourceset}
if you use \bibgls). For example:
\begin{codeenv}
\gls{glsaddstoragekey}\marg{\fieldfmt{nationality}}\marg{}\marg{\cmd{Nationality}}
\gls{glsaddstoragekey}\marg{\fieldfmt{dateofbirth}}\marg{}\marg{\cmd{DateOfBirth}}
\gls{glsaddstoragekey}\marg{\fieldfmt{gender}}\marg{}\marg{\cmd{Gender}}
\gls{glsaddstoragekey}\marg{\fieldfmt{address}}\marg{}\marg{\cmd{Address}}
\gls{glsaddstoragekey}\marg{\fieldfmt{email}}\marg{}\marg{\cmd{Email}}
\gls{newglossaryentry}\marg{polly.parrot}\comment{label}
\marg{\comment{}
   \field{name} = \marg{Polly Parrot},
   \field{description} = \marg{Senior assistant at the International Society 
of Duck and Geese},
   \fieldfmt{nationality} = \marg{British},\comment{nationality}
   \fieldfmt{dateofbirth} = \marg{1970-12-31},\comment{date of birth}
   \fieldfmt{gender}  = \marg{female},\comment{gender}
   \fieldfmt{address} = \marg{43 The Lane, Some Town, Noshire AB1 2XY},\comment{address}
   \fieldfmt{email}   = \marg{polly.parrot@example.com}\comment{email}
}
\end{codeenv}

In addition to the commands like \gls{glssymbol} and
\gls{glsentrysymbol}, there are other ways of accessing the field
value or checking if the field has been set. In the commands listed
below, the field label is the \emph{internal} label. In some cases,
this is the same as the key, but there are a few that have a
different internal label. See Table~\ref*{tab:internalfields} in the
\bibgls\ user manual or Table~4.1 in the \sty{glossaries} user
manual. Custom fields provided with \gls{glsaddkey} or \gls{glsaddstoragekey}
have matching key and internal field labels.

The \sty{glossaries-extra} package provides a generic way of
accessing a field, analogous to commands like \gls{glsentryname}:
\nosecformatdef{glsxtrusefield}
This expands to the field value if defined or does nothing if the
entry or field isn't defined.

The base \sty{glossaries} package provides:
\nosecformatdef{ifglshassymbol}
which tests if the \field{symbol} field has been assigned. There are similar 
commands for other common fields. For a more general purpose test, you 
can use:
\nosecformatdef{ifglshasfield}
which checks if the given entry (identified by \meta{entry label}, 
which must be defined) has the field identified by \meta{field label}
set to a non-empty value. Within \meta{true}, you can access the
field value with:
\nosecformatdef{glscurrentfieldvalue}
The \sty{glossaries-extra} package provides a similar command:
\nosecformatdef{glsxtrifhasfield}
which doesn't test if the entry exists. The unstarred form adds
implicit grouping around \meta{true} or \meta{false} (allowing
nested use). The starred form \gls{glsxtrifhasfield*} doesn't. 
You can compare the field value with a string using:
\nosecformatdef{GlsXtrIfFieldEqStr}
If you need the string to be (protected) fully expanded before
comparison, you need:
\nosecformatdef{GlsXtrIfFieldEqXpStr}
If you additionally need the field value (protected) fully expanded
before comparison, use:
\nosecformatdef{GlsXtrIfXpFieldEqXpStr}
For a complete list of field commands, see the
\sty{glossaries-extra} user manual.

The earlier \code{duck} and \code{goose} examples from 
\sectionref{sec:firstuse} can be rewritten to move the parenthetical
material into separate keys:
\begin{codeenv}
\gls{newglossaryentry}\marg{duck}\comment{label}
\marg{\comment{information about this term:}
  \field{name}   = \marg{duck},
  \field{user1}  = \marg{noun},
  \field{user2}  = \marg{quack, quack},
  description = {a waterbird with webbed feet}
}
\strut
\gls{newglossaryentry}\marg{goose}\comment{label}
\marg{\comment{information about this term:}
  \field{name}   = \marg{goose},
  \field{plural} = \marg{geese},
  \field{user1}  = \marg{noun},
  \field{user2}  = \marg{honk, honk},
  \field{description}=\marg{a large waterbird with a long neck, short legs,
   webbed feet and a short broad bill}
}
\end{codeenv}
The \idx{postlinkhook} and glossary style can then be modified to 
include the additional information.  For example:
\begin{codeenv}
\gls[noindex=false]{glsdefpostlink}\marg{general}\marg{\comment{}
 \gls[noindex=false]{glsxtrifwasfirstuse}\marg{\cmd{space}(\gls{glsentryuserii}\marg{\gls{glslabel}})}{}\comment{}
}
\strut
\gls[noindex=false]{glssetcategoryattribute}\marg{general}\marg{glossname}\marg{firstuc}
\strut
\gls[noindex=false]{glsdefpostname}\marg{general}\marg{\comment{}
 \cmd{space}
 (\gls{glsentryuseri}\marg{\gls[noindex=false]{glscurrententrylabel}}\comment{}
  \gls{GlsXtrIfXpFieldEqXpStr}\marg{plural}\marg{\gls{glscurrententrylabel}}\comment{}
  \marg{\gls[noindex=false]{glsentrytext}\marg{\gls{glscurrententrylabel}}s}\marg{}\comment{}
  \marg{, pl.\gls{cs.space}\gls[noindex=false]{glsentryplural}{\gls{glscurrententrylabel}}}\comment{}
 )\comment{}
}
\end{codeenv}
The \idx{postlinkhook} appends the value of the \field{user2} field
after the \idx{firstuse} of \gls{gls} (or its \idxpl{variant}).
The \catattr{glossname} attribute converts the first letter of the
\field{name} field to \idx{uppercase} when it's displayed in the
glossary.  The \idx{postnamehook} appends (in parentheses) the value
of the \field{user1} field and then checks if the plural form is the
same as the singular form with \qt{s} appended, and only displays
the plural if they are different. See \sectionref{sec:glsformats}
and \sectionref{sec:displaygloss} for further details.

\section{Accessibility Support}
\label{sec:accsupp}

The base \sty{glossaries} package is distributed with the
supplementary \sty{glossaries-accsupp} package, which uses the
\sty{accsupp} package~\cite{accsupp} to provide accessibility support. With the
\sty{glossaries-extra} extension package, the
\sty{glossaries-accsupp} package needs to be loaded after \sty{glossaries}
but before \sty{glossaries-extra} sets up the accessibility
integration support. The simplest way to do this is with
\sty{glossaries-extra}'s \styopt{accsupp} package option.

The accessibility support is provided through the PDF
\code{ActualText} specification (via the \sty{accsupp} package). 
If you need \code{E} or \code{Alt} instead of \code{ActualText} then redefine:
\nosecformatdef{glsaccsupp}
as appropriate. For example:
\begin{codeenv}
\cmd{renewcommand}*\marg{\gls{glsaccsupp}}[2]\marg{\comment{}
  \cmd{BeginAccSupp}\marg{Alt=\marg{\gls{param}1}}\gls{param}2\cmd{EndAccSupp}\marg{}\comment{}
}
\end{codeenv}

The \sty{glossaries-accsupp} package provides additional keys (see
Table~\ref{tab:accsuppfields} in the \bibgls\ user manual or
Chapter~18 of the \sty{glossaries} user manual~\cite{glossaries}).
The main keys are \field{access}, which provides an alternative to
the \field{name} field, \field{symbolaccess}, which provides an
alternative to the \field{symbol} field and \field{shortaccess},
which provides an alternative to the \field{short} field,
\field{firstaccess}, which provides an alternative to the
\field{first} field, and \field{textaccess}, which provides an
alternative to the \field{text} field. If any of the accessibility
fields are unset, no accessibility support is provided for that
field.
For example:
\begin{codeenv}
\gls{newglossaryentry}\marg{R}\comment{label}
\marg{\comment{settings:}
 \field{name}        = \marg{\cmd{ensuremath}\marg{\cmd{Re}}},
 \field{access}      = \marg{set of real numbers symbol},\comment{name access}
 \field{textaccess}  = \marg{set of real numbers},\comment{text access}
 \field{firstaccess} = \marg{set of real numbers},\comment{first access}
 \field{description} = \marg{set of real numbers}
}
\end{codeenv}
This means that when the \field{name} field is displayed in the
glossary, the corresponding accessibility text is \qt{set of real
numbers symbol}, but the \idx{link-text} for \gls{gls} is just
\qt{set of real numbers} (for both \idx{firstuse} and subsequent
use).

There are some category attributes that govern the default settings
of some fields when using \gls{newabbreviation} (see
\sectionref{sec:abbreviations}). If accessibility support is
provided, there are some additional attributes (introduced to
\sty{glossaries-extra} version 1.31):
\begin{description}
\item[\catattr{accessinsertdots}] This is a boolean attribute that behaves like
\catattr{insertdots} but only applies to the \field{shortaccess}
field, if it hasn't explicitly been set. This is useful for
initialisms that should be read out as letters but the screen reader
might interpret as a word. For example:
\begin{codeenv}
\gls{glssetcategoryattribute}\marg{initialism}\marg{\catattr{accessinsertdots}}\marg{true}
\gls{newabbreviation}\oarg{\field{category}=initialism}\marg{pi}\marg{PI}\marg{Private Investigator}
\end{codeenv}
This means that the short form appears as just \qt{PI} in the
document text, but the accessibility text is \qt{P.I.} which prompts
the screen reader to read it as an abbreviation instead of the word
\qt{pi}. Since the \field{shortaccess} field is an aid to the screen
reader and doesn't modify the visible text, there's no check
for the \catattr{retainfirstuseperiod} or \catattr{discardperiod}
attributes for that field. This setting doesn't affect the
accessibility support for the \field{name}, \field{first} or
\field{text} fields.

\item[\catattr{nameshortaccess}] This is a boolean attribute, where
the value \code{true} indicates the attribute is set. If the
\field{shortaccess} field is assigned (either explicitly with the key or
implicitly through the use of the \catattr{accessinsertdots}
attribute) and the \field{access} field isn't specified, then if the
\catattr{nameshortaccess} attribute is set this will copy the
\field{shortaccess} field to the \field{access} field. For example:
\begin{codeenv}
\gls{glssetcategoryattribute}\marg{initialism}\marg{\catattr{accessinsertdots}}\marg{true}
\gls{glssetcategoryattribute}\marg{initialism}\marg{\catattr{nameshortaccess}}\marg{true}
\gls{newabbreviation}\oarg{\field{category}=initialism}\marg{pi}\marg{PI}\marg{Private Investigator}
\end{codeenv}
Abbreviations that behave like regular terms (such as
\abbrstyle{short-nolong}) may also need \catattr{textshortaccess}
and \catattr{firstshortaccess} set.

\item[\catattr{textshortaccess}] Like \catattr{nameshortaccess}, but
applies to the \field{textaccess} field.

\item[\catattr{firstshortaccess}] Like \catattr{firstshortaccess}, but
applies to the \field{firstaccess} field.

\item[\catattr{accessaposplural}] If the \field{shortaccess} field
is set (either explicitly with the key or implicitly through the use
of the \catattr{accessinsertdots} attribute) and the
\field{shortpluralaccess} field isn't set, the
\catattr{accessaposplural} boolean attribute behaves like
\catattr{aposplural} but only applies to the
\field{shortpluralaccess} field. If the \catattr{accessaposplural}
attribute isn't set but the \catattr{aposplural} attribute is set,
then that's used instead. If you want \catattr{aposplural} on but
not apply it to \field{shortpluralaccess} then you need to set the
\catattr{accessaposplural} attribute to \code{false}.

\item[\catattr{accessnoshortplural}] A boolean attribute like
\catattr{accessaposplural} but analogous to \catattr{noshortplural}
instead.
\end{description}
These attributes have no effect for entries that aren't defined
using \gls{newabbreviation}. (These attributes apply to
\gls{newacronym} provided it internally uses \gls{newabbreviation},
which is does by default with \sty{glossaries-extra}.)

\section{Spaces}
\label{sec:spaces}

With \LaTeX\ in general, spaces are sometimes significant and
sometimes ignored. When defining entries, any spaces around the
equal sign or comma are ignored. For example, if an entry is defined
as
\begin{codeenv}
\gls{newglossaryentry}\marg{sample}
\marg{
  \field{name} = \marg{sample} , \field{description} = \marg{an example}
}
\end{codeenv}
then
\begin{codeenv}
/\gls{gls}\marg{sample}/
\end{codeenv}
will produce
\begin{result}
/sample/
\end{result}
(no spaces). Similarly with:
\begin{codeenv}
\gls{newglossaryentry}\marg{sample}
\marg{
  \field{name} = sample , \field{description} = \marg{an example}
}
\end{codeenv}
However, spaces at the start or end of the value if it's been
enclosed in braces aren't ignored. For example, if the entry is now
defined as:
\begin{codeenv}
\gls{newglossaryentry}\marg{sample}
\marg{
  \field{name} = \marg{ sample } , \field{description} = {an example}\incorrect
}
\end{codeenv}
then:
\begin{codeenv}
/\gls{gls}\marg{sample}/
\end{codeenv}
produces:
\begin{result}
/ sample /
\end{result}
The spaces in this case have been retained. The unstarred version of
\gls{longnewglossaryentry} appends extra code to the end of the
description, which removes any trailing spaces (and also the 
\gls{postdescriptionhook}). The starred version
\gls{longnewglossaryentry*} (only available with \sty{glossaries-extra}) 
doesn't. In both cases any leading spaces are retained. For example,
if the entry is defined as:
\begin{codeenv}
\gls{longnewglossaryentry}\marg{sample}\marg{name=\marg{sample}}\marg{ an example }\incorrect
\end{codeenv}
then:
\begin{codeenv}
/\gls{glsentrydesc}\marg{sample}/
\end{codeenv}
produces:
\begin{result}
/ an example/
\end{result}
(trailing space removed), whereas if the entry is defined as:
\begin{codeenv}
\gls{longnewglossaryentry*}\marg{sample}\marg{name=\marg{sample}}\marg{ an example }\incorrect
\end{codeenv}
then:
\begin{codeenv}
/\gls{glsentrydesc}\marg{sample}/
\end{codeenv}
produces:
\begin{result}
/ an example /
\end{result}
(leading and trailing spaces retained).

Spaces in labels are significant. For example, in \verb|\gls{ duck }|
the spaces are considered part of the label. If the entry was
actually defined without spaces in the label then the entry
referenced in \verb|\gls{ duck }| won't be found.

\section{Undefined References}
\label{sec:undefaction}

If an entry that hasn't been defined is referenced with \gls{gls},
by default an error is triggered. For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries}
\strut
\cmd{begin}\marg{document}
A \gls{gls}\marg{duck}.
\cmd{end}\marg{document}
\end{codeenv}
This produces the error:
\begin{verbatim}
Glossary entry `duck' has not been defined.
\end{verbatim}
If you instruct \LaTeX\ to ignore the error and continue, the result
is
\begin{result}
A .
\end{result}
The \sty{glossaries-extra} package provides the option
\styopt[warn]{undefaction}, which will convert the error to a
warning. For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}[\styopt{undefaction}=warn]\marg{glossaries-extra}
\strut
\cmd{begin}\marg{document}
A \gls{gls}\marg{duck}.
\cmd{end}\marg{document}
\end{codeenv}
This now produces the warning:
\begin{verbatim}
Glossary entry `duck' has not been defined on input line 6
\end{verbatim}
(There are also other warnings about an empty \code{main} glossary.)
The result is now:
\begin{result}
A ??.
\end{result}
This replaces the undefined reference with two question marks, just like 
undefined cross-references.
Notice the difference between using \gls{ifglshasfield}:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}[\styopt{undefaction}=warn]\marg{glossaries-extra}
\strut
\cmd{begin}\marg{document}
A \gls{gls}\marg{duck} 
(\gls{ifglshasfield}\marg{\gls[noindex=false]{field.useri}}\marg{duck}\marg{\gls{glscurrentfieldvalue}}\marg{not set}).
\cmd{end}\marg{document}
\end{codeenv}
which produces:
\begin{result}
A ?? (??).
\end{result}
(and has two undefined warnings) and using \gls{glsxtrifhasfield}:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}[\styopt{undefaction}=warn]\marg{glossaries-extra}
\strut
\cmd{begin}\marg{document}
A \gls{gls}\marg{duck}
(\gls{glsxtrifhasfield}\marg{\field{useri}}\marg{duck}\marg{\gls{glscurrentfieldvalue}}\marg{not set}).
\cmd{end}\marg{document}
\end{codeenv}
which only has one undefined warning and produces:
\begin{result}
A ?? (not set).
\end{result}

When you incorporate \bibgls\ into the build process (see
\sectionref{sec:bib2gls}), the first \LaTeX\ run doesn't have any 
entries defined. One of the actions that the \styopt{record} option 
automatically performs is to switch on \styopt[warn]{undefaction}, which avoids
undefined errors on the first \LaTeX\ run. For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}[\styopt{record}]\marg{glossaries-extra}
\strut
\cmd{begin}\marg{document}
A \gls{gls}\marg{duck}
(\gls{glsxtrifhasfield}\marg{\field{useri}}\marg{duck}\marg{\gls{glscurrentfieldvalue}}\marg{not set}).
\cmd{end}\marg{document}
\end{codeenv}
This produces the same result as the previous example, but there's
only the one warning (about an undefined reference) and no warning
about the empty \code{main} glossary.

\section{Robust, Fragile and Expandable Commands}
\label{sec:robust}

Commands like \gls{gls} are \pidx{robust}. This protects them from
premature expansion in situations that would otherwise break the
command. If content containing a \idx{robust} command is written to
an external file, the \idx{robust} command itself is written instead of its
definition. For example, consider the following document:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\cmd{newcommand}\marg{\csfmt{test}}\marg{some sample text}
\cmd{begin}\marg{document}
\cmd{tableofcontents}
\gls[noindex=false]{section}\marg{\csfmt{test}}
\cmd{end}\marg{document}
\end{codeenv}
In this case, \csfmt{test} is expandable. Its definition doesn't
contain anything complicated. The \ext{toc} file (which is input by
\csfmt{tableofcontents}) contains the line:
\begin{codeenv}
\cmd{contentsline} \marg{section}\marg{\cmd{numberline} \marg{1}some sample text}\marg{1}
\end{codeenv}
So \csfmt{test} has been expanded to its definition when it was
written to the \ext{toc} file. If \csfmt{test} is defined in terms
of another command, that will also be expanded. For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\cmd{newcommand}\marg{\csfmt{sample}}\marg{\gls{emph}\marg{sample}}
\cmd{newcommand}\marg{\csfmt{test}}\marg{some \csfmt{sample}\gls{cs.space}text}
\cmd{begin}\marg{document}
\cmd{tableofcontents}
\gls{section}\marg{\csfmt{test}}
\cmd{end}\marg{document}
\end{codeenv}
The \ext{toc} file now contains:
\begin{codeenv}
\cmd{contentsline} \marg{section}\marg{\cmd{numberline} \marg{1}some \gls{emph} \marg{sample}\gls{cs.space}text}\marg{1}
\end{codeenv}
So \csfmt{sample} has also been expanded but neither
\gls{emph} nor \idx{cs.space} (backslash space) have
been expanded. \Idx{robust} commands don't expand. For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries}
\strut
\gls{newglossaryentry}\marg{duck}
\marg{
  \field{name}=\marg{duck},
  \field{description}=\marg{a waterbird with webbed feet}
}
\strut
\cmd{begin}\marg{document}
\cmd{tableofcontents}
\gls{section}\marg{\gls{Gls}\marg{duck}: \gls{glsentrydesc}\marg{duck}}
\cmd{end}\marg{document}
\end{codeenv}
The \ext{toc} file now contains:
\begin{codeenv}
\cmd{contentsline} \marg{section}\marg{\cmd{numberline} \marg{1}\gls{Gls} \marg{duck}: a waterbird with 
webbed feet}\marg{1}
\end{codeenv}
So \gls{Gls} doesn't expand, and the command itself is written to the
\ext{toc} file, but \gls{glsentrydesc} does expand.

A \pidx{fragile} command is one that breaks (causes an error) when
it's expanded in this type of context. One such command is \gls{footnote}.
For example, the following won't work:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries}
\strut
\gls{newglossaryentry}\marg{duck}
\marg{
  \field{name}=\marg{duck},
  \field{description}=\marg{a waterbird with webbed feet}
}
\strut
\cmd{begin}\marg{document}
\cmd{tableofcontents}
\gls{section}\marg{\gls{Gls}\marg{duck}\gls{footnote}\marg{\gls{glsentrydesc}\marg{duck}}}\incorrect
\cmd{end}\marg{document}
\end{codeenv}
This causes the error:
\begin{verbatim}
! Argument of \@sect has an extra }.
\end{verbatim}
Inserting \gls{protect} before the command prevents the attempted
expansion, which makes the command behave as though it was robust:
\begin{codeenv}
\gls{section}\marg{\gls{Gls}\marg{duck}\gls{protect}\gls{footnote}\marg{\gls{glsentrydesc}\marg{duck}}}
\end{codeenv}
In this case, it's unlikely that you'd want the footnote to appear
in the table of contents, so it would be better to use the optional
argument:
\begin{codeenv}
\gls{section}\oarg{Duck}\marg{\gls{Gls}\marg{duck}\gls{footnote}\marg{\gls{glsentrydesc}\marg{duck}}}\correct
\end{codeenv}
Now the \ext{toc} file is just:
\begin{codeenv}
\cmd{contentsline} \marg{section}\marg{\cmd{numberline} \marg{1}Duck}\marg{1}
\end{codeenv}
If the \field{description} field contains a \idx{fragile} command
then \gls{glsentrydesc} will break in expandable contexts. For
example, the following doesn't work:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries}
\strut
\gls{newglossaryentry}\marg{duck}
\marg{
  \field{name}=\marg{duck},
  \field{description}=\marg{a waterbird\gls{footnote}\marg{a bird that lives on or 
   near water} with webbed feet}
}
\strut
\cmd{begin}\marg{document}
\cmd{tableofcontents}
\gls{section}\marg{\gls{Gls}\marg{duck}: \gls{glsentrydesc}\marg{duck}}\incorrect
\cmd{end}\marg{document}
\end{codeenv}
This is a contrived example. In this case, it would be better to
also define the term \qt{waterbird}: 
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries}
\strut
\gls{newglossaryentry}\marg{waterbird}
\marg{
  \field{name}=\marg{waterbird},
  \field{description}=\marg{a bird that lives on or near water}
}
\strut
\gls{newglossaryentry}\marg{duck}
\marg{
  \field{name}=\marg{duck},
  \field{description}=\marg{a \gls{gls}\marg{waterbird} with webbed feet}
}
\strut
\cmd{begin}\marg{document}
\cmd{tableofcontents}
\gls{section}\marg{\gls{Gls}\marg{duck}: \gls{glsentrydesc}\marg{duck}}
\cmd{end}\marg{document}
\end{codeenv}
The \ext{toc} file now contains:
\begin{codeenv}
\cmd{contentsline} \marg{section}\marg{\cmd{numberline} \marg{1}\gls{Gls} \marg{duck}: a \gls{gls} \marg{waterbird} 
with webbed feet}\marg{1}
\end{codeenv}

\begin{important}
The examples in this section are used to illustrate the differences
between \idx{robust}, \idx{fragile} and \idx{expandable} commands.
In general, it's better not to use commands like \gls{gls} in
headings or captions (see \sectionref{sec:headings}) and using
commands like \gls{gls} in field values can be problematic (see
\sectionref{sec:nested}).
\end{important}

By default, most of the field values are expanded when the entry is
defined. This allows for defining entries programmatically, but it
can cause a problem if the value contains any \idx{fragile} commands.
For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries}
\strut
\gls{newglossaryentry}\marg{duck}\comment{label}
\marg{
  \field{name} = \marg{duck},
  \field{first} = \marg{duck\gls{footnote}\marg{quack, quack}},\incorrect
  \field{description} = \marg{a waterbird with webbed feet}
}
\strut
\cmd{begin}\marg{document}
A \gls{gls}\marg{duck}.
\cmd{end}\marg{document}
\end{codeenv}
This causes the confusing error:
\begin{verbatim}
! Undefined control sequence.
\in@ #1#2->\begingroup \def \in@@ 
\end{verbatim}
In order for this example to work, the \idx{fragile} command must either be
protected:
\begin{codeenv}
\gls{newglossaryentry}\marg{duck}\comment{label}
\marg{
  \field{name} = \marg{duck},
  \field{first} = \marg{duck\gls{protect}\gls{footnote}\marg{quack, quack}},\correct
  \field{description} = \marg{a waterbird with webbed feet}
}
\end{codeenv}
or the expansion must first be switched off:
\begin{codeenv}
\gls{glsnoexpandfields} \correct
\gls{newglossaryentry}\marg{duck}\comment{label}
\marg{
  \field{name} = \marg{duck},
  \field{first} = \marg{duck\gls{footnote}\marg{quack, quack}},
  \field{description} = \marg{a waterbird with webbed feet}
}
\end{codeenv}
Since it's not possible to programmatically define entries with
\bibgls, the expansion is automatically switched off as \bibgls\
writes \gls{glsnoexpandfields} to the \ext{glstex} file (although
you can switch this feature off with \longarg{expand-fields}).

The reason why \gls{footnote} didn't cause a problem in the
\field{description} field \emph{when the entry was defined} is that, by
default, expansion isn't performed on the \field{name},
\field{description} and \field{symbol} fields, regardless of whether
or not \gls{glsnoexpandfields} has been used. This only applies to
the point when the entries are being defined. Unprotected
\idx{fragile} commands can still cause a problem if the value is
later used in a problematic context (such as the earlier example
where \gls{glsentrydesc} was used in a section heading).

\chapter{Abbreviations}
\label{sec:abbreviations}

The abbreviation handling provided by the base \isty{glossaries}
package is quite restrictive and only one abbreviation style can be
used for all abbreviations. The \isty{glossaries-extra} package
internally loads the \sty{glossaries} package and extends it,
providing new options and a better abbreviation mechanism that
allows different styles per category.

The base \sty{glossaries} package provides:
\nosecformatdef{newacronym}
The extension package \sty{glossaries-extra} provides:
\nosecformatdef{newabbreviation}
which internally uses \gls{newglossaryentry} with the
\field{category} set to \code{abbreviation} (which can be
overridden in the optional \meta{\keyvallist}).
The \gls{glossaries-extra} package also redefines \gls{newacronym} in 
terms of \gls{newabbreviation} so that it effectively behaves like:
\begin{codeenv}
\gls{newabbreviation}\oarg{\gls[noindex=false]{field.type}=\gls{acronymtype},\field{category}=acronym,\meta{\keyvallist}}
\margm{label}\margm{short}\margm{long}
\end{codeenv}
This makes it easier to transfer over from the base \sty{glossaries}
package, but if you use \gls{newacronym} remember that the
\field{category} is set to \code{acronym} instead of \code{abbreviation}.

In both cases, \meta{label} is the entry's label used to identify
the abbreviation in commands like \gls{gls}, \meta{short} is the
short form and \meta{long} is the long form. Any additional
settings, such as the \field{category} or \field{description} 
can be set in the optional argument.

The style must be set \emph{before the abbreviations are defined}
using:
\nosecformatdef{setabbreviationstyle}
where \meta{category} is the category label and \meta{style-name} is
the name of the style. If the optional argument is omitted,
\code{abbreviation} is assumed. The \sty{glossaries-extra} package
automatically sets the default styles:
\begin{codeenv}
\gls{setabbreviationstyle}\marg{\abbrstyle{long-short}}
\gls{setabbreviationstyle}\oarg{acronym}\marg{\abbrstyle{short-nolong}}
\end{codeenv}
This means that if you don't explicitly set the style then any
abbreviation defined with \gls{newacronym} will use the
\abbrstyle{short-nolong} style (unless you change the category in
the optional argument) and other abbreviations will use the
\abbrstyle{long-short} style.

If these styles aren't suitable, then you need to change them. Any
abbreviation that's defined with a category that hasn't been
assigned a style will fallback on the style for the default
\code{abbreviation} category. There are many predefined styles to
choose from and they come with commands to help adjust the
formatting. See the \sty{glossaries-extra} user
manual~\cite{glossaries-extra} for the
complete list. The \sty{glossaries-extra} package also comes with a
sample document
\ctanfile{glossaries-extra/samples}{sample-abbr-styles.pdf}
demonstrating all the predefined styles.

The style determines whether the abbreviation is treated as a
\idx{regular} term.  There are also some \idxpl{categoryattribute} that govern
abbreviations (see below and \sectionref{sec:accsupp}).  These
should also be set before the abbreviation is defined.

Some of the styles set the \field{description} field (typically to
the \meta{long} form). The styles that end with \code{-desc} don't,
and so that key must be set explicitly in the \meta{\keyvallist} optional part.

Here's a simple example that uses both \gls{newabbreviation} and
\gls{newacronym} to illustrate the difference:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{newabbreviation}\marg{tug}\marg{TUG}\marg{\cmd{TeX}\gls{cs.space}Users Group}
\gls{newabbreviation}\marg{cldr}\marg{CLDR}\marg{Unicode Common Locale Data 
Repository}
\strut
\gls{newacronym}\marg{SIunit}\marg{SI unit}\marg{International System of Units}
\gls{newacronym}\marg{ascii}\marg{ASCII}\marg{American Standard Code for 
Information Interchange}
\strut
\cmd{begin}\marg{document}
First use: \gls{gls}\marg{tug}, \gls{gls}\marg{cldr}, \gls{gls}\marg{SIunit}, \gls{gls}\marg{ascii}.
Next use: \gls{gls}\marg{tug}, \gls{gls}\marg{cldr}, \gls{gls}\marg{SIunit}, \gls{gls}\marg{ascii}.
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
First use: \gls{TUG}, \gls{CLDR}, \gls{SIunit}, \gls{ASCII}.
Next use: \gls{TUG}, \gls{CLDR}, \gls{SIunit}, \gls{ASCII}.
\end{result}
Note that the \idx{firstuse} of \code{SIunit} and \code{ascii} only
show the short form. This is because the default style for the
\code{acronym} category is the \abbrstyle{short-nolong} style, which
doesn't show the long form with \gls{gls} (and its \idxpl{variant}).

If you only want \gls{gls} to show the short form but not the long
form, use one of the \code{-nolong} styles (such as
\abbrstyle{short-nolong}). If you only want the
long form and not the short form, use one of the \code{-noshort}
styles (such as \abbrstyle{long-noshort}). If you want only the long
form on \idx{firstuse} and only the short form subsequently
then use one of the \code{-only} styles, such as
\abbrstyle{long-only-short-only}.

If you want a specific instance to show only the short form, without
modifying the \idx{firstuseflag}, then use
\nosecformatdef{glsxtrshort}
If you want a specific instance to show only the long form, without
modifying the \idx{firstuseflag}, then use
\nosecformatdef{glsxtrlong}
If you want a specific instance to show both the long and short form, without
modifying the \idx{firstuseflag}, then use
\nosecformatdef{glsxtrfull}
Depending on the style, this may not exactly match the format
produced by the \idx{firstuse} of \code{\gls{gls}\margm{label}}.

If you find these commands quite long-winded, there are some
shortcuts available with the \styopt{shortcuts} option, but as these
may interfere with other packages, you might want to consider
investigating your text editor settings as the more sophisticated
ones provide ways of inserting commonly-used commands to save typing.

The final optional \meta{insert} argument of commands like \gls{gls}
is typically moved inside, depending on the style. For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{newabbreviation}\marg{svm}\marg{SVM}\marg{support vector machine}
\strut
\cmd{begin}\marg{document}
The \gls{gls}\marg{svm}\oarg{'s} parameters are\cmd{ldots}
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
The \gls{ex.svm}['s] parameters are\ldots
\end{result}
Compare this with:
\begin{codeenv}
The \gls{gls}\marg{svm}'s parameters are\cmd{ldots}\incorrect
\end{codeenv}
which produces:
\begin{result}
The \gls{ex.svm}'s parameters are\ldots
\end{result}

\section{Plural Abbreviations}
If the abbreviation represents something countable then the plural
form can again be obtained with \gls{glspl}:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{newabbreviation}\marg{svm}\marg{SVM}\marg{support vector machine}
\strut
\cmd{begin}\marg{document}
First use: \gls{glspl}\marg{svm}. Next use: \gls{glspl}\marg{svm}.
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
First use: \glspl{ex.svm}. Next use: \glspl{ex.svm}.
\end{result}
The default plural short and long forms are obtained by
appending the letter \qt{s} after the singular form. These can be
changed on an individual basis with the \field{shortplural} and
\field{longplural} keys. For example:
\begin{codeenv}
\gls{newabbreviation}
 [\field{longplural}=\marg{lower triangular matrices}]
 \marg{ltm}\marg{LTM}\marg{lower triangular matrix}
\end{codeenv}

It may be that you prefer to keep the short plural form the same as
the short singular value for all abbreviations within a particular
category. You can implement this with the
\catattr{noshortplural} attribute, which must be set to \code{true}
before the abbreviations for that category are defined. For example:
\begin{codeenv}
\gls{glssetcategoryattribute}\marg{abbreviation}\marg{\catattr{noshortplural}}\marg{true}
\gls{newabbreviation}\marg{svm}\marg{SVM}\marg{support vector machine}
\end{codeenv}
Now:
\begin{codeenv}
First use: \gls{glspl}\marg{svm}. Next use: \gls{glspl}\marg{svm}.
\end{codeenv}
produces:
\begin{result}
First use: support vector machines (SVM). Next use: SVM.
\end{result}
A related attribute is \catattr{aposplural} which inserts \qtt{'s}
(apostrophe followed by \qt{s}) to form the default short plural to
help avoid ambiguity with \idx{lowercase} abbreviations where it might
not be obvious that the \qt{s} indicates a plural (rather than
another letter in the abbreviation). Again, this needs to be set
before the abbreviations for the given category (or categories) are
defined (but check with your supervisor, publisher or editor as this 
usage is controversial).

\section{Abbreviation Markup}

The \catattr{markwords} attribute can be set to \code{true} to
indicate that \gls{newabbreviation} should parse the long form and
markup the words using:
\nosecformatdef{glsxtrword}
The words are separated with
\nosecformatdef{glsxtrwordsep}
For example:
\begin{codeenv}
\gls{glssetcategoryattribute}\marg{abbreviation}\marg{\catattr{markwords}}\marg{true}
\gls{newabbreviation}\marg{ssl}\marg{SSL}\marg{Secure Sockets Layer}
\end{codeenv}
This is essentially the same as
\begin{codeenv}
\gls{newabbreviation}\marg{ssl}\marg{SSL}\marg{\gls{glsxtrword}\marg{Secure}\gls{glsxtrwordsep}
\gls{glsxtrword}\marg{Sockets}\gls{glsxtrwordsep}\gls{glsxtrword}\marg{Layer}}
\end{codeenv}
This is typically used with the \code{-hyphen} abbreviation styles.
If the final optional \meta{insert} argument of commands like
\gls{gls} starts with a hyphen, \gls{glsxtrwordsep} is locally
changed to a hyphen.

For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{setabbreviationstyle}\marg{\gls[noindex=false]{long-hyphen-short-hyphen}}
\strut
\gls{glssetcategoryattribute}\marg{abbreviation}\marg{\catattr{markwords}}\marg{true}
\strut
\gls{newabbreviation}\marg{ssl}\marg{SSL}\marg{Secure Sockets Layer}
\strut
\cmd{begin}\marg{document}
First use: \gls{gls}\marg{ssl}\oarg{-enabled}. Next use: \gls{gls}\marg{ssl}\oarg{-enabled}.
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
First use: \gls{ex.ssl}[-enabled]. Next use: \gls{ex.ssl}[-enabled].
\end{result}
Compare this with:
\begin{codeenv}
First use: \gls{gls}\marg{ssl}-enabled. Next use: \gls{gls}\marg{ssl}-enabled.\incorrect
\end{codeenv}
which instead produces:
\begin{result}
First use: \gls{ex.ssl}-enabled. Next use: \gls{ex.ssl}-enabled.
\end{result}
Whereas:
\begin{codeenv}
First use: \gls{gls}\marg{ssl}\oarg{ enabled}. Next use: \gls{gls}\marg{ssl}\oarg{ enabled}.
\end{codeenv}
produces:
\begin{result}
First use: \gls{ex.ssl}[ enabled]. Next use: \gls{ex.ssl}[ enabled].
\end{result}
Note that this is different to the result obtained with the
\abbrstyle{long-short} style which doesn't include the inserted
material in the parentheses (and doesn't check if the inserted
text starts with a hyphen).

There's a related attribute \catattr{markshortwords} which applies
to the short form instead. This is only useful if the short form contains
spaces.

Another markup-related attribute is \catattr{tagging}. In general,
you don't need to explicitly set this attribute. Instead, you need
to define a tagging command using:
\nosecformatdef{GlsXtrEnableInitialTagging}
This (robustly) defines \meta{cs} (a control sequence) to accept a
single argument, which you need to use in the \meta{long} part of the 
abbreviation definition (it's not inserted automatically).

The \gls{GlsXtrEnableInitialTagging} command also sets the
\catattr{tagging} attribute to \code{true} for each of the listed
categories, which ensures that \meta{cs} uses
\nosecformatdef{glsxtrtagfont}
within the glossary (see \sectionref{sec:displaygloss}). Within the
main text the command simply does its argument.
For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{GlsXtrEnableInitialTagging}\marg{abbreviation}\marg{\cmd{itag}}
\strut
\gls{newabbreviation}\marg{xml}\marg{XML}\marg{e\cmd{itag}\marg{x}tensible \cmd{itag}\marg{m}arkup
\cmd{itag}\marg{l}anguage}
\strut
\cmd{begin}\marg{document}
First use: \gls{gls}\marg{xml}. Next use: \gls{gls}\marg{xml}.
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
First use: \gls{ex.xml}. Next use: \gls{ex.xml}.
\end{result}
This doesn't show the markup as the tagging command (\csfmt{itag} in
this example) simply expands to its argument in the main document
text. The difference is only evident in the glossary.

If all your abbreviations are defined in a separate file, it's
useful to provide a definition of the tagging command with
\gls{providecommand} to ensure it's defined if you decide not to use
\gls{GlsXtrEnableInitialTagging}. With \bibgls, you can include it
in the \atentry{preamble}. For example:
\begin{codeenv}
\atentry{preamble}\marg{"\gls{providecommand}\marg{\cmd{itag}}\oarg{1}\marg{\gls{param}1}"}
\end{codeenv}

\section{Dotted Abbreviations}

If an abbreviation ends with a \idx{full-stop}, it can be awkward
when it appears at the end of a sentence, as you can end up with two
dots by mistake. For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{newabbreviation}\marg{dante}\marg{DANTE e.V.}
\marg{Deutschsprachige Anwendervereinigung \cmd{TeX}\gls{cs.space}e.V.}
\strut
\gls{newabbreviation}\marg{gp}\marg{G.P.}\marg{General Practitioner}
\strut
\cmd{begin}\marg{document}
\gls{gls}\marg{dante} is a local \cmd{TeX}\gls{cs.space}user group.
The German-speaking local \cmd{TeX}\gls{cs.space}user group is \gls{gls}\marg{dante}.
\strut
A \gls{gls}\marg{gp} is a medical doctor.
I went to my surgery to see the \gls{gls}\marg{gp}.
\cmd{end}\marg{document}
\end{codeenv}
This results in:
\begin{result}
\gls{ex.dante} is a local \TeX\ user group.
The German-speaking local \TeX\ user group is \gls{ex.dante}\relax.\incorrect

A \gls{ex.gp} is a medical doctor.
I went to my surgery to see the \gls{ex.gp}\relax.\incorrect
\end{result}
The awkward double-dot is caused by the final dot in the
short form followed by the sentence terminating \idx{full-stop}.

If the \catattr{discardperiod} attribute is set to \code{true}, the
\idx{postlinkhook} will look ahead for a \idx{full-stop}. If it
finds one, it will be discarded. For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{glssetcategoryattribute}\marg{abbreviationdot}\marg{\catattr{discardperiod}}\marg{true}
\strut
\gls{newabbreviation}\oarg{\field{category}=abbreviationdot}
 \marg{dante}\marg{DANTE e.V.}\marg{Deutschsprachige Anwendervereinigung \cmd{TeX}\gls{cs.space}e.V.}
\strut
\gls{newabbreviation}\oarg{\field{category}=abbreviationdot}
 \marg{gp}\marg{G.P.}\marg{General Practitioner}
\strut
\cmd{begin}\marg{document}
\gls{gls}\marg{dante} is a local \cmd{TeX}\gls{cs.space}user group.
The German-speaking local \cmd{TeX}\gls{cs.space}user group is \gls{gls}\marg{dante}.
\strut
A \gls{gls}\marg{gp} is a medical doctor.
I went to my surgery to see the \gls{gls}\marg{gp}.
\cmd{end}\marg{document}
\end{codeenv}
This now results in:
\begin{result}
\gls{ex.dante} is a local \TeX\ user group.
The German-speaking local \TeX\ user group is \gls{ex.dante}.

A \gls{ex.gp} is a medical doctor.
I went to my surgery to see the \gls{ex.gp}.
\end{result}
This attribute only affects the \emph{non-plural} commands, such as
\gls{gls} and \gls{glsxtrshort}. If the last paragraph in the above 
example is changed to:
\begin{codeenv}
A \gls{gls}\marg{gp} is a medical doctor.
I went to my surgery to see the \gls{glspl}\marg{gp}.
\end{codeenv}
then the result is:
\begin{result}
A \gls{ex.gp} is a medical doctor.
I went to my surgery to see the \glspl{ex.gp}.
\end{result}
In this case there's no need to discard the terminating
\idx{full-stop} as the plural form doesn't end with one. If the
plural form also ends with a \idx{full-stop} (for example, if the
\catattr{noshortplural} attribute is also set) then you additionally
need to set the \catattr{pluraldiscardperiod} attribute.

The \idx{postlinkhook} is also applied to other commands, such as 
\gls{glsxtrfull}, \gls{glsxtrlong}, \gls{glsxtrshort} and \gls{glssymbol}.
For example:
\begin{codeenv}
I went to my surgery to see the \gls{glsxtrshort}\marg{gp}.
\end{codeenv}
results in:
\begin{result}
I went to my surgery to see the \glsxtrshort{ex.gp}.
\end{result}
In some cases, this may be inappropriate, for example:
\begin{codeenv}
I went to my surgery to see the \gls{glsxtrlong}\marg{gp}.
\end{codeenv}
results in:
\begin{result}
I went to my surgery to see the \glsxtrlong{ex.gp}.
\end{result}
In this case the terminating \idx{full-stop} shouldn't be discarded.
There are several ways to prevent it. For example, moving the
\idx{full-stop} into the \meta{insert} argument:
\begin{codeenv}
I went to my surgery to see the \gls{glsxtrlong}\marg{gp}\oarg{.}
\end{codeenv}
This results in:
\begin{result}
I went to my surgery to see the \glsxtrlong{ex.gp}[.]
\end{result}
Alternatively, insert \csfmt{relax} before the \idx{full-stop}:
\begin{codeenv}
I went to my surgery to see the \gls{glsxtrlong}\marg{gp}\cmd{relax}.
\end{codeenv}

Depending on the abbreviation style, it may be inappropriate for the
\idx{firstuse} to discard the \idx{full-stop}. In this case, it's a
bit of a nuisance to keep track of whether the term is being
referenced for the first time. Instead, set the
\catattr{retainfirstuseperiod} attribute to \code{true}.

If you have many abbreviations defined without dots and then you
later decide to insert them, you may prefer an automated approach.
This can be done by setting the \catattr{insertdots} attribute to \code{true}.
For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{glssetcategoryattribute}\marg{initialism}\marg{\catattr{insertdots}}\marg{true}
\gls{glssetcategoryattribute}\marg{initialism}\marg{\catattr{discardperiod}}\marg{true}
\gls{glssetcategoryattribute}\marg{initialism}\marg{\catattr{retainfirstuseperiod}}\marg{true}
\strut
\gls{setabbreviationstyle}\oarg{initialism}\marg{\gls[noindex=false]{short-long}}
\strut
\gls{newabbreviation}\oarg{\field{category}=initialism}
 \marg{gp}\marg{GP}\marg{General Practitioner}
\strut
\cmd{begin}\marg{document}
Today I went to my surgery to see the \gls{gls}\marg{gp}.
Tomorrow I'm going to my surgery to see the \gls{gls}\marg{gp}.
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
Today I went to my surgery to see the \gls{ex2.gp}.
Tomorrow I'm going to my surgery to see the \gls{ex2.gp}.
\end{result}

\section{Translations}
\label{sec:abbrvtrans}

If an abbreviation needs to be accompanied by a translation, then
you can use a custom field or one of the supplied user fields
described in \sectionref{sec:userkeys} to store the translation. The
\code{-user} abbreviation styles can be used to include the extra
information if the field is set. The \field{user1} field
is the default, but you can change this by redefining
\nosecformatdef{glsxtruserfield}
to the \emph{internal} field name. (For example, \field{userii} for
\field{user2}.) In the sample document below, the translation is
supplied in the default \field{user1} field:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{setabbreviationstyle}\marg{\abbrstyle{long-short-user}}
\strut
\gls{newabbreviation}\oarg{\field{user1}=\marg{ribonucleic acid}}
 \marg{rna}\marg{RNA}\marg{ribonukleins\gls[noindex=false]{umlaut}aure}
\strut
\cmd{begin}\marg{document}
First use: \gls{gls}\marg{rna}.  Next use: \gls{gls}\marg{rna}.
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
First use: \gls{ex.rna}.  Next use: \gls{ex.rna}.
\end{result}
If the field is empty, \abbrstyle{long-short-user} behaves like
\abbrstyle{long-short}.

\chapter{Symbols}
\label{sec:symbols}

\Sectionref{sec:userkeys} described the \field{symbol} key, which can
be used to additionally provide a symbol. For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{\gls[noindex=false]{siunitx}}\comment{provides \gls{si}}
\cmd{usepackage}\marg{glossaries}
\strut
\gls{newglossaryentry}\marg{length}\comment{label}
\marg{\comment{settings:}
   \field{name}   = \marg{length},
   \field{symbol} = \marg{\gls{si}\marg{\cmd{metre}}},
   \field{description} = \marg{measurement between two points}
}
\strut
\gls{newglossaryentry}\marg{area}\comment{label}
\marg{\comment{settings:}
   \field{name}   = \marg{area},
   \field{symbol} = \marg{\gls[noindex=false]{si}\marg{\cmd{metre}\cmd{squared}}},
   \field{description} = \marg{measurement of a surface}
}
\strut
\cmd{begin}\marg{document}
Measurements: \gls{gls}\marg{length} (\gls{glssymbol}\marg{length}) and
\gls{gls}\marg{area} (\gls{glssymbol}\marg{area}).
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
Measurements: \gls{ex.length} (\glssymbol{ex.length}) and
\gls{ex.area} (\glssymbol{ex.area}).
\end{result}

It may be that you prefer to have the symbol in the \field{name}
field instead. The example document below is a modification of the
above and uses the \idx{postlinkhook} to append the description on
\idx{firstuse} (see \sectionref{sec:postlinkhooks}).
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{siunitx}
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls[noindex=false]{glsnoexpandfields} \comment{name field contains \gls{si}}
\strut
\gls{glsdefpostlink}\marg{symbol}\marg{\gls{glsxtrpostlinkAddDescOnFirstUse}}
\strut
\gls{newglossaryentry}\marg{length}\comment{label}
\marg{\comment{settings:}
  \field{name} = \marg{\gls{si}\marg{\cmd{metre}}},
  \field{description} = \marg{length},
  \field{category} = \marg{symbol}
}
\strut
\gls{newglossaryentry}\marg{area}\comment{label}
\marg{\comment{settings:}
  \field{name} = \marg{\gls{si}\marg{\cmd{metre}\cmd{squared}}},
  \field{description} = \marg{area},
  \field{category} = \marg{symbol}
}
\strut
\cmd{begin}\marg{document}
First use: \gls{gls}\marg{length} and \gls{gls}\marg{area}.
Next use: \gls{gls}\marg{length} and \gls{gls}\marg{area}.
\cmd{end}\marg{document}
\end{codeenv}
Note the need for \gls{glsnoexpandfields} (described in
\sectionref{sec:robust}). This wasn't required in the previous
example because the \sty{siunitx} commands were in the
\field{symbol} field, which isn't expanded by default. The
\field{name} field also isn't expanded by default, but its value is
copied to the \field{text} and \field{first} fields, which are
expanded by default. If \gls{glsnoexpandfields} is omitted from the
above document, the following error would occur:
\begin{verbatim}
! Undefined control sequence.
\@glo@name ->\si {\metre 
                         }
\end{verbatim}
Although \gls{si} is robust, commands like \csfmt{metre} and
\csfmt{squared} are only available within the argument of \gls{si}
(and other similar commands provided by \sty{siunitx}) and so break
in expandable contexts.
With \gls{glsnoexpandfields}, the document compiles correctly and
produces:
\begin{result}
\glsdefpostlink{symbol}{\glsxtrpostlinkAddDescOnFirstUse}%
First use: \gls{ex2.length} and \gls{ex2.area}.
Next use: \gls{ex2.length} and \gls{ex2.area}.
\end{result}

The \sty{glossaries-extra}['s] \styopt{symbols} package option
provides the command
\nosecformatdef{glsxtrnewsymbol}
which is a shortcut for
\begin{codeenv}
\gls{newglossaryentry}\margm{label}\marg{\field{name}=\margm{symbol},\field{category}=\marg{symbol},\gls[noindex=false]{field.sort}=\margm{label},
\gls[noindex=false]{field.type}=\marg{symbols},\meta{\keyvallist}}
\end{codeenv}
So the above document can be changed to:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{siunitx}
\cmd{usepackage}[\styopt{symbols}]\marg{glossaries-extra}
\strut
\gls{glsnoexpandfields}
\strut
\gls{glsdefpostlink}\marg{symbol}\marg{\gls{glsxtrpostlinkAddDescOnFirstUse}}
\strut
\gls{glsxtrnewsymbol}\oarg{\field{description} = \marg{length}}\marg{length}\marg{\gls{si}\marg{\cmd{metre}}}
\strut
\gls{glsxtrnewsymbol}\oarg{\field{description} = \marg{area}}\marg{area}\marg{\gls{si}\marg{\cmd{metre}\cmd{squared}}}
\strut
\cmd{begin}{document}
First use: \gls{gls}\marg{length} and \gls{gls}\marg{area}.
Next use: \gls{gls}\marg{length} and \gls{gls}\marg{area}.
\cmd{end}\marg{document}
\end{codeenv}
The result is the same.

\section{Functions}
\label{sec:functions}

Some symbols may represent functions. For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}[\styopt{symbols}]\marg{glossaries-extra}
\strut
\gls{glsnoexpandfields}
\strut
\gls{glsxtrnewsymbol}
 \oarg{\field{description} = \marg{derivative}}
 \marg{deriv}\comment{label}
 \marg{\gls{ensuremath}\marg{f'(x)}}\comment{symbol}
\strut
\cmd{begin}\marg{document}
The derivative is denoted \gls{gls}\marg{deriv}.
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
The derivative is denoted \gls{ex.deriv}.
\end{result}
What if I need to change the variable for a specific instance, for
example, if I want $f'(x_i)$ instead of $f'(x)$? I can just use:
\begin{codeenv}
The gradient at \gls{mshiftchar}x\gls{sbchar}i\gls{mshiftchar} is \gls{mshiftchar}f'(x\gls{sbchar}i)\gls{mshiftchar}.
\end{codeenv}
So far, none of the example documents have a glossary or list of
terms. The ultimate aim when using the \styfmt{glossaries} package
is to ensure consistent formatting and notation, and, where
applicable, include a list of all terms referenced in the document.
The use of commands like \gls{gls} helps to achieve this. If the
notation needs to be changed, only the entry definition (and
associated formatting commands) should need to be redefined without
having to go through the whole document changing the code. Using
commands like \gls{gls} also identifies which entries need to be
included in the list of terms and, if \sty{hyperref} is loaded, can
be hyperlinked to the relevant place in that list (see
\sectionref{sec:displaygloss}).

So explicitly using \verb|f'(x_i)| won't index the \code{deriv} entry 
or mark it has having been used or create a hyperlink. One
possibility is to use one of the following commands:
\nosecformatdef{glslink}
\nosecformatdef{glsdisp}
They both work in much the same way, indexing the entry and
displaying \meta{text} as the \idx{link-text}. The only difference is
that \gls{glsdisp} also unsets the \idx{firstuseflag}, which marks the entry
as having been used. For example:
\begin{codeenv}
The gradient at \gls{mshiftchar}x\gls{sbchar}i\gls{mshiftchar} is \gls{glslink}\marg{deriv}\marg{\gls{mshiftchar}f'(x\gls{sbchar}i)\gls{mshiftchar}}.
\end{codeenv}
This solves the problem of ensuring that the \code{deriv} entry is
indexed and, if \sty{hyperref} is loaded, ensures that the
\idx{link-text} has a hyperlink to the relevant place in the list of
notation, but it doesn't solve the problem of consistent formatting.

One way of ensuring consistent formatting is to define a semantic
command. For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}[\styopt{symbols}]\marg{glossaries-extra}
\strut
\gls{glsnoexpandfields}
\strut
\cmd{newcommand}\marg{\cmd{derivfn}}[1]\marg{f'(\gls{param}1)}
\strut
\gls{glsxtrnewsymbol}
 \oarg{\field{description} = \marg{derivative}}
 \marg{deriv}\comment{label}
 \marg{\gls{ensuremath}\marg{\cmd{derivfn}\marg{x}}}\comment{symbol}
\strut
\cmd{begin}\marg{document}
The derivative is denoted \gls{gls}\marg{deriv}.
The gradient at \gls{mshiftchar}x\gls{sbchar}i\gls{mshiftchar} is \gls{glslink}\marg{deriv}\marg{\gls{mshiftchar}\cmd{derivfn}\marg{x\gls{sbchar}i}\gls{mshiftchar}}.
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
\providecommand{\derivfn}[1]{f'(#1)}
The derivative is denoted \gls{ex.deriv}.
The gradient at $x_i$ is \glslink{ex.deriv}{$\derivfn{x_i}$}.
\end{result}
Now only \csfmt{derivfn} needs modifying if the notation must change.
This requires remembering both the entry label (\code{deriv} in this
case) and the associated formatting command (\csfmt{derivfn} in this
case). The \sty{glossaries-extra} package provides a way of storing
the associated formatting command in one of the additional keys (see
\sectionref{sec:userkeys}). The field is identified by:
\nosecformatdef{GlsXtrFmtField}
which defaults to \field{useri} (the internal representation of the
\field{user1} key). The value must be the name (without the leading
backslash) of a control sequence that takes a \emph{single}
mandatory argument. The above custom command \code{derivfn}
satisfies this requirement, so the entry can be defined as:
\begin{codeenv}
\gls{glsxtrnewsymbol}
 \oarg{\comment{settings:}
   \field{description} = \marg{derivative},
   \field{user1} = \marg{derivfn}
 }
 \marg{deriv}\comment{label}
 \marg{\gls{ensuremath}\marg{\cmd{derivfn}\marg{x}}}\comment{symbol}
\end{codeenv}
The formatting command can now be applied using one of the
following:
\nosecformatdef{glsxtrfmt}
\nosecformatdef{glsxtrfmt*}
which internally use \gls{glslink} or:
\nosecformatdef{glsxtrentryfmt}
which doesn't (as so is more like using \gls{glsentryname}).

So an alternative approach is:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}[\styopt{symbols}]\marg{glossaries-extra}
\strut
\gls{glsnoexpandfields}
\strut
\cmd{newcommand}\marg{\cmd{derivfn}}[1]\marg{f'(\gls{param}1)}
\strut
\gls{glsxtrnewsymbol}
 \oarg{\comment{settings:}
   \field{description} = \marg{derivative},
   \field{user1} = \marg{derivfn}
 }
 \marg{deriv}\comment{label}
 \marg{\gls{ensuremath}\marg{\cmd{derivfn}\marg{x}}}\comment{symbol}
\strut
\cmd{begin}\marg{document}
The derivative is denoted \gls{gls}\marg{deriv}.
The gradient at \gls{mshiftchar}x\gls{sbchar}i\gls{mshiftchar} is \gls{mshiftchar}\gls{glsxtrfmt}\marg{deriv}\marg{x\gls{sbchar}i}\gls{mshiftchar}.
\cmd{end}\marg{document}
\end{codeenv}
This again produces:
\begin{result}
The derivative is denoted \gls{ex.deriv}.
The gradient at $x_i$ is $\glsxtrfmt{ex.deriv}{x_i}$.
\end{result}

Both the starred \gls{glsxtrfmt*} and unstarred \gls{glsxtrfmt}
format the \meta{text} argument using:
\nosecformatdef{glsxtrfmtdisplay}
where \meta{cs-name} is the control sequence name stored in the
field identified by \gls{GlsXtrFmtField} and the \meta{insert} part
is the final optional argument for the starred \gls{glsxtrfmt*} (if
provided) otherwise it's empty. If the command identified by
\meta{cs-name} doesn't exist (or if the field providing it isn't
set) then just \meta{text}\meta{insert} is done.

\begin{important}
Nested \idx{link-text} causes problems so don't use \gls{glsxtrfmt}
in the optional part of commands like \gls{gls} or \gls{glssymbol}
or in field values that are used by those types of command. Also
don't use \gls{glsxtrfmt} within the \meta{text} or \meta{insert}
part of another instance of \gls{glsxtrfmt} or in \gls{glslink} or
\gls{glsdisp}. Use \gls{glsxtrentryfmt} instead.
\end{important}

If more than one argument is required, then a helper macro is
needed. For example:
\begin{verbatim}
\newcommand{\iderivfn}[2][f]{#1'(#2)}
\newcommand{\derivfn}[1]{\iderivfn#1}
\end{verbatim}
Now to obtain $g'(x_i)$:
\begin{codeenv}
\gls{mshiftchar}\gls{glsxtrfmt}\marg{deriv}\marg{[g]\marg{x\gls{sbchar}i}}\gls{mshiftchar}
\end{codeenv}

\section{Dealing with Automated Case-Changing}
\label{sec:symfirstuc}

Commands like \gls{Gls} don't usually make much sense for symbols as
a change in case can cause a change in meaning. For example,
$\boldsymbol{x}$ might denote a vector and $\boldsymbol{X}$ might
denote a matrix. However, you may have a mixed list of terms
containing both symbols and words, and if you set the
\catattr{glossname} attribute to \code{firstuc}, which automatically
converts the first letter of each \field{name} to \idx{uppercase} in the
glossary, then this can cause a problem for entries where the
\field{name} starts with a symbol. The simplest solution is to
insert an empty group at the start of the \field{name} field for
such entries. For example:
\begin{codeenv}
\gls{glsxtrnewsymbol}
 \oarg{\field{description} = \marg{length}}\comment{settings}
 \marg{length}\comment{label}
 \marg{\marg{}\gls{si}\marg{\cmd{metre}}}\comment{name}
\end{codeenv}
This is done automatically by \bibgls, but if it causes any
interference you can switch off the behaviour with
\longarg{no-mfirstuc-math-protection}.

\chapter{Displaying the Definition}
\label{sec:displaygloss}

The examples so far only use the defined entries in the documents
with commands like \gls{gls} or \gls{glssymbol} or
\gls{glsentrydesc}. These are useful for ensuring consistent
formatting, but it's also helpful to have a place in the document
where the term is formally defined. This can be partially solved
by including the description in parentheses on \idx{firstuse},
either by explicitly including the description in the \field{first}
field or with the use of the \idx{postlinkhook}, but the
\idx{firstuse} might not be the most appropriate place for the
description.

\section{Listing the Terms (Glossary)}
\label{sec:printgloss}

If you want a complete list of all defined terms, you can use:
\nosecformatdef{printunsrtglossary}
This lists all the terms for the given glossary (identified by the
\printglossopt{type} key in \meta{options}, see
\sectionref{sec:multigloss}) according to the order of the
glossary's internal list of labels, which is typically in the order of 
definition. (As each entry is defined, its label is appended to the
internal list of the associated glossary.)

You can change the default title with the \printglossopt{title} option. For
example:
\begin{codeenv}
\gls{printunsrtglossary}\oarg{\printglossopt[Nomenclature]{title}}
\end{codeenv}
The title used in the table of contents is assumed to be the same,
but you can change it with \printglossopt{toctitle}. For example:
\begin{codeenv}
\gls{printunsrtglossary}\oarg{
 \printglossopt[List of Terms and Notation]{title},
 \printglossopt[Notation]{toctitle}
}
\end{codeenv}

The glossary style can be set with the \printglossopt{style} key
in \meta{options}. Alternatively, you can set a default style with the
\styopt{style} package option. There are many predefined styles to
choose from (see the
\href{https://www.dickimaw-books.com/gallery/glossaries-styles/}{\styfmt{glossaries}
gallery}~\cite{glossarystylesgallery}). The styles are provided in supplementary packages, some
of which are automatically loaded. Since each package adds to the
document overhead, and some require additional packages to be
loaded, when using \sty{glossaries-extra}, it's a good idea to
disable the automatic loading of all styles with \styopt{nostyles}
and then use \styopt{stylemods} to load the specific packages (along
with the \sty{glossaries-extra-stylemods} package, which patches
some of the predefined styles). For example, the
\glostyle{index} style is provided by the \styfmt{glossary-tree}
package, so \styopt[tree]{stylemods} will automatically load
\styfmt{glossary-tree} and provide all the tree-like styles,
including \glostyle{index}. The \styopt{stylemods} value may be a
comma-separated list, so to load both \styfmt{glossary-tree} and
\styfmt{glossary-long}, use \styopt[tree,long]{stylemods}.
For example:
\begin{codeenv}
\cmd{documentclass}\marg{scrartcl}
\cmd{usepackage}\marg{\gls[noindex=false]{mhchem}}
\cmd{usepackage}[\styopt[dot]{postpunc},\comment{full stop after description}
 \styopt{nostyles},\comment{don't load default style packages}
\comment{load glossaries-extra-stylemods.sty and glossary-tree.sty:}
 \styopt[tree]{stylemods}
]\marg{glossaries-extra}
\strut
\gls{newglossaryentry}\marg{area}
\marg{
   \field{name} = \marg{\gls{ensuremath}\marg{A}},
   \field{description} = \marg{area}
}
\strut
\gls{newglossaryentry}\marg{amethyst}
\marg{
   \field{name} = \marg{amethyst},
   \field{description} = \marg{a purple type of quartz},
   \field{symbol} = \marg{\gls[noindex=false]{ce}\marg{SiO2}}
}
\strut
\gls{newglossaryentry}\marg{circumference}
\marg{
   \field{name} = \marg{\gls{ensuremath}\marg{C}},
   \field{description} = \marg{circumference}
}
\strut
\gls{newglossaryentry}\marg{duck}
\marg{
   \field{name} = \marg{duck},
   \field{description} = \marg{a waterbird with webbed feet}
}
\gls{newglossaryentry}\marg{goose}
\marg{
   \field{name} = \marg{goose},
   \field{description} = \marg{a large waterbird with a long neck, short legs,
webbed feet and a short broad bill}
}
\strut
\gls{newglossaryentry}\marg{radius}
\marg{
   \field{name} = \marg{\gls{ensuremath}\marg{r}},
   \field{description} = \marg{radius}
}
\strut
\gls{newglossaryentry}\marg{pi}
\marg{
   \field{name} = \marg{\gls{ensuremath}\marg{\cmd{pi}}},
   \field{description} = \marg{Archimedes' constant}
}
\strut
\cmd{begin}\marg{document}
\gls{printunsrtglossary}\oarg{\printglossopt[index]{style}}
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
\glsaddeach{ex3.goose,ex3.duck,ex2.amethyst,standalone.pi,%
standalone.circumference,standalone.area,standalone.radius}%
\setupglossaries{toc=false,section}%
\glossariesextrasetup{postpunc=dot}%
\renewcommand{\glsxtrgroupfield}{useriii}%
\renewcommand*{\printunsrtglossaryentryprocesshook}[1]{%
  \glsifcategory{#1}{standalone}{}{\printunsrtglossaryskipentry}%
}%
\printunsrtglossary[style=index,title=Glossary,nonumberlist,target=false]
\end{result}
The \glostyle{index} glossary style checks if the \field{symbol}
field has been set. If it has, then the symbol is added in
parentheses (as in the amethyst example). Only some of the styles
include the \field{symbol} field. (Table~15.1 in the
\sty{glossaries} user manual~\cite{glossaries} gives an overview of
the features supported by the predefined styles.)

The glossary is sub-divided into letter groups. By default, these
sub-groups are separated with a vertical gap (for example, between
duck and goose above). In the above example, the letter group is
determined by the first character of the \field{sort} field. Since the
default behaviour of both \sty{glossaries} and
\sty{glossaries-extra} is to use \idx{makeindex}, the \field{sort}
field (which is used by \idx{makeindex}) is set to the value of the
\field{name} field (unless explicitly set) and then sanitized.

When using \gls{printunsrtglossary}, the \field{sort} field is
irrelevant except to determine the letter group. The sub-group
heading is displayed by some styles, such as the
\glostyle{indexgroup} style. For example, with:
\begin{codeenv}
\gls{printunsrtglossary}\oarg{\printglossopt[indexgroup]{style}}
\end{codeenv}
The glossary is now:
\begin{result}
\setupglossaries{toc=false,section}%
\glossariesextrasetup{postpunc=dot}%
\renewcommand{\glsxtrgroupfield}{useriii}%
\renewcommand*{\printunsrtglossaryentryprocesshook}[1]{%
  \glsifcategory{#1}{standalone}{}{\printunsrtglossaryskipentry}%
}%
\printunsrtglossary[style=indexgroup,title=Glossary,nonumberlist,target=false]
\end{result}
This explains why there's a gap between $A$ (area) and amethyst as
they don't belong to the same letter group. The \field{sort} field
for the \code{area} entry is \verb|\ensuremath{A}| which has been
sanitized, so it starts with a literal backslash (\idx{backslashchar}).
This means that \code{area} is assigned to the symbols letter group. The
symbols group occurs three times, because the list is following the
order of definition.

\subsection{Groups and Locations}
\label{sec:group}

The \field{group} key isn't defined by default, but if it is defined
then \gls{printunsrtglossary} will use the \field{group} field
instead of trying to determine the group from the first character of
the \field{sort} field (as in the example above). The value of the
\field{group} field must be a label (see \sectionref{sec:labels}). 
A title may be assigned to a group with:
\nosecformatdef{glsxtrsetgrouptitle}
If a title hasn't been assigned, the label is used as the title.
The above command is the preferred form, but the base
\sty{glossaries} package checks for a control sequence in the form
\csfmt{\meta{label}groupname} where \meta{label} is the group label.
The \sty{glossaries-extra} package also recognises this form to
ensure backward-compatibility.  If the \field{group} field is empty
the sub-group won't have a title.

For example, the following defines the \field{group} field with a
custom command \csfmt{grouplabel} (that's not needed, but it's
required by the \gls{glsaddstoragekey} syntax):
\begin{codeenv}
\cmd{documentclass}\marg{scrartcl}
\cmd{usepackage}\marg{mhchem}
\cmd{usepackage}[\styopt[dot]{postpunc},\comment{full stop after description}
 \styopt{nostyles},\comment{don't load default style packages}
 \styopt[tree]{stylemods}\comment{load glossary-tree.sty and patch styles}
]\marg{glossaries-extra}
\strut
\gls{glsaddstoragekey}\marg{group}\marg{}\marg{\cmd{grouplabel}}
\gls{glsxtrsetgrouptitle}\marg{greek}\marg{Greek Symbols}
\strut
\gls{newglossaryentry}\marg{area}
\marg{
   \field{name} = \marg{\gls{ensuremath}\marg{A}},
   \field{description} = \marg{area},
   \field{group} = \marg{A}
}
\strut
\gls{newglossaryentry}\marg{amethyst}
\marg{
   \field{name} = \marg{amethyst},
   \field{description} = \marg{a purple type of quartz},
   \field{symbol} = \marg{\gls{ce}\marg{SiO2}},
   \field{group} = \marg{A}
}
\strut
\gls{newglossaryentry}\marg{circumference}
\marg{
   \field{name} = \marg{\gls{ensuremath}\marg{C}},
   \field{description} = \marg{circumference},
   \field{group} = \marg{C}
}
\strut
\gls{newglossaryentry}\marg{duck}
\marg{
   \field{name} = \marg{duck},
   \field{description} = \marg{a waterbird with webbed feet},
   \field{group} = \marg{D}
}
\strut
\gls{newglossaryentry}\marg{goose}
\marg{
   \field{name} = \marg{goose},
   \field{description} = \marg{a large waterbird with a long neck, short legs,
   webbed feet and a short broad bill},
   \field{group} = \marg{G}
}
\strut
\gls{newglossaryentry}\marg{radius}
\marg{
   \field{name} = \marg{\gls{ensuremath}\marg{r}},
   \field{description} = \marg{radius},
   \field{group} = \marg{R}
}
\strut
\gls{newglossaryentry}\marg{pi}
\marg{
   \field{name} = \marg{\gls{ensuremath}\marg{\cmd{pi}}},
   \field{description} = \marg{Archimedes' constant},
   \field{group} = \marg{greek}
}
\strut
\cmd{begin}\marg{document}
\gls{printunsrtglossary}\oarg{\printglossopt[indexgroup]{style}}
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
\setupglossaries{toc=false,section}%
\glossariesextrasetup{postpunc=dot}%
\renewcommand{\glsxtrgroupfield}{useriv}%
\glsxtrsetgrouptitle{greek}{Greek Symbols}%
\renewcommand*{\printunsrtglossaryentryprocesshook}[1]{%
  \glsifcategory{#1}{standalone}{}{\printunsrtglossaryskipentry}%
}%
\printunsrtglossary[style=indexgroup,title=Glossary,nonumberlist,target=false]
\end{result}
Note that with this method \emph{every} entry must be assigned a
group or it will be assigned to the empty group.

Similarly, if the \field{location} field is defined, you can use it
to provide a location list. The \styopt{record} package option
conveniently defines both \field{group} and \field{location}, so the
following can be used instead:
\begin{codeenv}
\cmd{usepackage}[
 \styopt{record},\comment{provides group and location fields (and other stuff)}
 postpunc=dot,nostyles,stylemods={tree}]\marg{glossaries-extra}
\strut
\gls{newglossaryentry}\marg{area}
\marg{
   \field{name} = \marg{\gls{ensuremath}\marg{A}},
   \field{description} = \marg{area},
   \field{group} = \marg{A},
   \field{location} = \marg{page 1}
}
\end{codeenv}
This very quickly becomes tedious and prone to errors as the entries
have to be ordered manually, and every entry must be assigned the
group and location (if required).  Every time the location changes
through edits to the document, the locations must be updated.
However, this is exactly the method that \bibgls\ uses, but it does
it automatically for you by selecting the required data from one or
more \ext{bib} files and then creating a file containing all the
glossary entry definitions with the fields set appropriately. The \ext{aux}
file provides \bibgls\ with the indexing information so that it
knows which entries to select and what the locations are, and how to
order the definitions. See \sectionref{sec:bib2gls} for further
information.

\subsection{Homographs and Hierarchical Terms}
\label{sec:parent}

An entry may be assigned a parent with the \field{parent} key. The
value must be the label of a entry that's already defined. You can
test if an entry has the \field{parent} field set with:
\nosecformatdef{ifglshasparent}
If the \field{name} key is omitted, the value is assumed to be the same as
the parent's \field{name}.
For example:
\begin{codeenv}
\comment{parent:}
\gls{newglossaryentry}\marg{glossary}\marg{\field{name}=\marg{glossary},\field{description}=\marg{}}
\comment{children:}
\gls{newglossaryentry}\marg{glossarycol}
\marg{\comment{settings:}
 \field{parent} = \marg{glossary},\comment{parent label}
 \field{description} = \marg{collection of glosses}
}
\gls{newglossaryentry}\marg{glossarylist}
\marg{\comment{settings:}
 \field{parent} = \marg{glossary},\comment{parent label}
 \field{description} = \marg{list of technical words}
}
\end{codeenv}
In this case the entry with the label \code{glossary} is the
\pidx{parent-entry}, and the entries with
the labels \code{glossarycol} and \code{glossarylist} are 
\pidxpl{child-entry} (or sub-items). An entry that doesn't have a
parent is a main or top-level or level~0 item. In this case, the
\idxpl{child-entry} don't have the \field{name} key, so the name is
obtained from the parent's name. This is an example of a
\pidx{homograph}, where two words with different meanings
have the same spelling. The parent entry has an empty description.

Here's another example:
\begin{codeenv}
\comment{parent:}
\gls{newglossaryentry}\marg{mineral}\comment{label}
\marg{\comment{settings:}
  \field{name} = \marg{mineral},
  \field{description} = \marg{natural inorganic substance}
}
\comment{sub-entries:}
\gls{newglossaryentry}\marg{quartz}\comment{label}
\marg{
  \field{parent} = \marg{mineral},\comment{parent label}
  \field{name} = \marg{quartz},
  \field{description} = \marg{hard mineral consisting of silica}
}
\gls{newglossaryentry}\marg{amethyst}\comment{label}
\marg{
  \field{parent} = \marg{quartz},\comment{parent label}
  \field{name} = \marg{amethyst},
  \field{description} = \marg{a purple type of quartz}
}
\end{codeenv}
In this case, the \idxpl{child-entry} have the \field{name} key
set. This is an example of a set of \pidxpl{hierarchical-entry},
where each \idx{child-entry} is a sub-category of the parent.
Some glossary styles are appropriate for \idxpl{homograph} and some
are appropriate for \idxpl{hierarchical-entry} and some are only
appropriate for flat glossaries (no child entries).
For example, the \glostyle{index}, \glostyle{indexgroup},
\glostyle{tree} and \glostyle{treegroup} styles are appropriate 
for \idxpl{hierarchical-entry}:
\begin{codeenv}
\cmd{documentclass}\marg{scrartcl}
\strut
\cmd{usepackage}[\styopt{nostyles},\styopt[dot]{postpunc},\styopt[tree]{stylemods}]\marg{glossaries-extra}
\strut
\gls{newglossaryentry}\marg{animal}
\marg{
   \field{name} = \marg{animal},
   \field{description} = \marg{living organism with a nervous system and sense organs
    that can move independently}
}
\strut
\gls{newglossaryentry}\marg{bird}
\marg{
  \field{parent} = \marg{animal},
  \field{name} = \marg{bird},
  \field{description} = \marg{warm-blooded egg-laying animal with feathers, wings
   and a beak}
}
\strut
\gls{newglossaryentry}\marg{duck}
\marg{
   \field{parent} = \marg{bird},
   \field{name} = \marg{duck},
   \field{description} = \marg{a waterbird with webbed feet}
}
\strut
\gls{newglossaryentry}\marg{goose}
\marg{
   \field{parent} = \marg{bird},
   \field{name} = \marg{goose},
   \field{description} = \marg{a large waterbird with a long neck, short legs,
   webbed feet and a short broad bill}
}
\strut
\gls{newglossaryentry}\marg{mineral}
\marg{
  \field{name} = \marg{mineral},
  \field{description} = \marg{natural inorganic substance}
}
\strut
\gls{newglossaryentry}\marg{quartz}
\marg{
  \field{parent} = \marg{mineral},
  \field{name} = \marg{quartz},
  \field{description} = \marg{hard mineral consisting of silica}
}
\strut
\gls{newglossaryentry}\marg{amethyst}
\marg{
   \field{parent} = \marg{quartz},
   \field{name} = \marg{amethyst},
   \field{description} = \marg{a purple type of quartz},
}
\strut
\gls{newglossaryentry}\marg{citrine}
\marg{
  \field{parent} = \marg{quartz},
  \field{name} = \marg{citrine},
  \field{description} = \marg{a form of quartz with a colour ranging
  from pale yellow to brown due to ferric impurities}
}
\strut
\cmd{begin}\marg{document}
\gls{printunsrtglossary}\oarg{style=indexgroup}
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
\glsaddeach{hier.animal,hier.bird,hier.duck,hier.goose,hier.mineral,%
hier.quartz,hier.amethyst,hier.citrine}%
\setupglossaries{toc=false,section}%
\glossariesextrasetup{postpunc=dot}%
\renewcommand*{\printunsrtglossaryentryprocesshook}[1]{%
  \glsifcategory{#1}{hierarchical}{}{\printunsrtglossaryskipentry}%
}%
\printunsrtglossary[subentrycounter=false,style=indexgroup,title=Glossary,nonumberlist,target=false]
\end{result}

The \glostyle{treenoname} and \glostyle{treenonamegroup} styles are
appropriate for \idxpl{homograph}. These are usually best with the
\styopt{subentrycounter} package option, which defines the
\counter{glossarysubentry} counter that's incremented and
displayed for every level~1 entry (that is, an entry with a parent
but not a grandparent). For example:
\begin{codeenv}
\cmd{documentclass}\marg{scrartcl}
\strut
\cmd{usepackage}[\styopt{subentrycounter},\comment{create glossarysubentry counter}
 \styopt[dot]{postpunc},\comment{append full stop after description}
 \styopt{nostyles},\styopt[tree]{stylemods}]\marg{glossaries-extra}
\strut
\gls{newglossaryentry}\marg{bow1}
\marg{
 \field{name}=\marg{bow},
 \field{description}=\marg{(rhymes with toe)}
}
\strut
\gls{newglossaryentry}\marg{bowknot}
\marg{
  \field{parent} = \marg{bow1},
  \field{description} = \marg{a knot tied with two loops and loose ends}
}
\strut
\gls{newglossaryentry}\marg{bowweapon}
\marg{
  \field{parent} = \marg{bow1},
  \field{description} = \marg{a weapon for shooting arrows, made of curved wood
  joined at both ends with taut string}
}
\strut
\gls{newglossaryentry}\marg{bow2}
\marg{
 \field{name}=\marg{bow},
 \field{description}=\marg{(rhymes with cow)}
}
\strut
\gls{newglossaryentry}\marg{bowbend}
\marg{
  \field{parent} = \marg{bow2},
  \field{description} = \marg{bend head or upper body}
}
\strut
\gls{newglossaryentry}\marg{bowpressure}
\marg{
  \field{parent} = \marg{bow2},
  \field{description} = \marg{give in to pressure}
}
\strut
\gls{newglossaryentry}\marg{bow3}
\marg{
 \field{name}=\marg{bow},
 \field{description}=\marg{(also bows) the front end of a ship}
}
\strut
\gls{newglossaryentry}\marg{glossary}\marg{\field{name}=\marg{glossary},\field{description}=\marg{}}
\strut
\gls{newglossaryentry}\marg{glossarycol}
\marg{
  \field{parent} = \marg{glossary},
  \field{description} = \marg{collection of glosses}
}
\strut
\gls{newglossaryentry}\marg{glossarylist}
\marg{
  \field{parent} = \marg{glossary},
  \field{description} = \marg{list of technical words}
}
\strut
\cmd{begin}\marg{document}
\gls{printunsrtglossary}\oarg{style=treenoname}
\cmd{end}\marg{document}
\end{codeenv}
This produces
\begin{result}
\glsaddeach{hom.bow1,hom.bowknot,hom.bowweapon,%
hom.bow2,hom.bowbend,hom.bowpressure,hom.bow3,%
hom.glossary,hom.glossarycol,hom.glossarylist}%
\setupglossaries{toc=false,section}%
\glossariesextrasetup{postpunc=dot}%
\renewcommand*{\printunsrtglossaryentryprocesshook}[1]{%
  \glsifcategory{#1}{homograph}{}{\printunsrtglossaryskipentry}%
}%
\printunsrtglossary[style=treenoname,title=Glossary,nonumberlist,target=false]
\end{result}
The empty description for the top-level \code{glossary} entry has
caused an odd effect with a space occurring between the name and the
post-description punctuation. This can be removed by redefining:
\nosecformatdef{glstreenonamedesc}
so that it checks if the \field{description} field has been set with:
\nosecformatdef{ifglshasdesc}
For example:
\begin{codeenv}
\cmd{renewcommand}\marg{\gls{glstreenonamedesc}}[1]\marg{\comment{}
  \gls{ifglshasdesc}\marg{\gls{param}1}
  \marg{\gls[noindex=false]{glstreepredesc}\gls{glossentrydesc}\marg{\gls{param}1}\gls{glspostdescription}}
  \marg{}\comment{do nothing, description field is empty}
}
\end{codeenv}
Another variation is to check if the entry has children add use a
colon instead of a \idx{full-stop}. The base \sty{glossaries}
package provides:
\nosecformatdef{ifglshaschildren}
However this method is very inefficient as it has to iterate over
all defined entries and check if any have the \field{parent} field
set to \meta{entry label}. A more efficient method can be obtained
with \bibgls\ and the \csopt{save-child-count} resource option,
which will save the number of child entries that have been indexed
in an internal field labelled \field{childcount}. In this case, a
more efficient method is to use:
\nosecformatdef{GlsXtrIfHasNonZeroChildCount}
If you don't use \bibgls, this command will always do \meta{false}
unless you explicitly set the internal fields to the correct
values.

\subsection{Multiple Glossaries}
\label{sec:multigloss}

The default glossary has the label \code{main}, but it can also be referenced 
with:
\nosecformatdef{glsdefaulttype}
The \styopt{nomain} package option suppresses the creation of the
\code{main} glossary, in which case \gls{glsdefaulttype} will be set to
the first glossary to be defined. (There must be at least one
glossary defined, so if you use \styopt{nomain} you must provide
another default.)

Abbreviations defined with \gls{newabbreviation}
(see \sectionref{sec:abbreviations}) are, by default, assigned to the glossary 
given by:
\nosecformatdef{glsxtrabbrvtype}
This initially expands to \gls{glsdefaulttype}, but the
\styopt{abbreviations} option redefines this to \code{abbreviations}
and creates a glossary with that label.

Abbreviations defined with \gls{newacronym} are, by default,
assigned to the glossary given by:
\nosecformatdef{acronymtype}
This initially expands to \gls{glsdefaulttype}, but the
\styopt{abbreviations} option redefines this to
\gls{glsxtrabbrvtype}. However, the \styopt{acronyms} option
redefines \gls{acronymtype} to \code{acronym} and creates a glossary
with that label. So if you use both the \styopt{abbreviations} and
\styopt{acronyms} package options, you will have two extra
glossaries created, one as the default for \gls{newabbreviation} and
the other as the default for \gls{newacronym}.

The \styopt{symbols} package option creates a glossary with the
label \code{symbols} and defines \gls{glsxtrnewsymbol} (see 
\sectionref{sec:symbols}) which sets the \field{type} to
\code{symbols}. There are also similar package options
\styopt{numbers} and \styopt{index}, which create the \code{numbers}
glossary (and \gls{glsxtrnewnumber}) and the \code{index} glossary
(and \gls{newterm}).

In each case, the default type can be overridden when defining an
entry by using the \field{type} key in the assignment list. The
value must be the label identifying a defined glossary.

You can provide your own custom glossary using:
\nosecformatdef{newglossary*}
where \meta{type} is the label used to identify the glossary and
\meta{title} is the default title used by \gls{printunsrtglossary}.
(The unstarred version has a different syntax and is only applicable 
with \gls{makeindex} or \gls{xindy}.) For example:
\begin{codeenv}
\gls{newglossary*}\marg{measurements}\marg{SI Units}
\gls{newglossaryentry}\marg{length}
\marg{\comment{settings:}
  \field{name} = \marg{\gls{si}\marg{\cmd{metre}}},
  \field{description} = \marg{length},
  \field{type} = \marg{measurements}
}
\end{codeenv}
In this case, the label identifying the new glossary is
\code{measurements} and the title is \qt{SI Units}.

You can specify the glossary using the \printglossopt{type} setting
in the optional argument of \gls{printunsrtglossary}. For example, 
the above \code{measurements} glossary can be displayed with:
\begin{codeenv}
\gls{printunsrtglossary}\oarg{\printglossopt[measurements]{type}}
\end{codeenv}
For convenience, there's a command that iterates over all defined
glossaries (in the order of definition) and does
\gls{printunsrtglossary}\oarg{\printglossopt[\meta{label}]{type}}
for each glossary:
\nosecformatdef{printunsrtglossaries}
There's no optional argument for this command. When creating
glossaries with package options, such as \styopt{abbreviations}, you
may find an unexpected order as the options aren't always processed
in the order in which they were specified. (Some
\sty{glossaries-extra} options are passed to the base
\sty{glossaries} package and are processed when that package is
internally loaded not when the extension options are processed.) In
which case you need to use \gls{printunsrtglossary} for each
glossary in the required order. You will also need to do this if the
glossary settings are different. (For example, if one glossary needs
to use the \glostyle{tree} style and another needs to use the
\glostyle{treenoname} style.)

You can also define an \pidx{ignoredglossary}, which is ignored by
\gls{printunsrtglossaries}. This is a useful way of creating a
glossary for common terms that shouldn't appear in a list or for
stand-alone entries (see \sectionref{sec:standalone}). The unstarred
form:
\nosecformatdef{newignoredglossary}
is useful for common terms where the list won't be displayed as it
automatically suppresses hyperlinks for entries assigned to that
glossary. The starred form:
\nosecformatdef{newignoredglossary*}
is useful for stand-alone entries as it doesn't automatically
suppress the hyperlinks.
Although \gls{printunsrtglossaries} skips \idxpl{ignoredglossary},
it's still possible to display an \idx{ignoredglossary} with
\gls{printunsrtglossary} but you'll need to use the
\printglossopt{title} setting to override the default title.

\subsection{Redisplaying or Filtering a Glossary}
\label{sec:printglossagain}

It's possible to use \gls{printunsrtglossary} multiple times for the
same glossary, but if you have hyperlinks you will need to either
suppress the targets with \printglossopt[false]{target} or change
the target name. The target names are all prefixed with:
\nosecformatdef{glolinkprefix}
so changing this before displaying the glossary will change the
targets, but commands like \gls{gls} also use this prefix, so they
will only link to the glossary item with a matching prefix.

The starred form of \gls{printunsrtglossary} has an extra
argument:
\nosecformatdef{printunsrtglossary*}
This may be used to make local assignments. It's equivalent to:
\begin{codeenv}
\cmd{begingroup} \meta{code}\gls{printunsrtglossary}\oargm{options}\cmd{endgroup}
\end{codeenv}
For example, if the \field{group} key has been defined (see
\sectionref{sec:group}) you can locally switch to a different field
for the group label by redefining:
\nosecformatdef{glsxtrgroupfield}
within \meta{code}.
For example, if the \field{secondarygroup} field has been defined:
\begin{codeenv}
\gls{printunsrtglossary*}\marg{\comment{}
  \cmd{renewcommand}\marg{\gls{glsxtrgroupfield}}\marg{secondarygroup}\comment{}
}
\end{codeenv}
Note that this just changes the group labels. The order is still
according to the glossary's internal list of labels.

Unlike \gls{printglossary} (used with \gls{makeindex} and
\gls{xindy}) which inputs a file containing the code to typeset the glossary,
\gls{printunsrtglossary} iterates over the labels defined in the
given glossary and adds the appropriate code to an internal command.
Once the construction of the internal command is completed, it's
then performed. (The construction of this internal command is done
to avoid complications when iterating within \env{tabular}-like
environments, as some of the styles use \env{longtable} or
\env{supertabular}.) There's a hook just before the internal command is 
expanded:
\nosecformatdef{printunsrtglossarypredoglossary}
The glossary header and preamble are displayed before 
the loop starts, so this hook won't change them (but you can make
local changes in \meta{code} outside of the hook).
The style is also set before the loop, but the start
and end of the \env{theglossary} environment (which is defined by
the glossary styles) is included in the internal command, so minor
adjustments to the style can be made in this hook.

There's another hook that's performed at each iteration:
\nosecformatdef{printunsrtglossaryentryprocesshook}
where \meta{label} is the current entry label. For example, the
\glostyle{alttree} style needs to know the widest entry name in
order to set up the correct indentation. The widest name is set
using:
\nosecformatdef{glssetwidest}
but this requires knowing which entry has the widest name. There are
some commands provided by the \sty{glossary-tree} and
\sty{glossaries-extra-stylemods} packages that iterate over all
entries, measuring each name, in order to find the widest, but since
\gls{printunsrtglossary} already has to iterate over the list before
typesetting it, this hook can be used to update the widest name at
the same time. You can update the value with:
\nosecformatdef{glsupdatewidest}
which computes the width of \meta{text} and, if it's wider than the
current widest name for the given level, sets the widest value to
\meta{text} (without expanding it). If \meta{text} needs expanding
you need to use:
\nosecformatdef{eglsupdatewidest}
The \meta{level} refers to the entry's hierarchical level with a
value of~0 indicating top-level (that is, an entry without a parent).
The level is stored in the internal \field{level} field and can only
be accessed with \gls{glsxtrusefield} or similar commands 
(see \sectionref{sec:userkeys}).

You can also redefine this hook to filter the glossary list. 
If an entry shouldn't appear in the list, use:
\nosecformatdef{printunsrtglossaryskipentry}
For example, to only include entries that have the \field{category}
set to \code{formula}:
\begin{codeenv}
\gls{printunsrtglossary*}\oarg{\printglossopt{target}=false,\printglossopt{title}=\marg{Formula}}
\marg{\comment{local code:}
  \cmd{renewcommand}\marg{\gls{printunsrtglossaryentryprocesshook}}[1]\marg{\comment{}
   \gls{glsifcategory}\marg{\gls{param}1}\marg{formula}
   \marg{}\comment{category = formula}
   \marg{\gls{printunsrtglossaryskipentry}}\comment{}
  }\comment{}
}
\end{codeenv}
This uses \gls{glsifcategory} to check the value of the entry's 
\field{category} field (see \sectionref{sec:categories}). Another
conditional you might find useful is:
\nosecformatdef{glsxtriflabelinlist}
which tests if the given \meta{label} is in the comma-separated
\meta{list} of labels. Both \meta{label} and \meta{list} are fully
expanded before testing. This command is only intended for labels,
which must be fully expandable.
For example, the following excludes any entries that have the
\field{category} set to \code{abbreviation} or \code{acronym}:
\begin{codeenv}
\gls{printunsrtglossary*}\oarg{\printglossopt{target}=false,\printglossopt{title}=\marg{Formula}}
\marg{\comment{local code:}
  \cmd{renewcommand}\marg{\gls{printunsrtglossaryentryprocesshook}}[1]\marg{\comment{}
   \gls{glsxtriflabelinlist}
   \marg{\gls{glscategory}\marg{\gls{param}1}}\comment{category label for this entry}
   \marg{abbreviation,acronym}\comment{exclusion list}
   \marg{\gls{printunsrtglossaryskipentry}}\comment{}
   \marg{}
  }\comment{}
}
\end{codeenv}


\section{Stand-alone Definitions}
\label{sec:standalone}

The \sty{glossaries-extra} package provides:
\nosecformatdef{glsxtrglossentry}
which may be used to create a target for a particular entry (identified by
\meta{label}). This displays the value of the \field{name} field,
but it also obeys the \idx{postnamehook} (see
\sectionref{sec:postfieldhooks}), the \catattr{glossname}
and \catattr{glossnamefont} attributes (see
\sectionref{sec:glossname}), and provides accessibility support if
the \field{access} field is set (see \sectionref{sec:accsupp}).
This command doesn't display any of the other field values. 
If any are required, you need to add them afterwards.
For the description, you can use \gls{glsentrydesc}, but it's better
to use:
\nosecformatdef{glossentrydesc}
Unlike \gls{glsentrydesc}, which just displays the value of the
\field{description} field, \gls{glossentrydesc} obeys the
\catattr{glossdesc} and \catattr{glossdescfont} attributes
(\sectionref{sec:glossname}). Alternatively, you can use:
\nosecformatdef{Glossentrydesc}
which converts the first letter of the description to
\idx{uppercase}.

There's a similar command for symbols:
\nosecformatdef{glossentrysymbol}
There are currently no category attributes governing this
command, but it does check for the \field{symbolaccess} field if
accessibility support has been added (see \sectionref{sec:accsupp}). 
For other fields, you can use the commands described in
\sectionref{sec:userkeys}.

If you need to substitute the \field{name} for another field in the
target, you can use:
\nosecformatdef{glsxtrglossentryother}
instead of \gls{glsxtrglossentry},
where \meta{label} identifies the entry and \meta{field} is the
internal field label to use instead of the \field{name}. The
\meta{header} argument is the code to use in the header, which
should be left empty for the default value, if
\gls{glsxtrglossentryother} is used in a sectioning command. (The
first argument doesn't use standard \LaTeX\ optional syntax because
the command has to be expandable in order for it to work correctly
in section arguments.) This command obeys the \idx{postnamehook}
even though it's not actually displaying the name.

To pick up the \styopt{postpunc} setting and the
\idx{postdescriptionhook}, append \gls{glspostdescription}
after the description (see \sectionref{sec:postfieldhooks}).
For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{\gls[noindex=false]{xcolor}}
\cmd{usepackage}[colorlinks,linkcolor=purple]\marg{\gls[noindex=false]{hyperref}}
\cmd{usepackage}[\styopt[dot]{postpunc}]\marg{glossaries-extra}
\strut
\gls{newglossaryentry}\marg{pi}
\marg{
   \field{name} = \marg{\gls{ensuremath}\marg{\cmd{pi}}},
   \field{description} = \marg{Archimedes' constant}
}
\strut
\gls{newglossaryentry}\marg{radius}
\marg{
   \field{name} = \marg{\gls{ensuremath}\marg{r}},
   \field{description} = \marg{radius}
}
\strut
\gls{newglossaryentry}\marg{area}
\marg{
   \field{name} = \marg{\gls{ensuremath}\marg{A}},
   \field{description} = \marg{area}
}
\strut
\cmd{begin}\marg{document}
\cmd{begin}\marg{equation}
\gls{gls}\marg{area} = \gls{gls}\marg{pi}\gls{gls}\marg{radius}[\gls{spchar}2]
\cmd{end}\marg{equation}
\cmd{begin}\marg{tabular}\marg{ll}
\gls{glsxtrglossentry}\marg{area} \gls[noindex=false]{colsep} \gls{glossentrydesc}\marg{area}\gls{glspostdescription}\gls[noindex=false]{cs.backslash}
\gls{glsxtrglossentry}\marg{pi} \gls{colsep} \gls{glossentrydesc}\marg{pi}\gls{glspostdescription}\gls{cs.backslash}
\gls{glsxtrglossentry}\marg{radius} \gls{colsep} \gls{glossentrydesc}\marg{radius}\gls{glspostdescription}
\cmd{end}\marg{tabular}
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
\setcounter{equation}{0}%
\renewcommand{\theequation}{\arabic{equation}}%
\renewcommand{\theHequation}{\thechapter.standalone1.\arabic{equation}}%
\renewcommand{\glolinkprefix}{standalone1}%
\renewcommand{\glstextformat}[1]{\textcolor{purple}{#1}}%
\renewcommand{\glslinkpresetkeys}{\setkeys{glslink}{local}}%
\glossariesextrasetup{postdot}%
\begin{equation}
\gls{standalone.area} = \gls{standalone.pi}\gls{standalone.radius}[^2]
\end{equation}
\begin{tabular}{ll}
\glsxtrglossentry{standalone.area} & \glossentrydesc{standalone.area}\glspostdescription\\
\glsxtrglossentry{standalone.pi} & \glossentrydesc{standalone.pi}\glspostdescription\\
\glsxtrglossentry{standalone.radius} & \glossentrydesc{standalone.radius}\glspostdescription
\end{tabular}
\end{result}
The purple text shows the hyperlinks to the relevant definition. As
with \gls{printunsrtglossary}, the hypertargets are prefixed with
\gls{glolinkprefix} (see \sectionref{sec:printglossagain}).  This
can be locally changed to avoid clashes if the definition needs to
be reproduced later.

A more convenient approach to the above is to define an environment that can
list all the referenced entries automatically. The
\sty{glossaries-extra} package provides a way of buffering the
boolean switch performed by \gls{gls} that ensures that the
\idx{firstuseflag} is unset (see \sectionref{sec:buffering}). 
This is intended for use where the switch causes a problem, but it
can also be used in this case to store a list of used entries (since
there's no difference between \idx{firstuse} and subsequent use in
this case, it won't affect the \idx{link-text}).

Here's a modified version of the above document:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{xcolor}
\cmd{usepackage}[colorlinks,linkcolor=purple]\marg{hyperref}
\cmd{usepackage}[\styopt[dot]{postpunc}]\marg{glossaries-extra}
\strut
\gls{newglossaryentry}\marg{pi}
\marg{
   \field{name} = \marg{\gls{ensuremath}\marg{\cmd{pi}}},
   \field{description} = \marg{Archimedes' constant}
}
\strut
\gls{newglossaryentry}\marg{radius}
\marg{
   \field{name} = \marg{\gls{ensuremath}\marg{r}},
   \field{description} = \marg{radius}
}
\strut
\gls{newglossaryentry}\marg{area}
\marg{
   \field{name} = \marg{\gls{ensuremath}\marg{A}},
   \field{description} = \marg{area}
}
\strut
\gls{newglossaryentry}\marg{circumference}
\marg{
   \field{name} = \marg{\gls{ensuremath}\marg{C}},
   \field{description} = \marg{circumference}
}
\strut
\cmd{newcommand}\marg{\cmd{doglossaryentry}}[1]\marg{\comment{handler macro}
  \gls{glsxtrglossentry}\marg{\gls{param}1} \gls{colsep} \gls{glossentrydesc}\marg{\gls{param}1}\gls{glspostdescription}\gls{cs.backslash}\comment{}
}
\strut
\cmd{newcounter}\marg{localglossary}
\strut
\cmd{newenvironment}\marg{localglossary}
\marg{\comment{}
  \cmd{stepcounter}\marg{localglossary}\comment{}
  \cmd{renewcommand}\marg{\gls{glolinkprefix}}\marg{\cmd{thelocalglossary}.}\comment{}
  \gls{GlsXtrStartUnsetBuffering}*
}
\marg{\comment{}
  \cmd{par}
  \cmd{begin}\marg{tabular}\marg{ll}
  \gls{GlsXtrForUnsetBufferedList}\cmd{doglossaryentry}
  \cmd{end}\marg{tabular}
  \gls{GlsXtrStopUnsetBuffering}
  \cmd{par}
}
\strut
\cmd{begin}\marg{document}
The area of a circle is given by:
\cmd{begin}\marg{localglossary}
\cmd{begin}\marg{equation}
\gls{gls}\marg{area} = \gls{gls}\marg{pi}\gls{gls}\marg{radius}[\gls{spchar}2]
\cmd{end}\marg{equation}
\cmd{end}\marg{localglossary}
The circumference of a circle is given by:
\cmd{begin}\marg{localglossary}
\cmd{begin}\marg{equation}
\gls{gls}\marg{circumference} = 2\gls{gls}\marg{pi}\gls{gls}\marg{radius}
\cmd{end}\marg{equation}
\cmd{end}\marg{localglossary}
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
\setcounter{equation}{0}%
\renewcommand{\theequation}{\arabic{equation}}%
\renewcommand{\theHequation}{\thechapter.standalone2.\arabic{equation}}%
\renewcommand{\glolinkprefix}{standalone2}%
\renewcommand{\glstextformat}[1]{\textcolor{purple}{#1}}%
\renewcommand{\glslinkpresetkeys}{}%
\glossariesextrasetup{postdot}%
The area of a circle is given by:
\begin{localglossary}
\begin{equation}
\gls{standalone.area} = \gls{standalone.pi}\gls{standalone.radius}[^2]
\end{equation}
\end{localglossary}
The circumference of a circle is given by:
\begin{localglossary}
\begin{equation}
\gls{standalone.circumference} = 2\gls{standalone.pi}\gls{standalone.radius}
\end{equation}
\end{localglossary}
\end{result}
The custom \counterfmt{localglossary} counter is defined and incremented to
ensure that the target prefix \gls{glolinkprefix} is unique for each
environment. This definition of the custom \envfmt{localglossary}
environment is intentionally kept trivial since the main point here is
the demonstration of \gls{glsxtrglossentry} and the buffering rather
than the actual formatting of the entries. Additional vertical
spacing, appropriate alignment and a paragraph column specifier are
left as an exercise for the reader.

The \styopt{entrycounter} package option creates a new counter
called \counter{glossaryentry}, which will automatically be
incremented and displayed at the start of \gls{glsxtrglossentry}
for top-level entries. (The \counter{glossarysubentry} counter created with the
\styopt{subentrycounter} option, described in \sectionref{sec:parent},
is independent of the \styopt{entrycounter} package option.) In
the above example, this counter will need to depend on the custom
\counterfmt{localglossary} counter to ensure that it's reset at the
start of each \envfmt{localglossary} environment. This can easily be
done by using the name of the master counter as the value of
\styopt{counterwithin} (which automatically implements
\styopt{entrycounter}), but the master counter must be defined
first:
\begin{codeenv}
\cmd{newcounter}\marg{localglossary}
\cmd{usepackage}[\styopt[localglossary]{counterwithin}]\marg{glossaries-extra}
\end{codeenv}
The default definition of \gls{theHglossaryentry} is:
\begin{codeenv}
\gls[noindex=false]{currentglossary}.\gls[noindex=false]{theglossaryentry}
\end{codeenv}
Since this example is using stand-alone definitions rather than
\gls{printunsrtglossary} (see \sectionref{sec:printgloss}), this
definition isn't appropriate and will cause duplicate destination
warnings. The simplest solution is to redefine
\gls{theHglossaryentry} in terms of the custom
\counterfmt{localglossary} counter value:
\begin{codeenv}
\cmd{renewcommand}\marg{\cmd{theHglossaryentry}}\marg{\comment{}
 \cmd{thelocalglossary}.\cmd{arabic}\marg{\counter{glossaryentry}}}
\end{codeenv}
and change \gls{glsstepentry} to use a unique label:
\begin{codeenv}
\cmd{renewcommand}*\marg{\gls{glsstepentry}}[1]\marg{\comment{}
  \cmd{refstepcounter}\marg{\counter{glossaryentry}}\comment{}
  \gls[noindex=false]{label}\marg{glsentry\cmd{arabic}\marg{localglossary}-\gls{param}1}\comment{}
}
\end{codeenv}
(or remove the \gls{label} from the definition if it's unrequired).

Unlike commands such as \gls{gls}, which can be problematic in moving
arguments, \gls{glsxtrglossentry} is designed to work in section
headings. For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{mhchem}
\cmd{usepackage}[colorlinks,linkcolor=magenta]\marg{hyperref}
\cmd{usepackage}[\styopt[dot]{postpunc}]\marg{glossaries-extra}
\strut
\gls{newglossaryentry}\marg{amethyst}
\marg{
   \field{name} = \marg{amethyst},
   \field{description} = \marg{a purple type of quartz},
   \field{symbol} = \marg{\gls{ce}\marg{SiO2}},
   \field{category} = \marg{mineral}
}
\strut
\gls{glssetcategoryattribute}\marg{mineral}\marg{glossname}\marg{firstuc}
\strut
\cmd{newcommand}\marg{\cmd{displayterm}}[1]\marg{\comment{}
 \cmd{subsection}\marg{\gls{glsxtrglossentry}\marg{\gls{param}1}}\comment{}
 Chemical formula: \gls{glossentrysymbol}\marg{\gls{param}1}.
 \gls{Glossentrydesc}\marg{\gls{param}1}\gls{glspostdescription}\cmd{par}
}
\cmd{begin}\marg{document}
\cmd{tableofcontents}
\cmd{section}\marg{Types of Quartz}
A reference to \gls{gls}\marg{amethyst}.
\strut
\cmd{displayterm}\marg{amethyst}
\cmd{end}\marg{document}
\end{codeenv}
(Again, improvements to the actual formatting of the custom
\csfmt{displayterm} is left as an exercise to the reader. Additional
fields could contain, for example, the name of an image file to
illustrated the entry. See the
\href{https://www.dickimaw-books.com/gallery/}{\styfmt{glossaries}
gallery}~\cite{gallery} for further ideas.)

The above example uses the \catattr{glossname} attribute to convert the first
letter of the \field{name} to \idx{uppercase}. Unfortunately this can't be
applied to the PDF bookmark or table of contents. A solution to this
would be to explicitly set the \field{name} with the first letter as
an \idx{uppercase} character and the \field{text} field in
\idx{lowercase}. For example:
\begin{codeenv}
\gls{newglossaryentry}\marg{amethyst}
\marg{
   \field{name} = \marg{Amethyst},
   \field{text} = \marg{amethyst},
   \field{description} = \marg{a purple type of quartz},
   \field{symbol} = \marg{\gls{ce}\marg{SiO2}},
   \field{category} = \marg{mineral}
}
\end{codeenv}
The \catattr{glossname} attribute can then be omitted. This is a bit
inconvenient, but if you use \bibgls\ (see \sectionref{sec:bib2gls})
this can be performed automatically with the
\csopt{name-case-change} resource option.

\chapter{Changing the Formatting}
\label{sec:glsformats}

All commands like \gls{gls} and \gls{glssymbol} by default
encapsulate the \idx{link-text} within the argument of:
\nosecformatdef{glstextformat}
For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{xcolor}\comment{provides colour}
\cmd{usepackage}\marg{pifont}\comment{provides \gls{ding}}
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{newglossaryentry}\marg{duck}\comment{label}
\marg{
   \field{name} = \marg{duck},
   \field{description} = \marg{a waterbird with webbed feet}
}
\strut
\gls{newglossaryentry}\marg{fleuron}\comment{label}
\marg{
  \field{name} = \marg{fleuron},
  \field{symbol} = \marg{\gls[noindex=false]{ding}\marg{167}},
  \field{category} = \marg{ornament},
  \field{description} = \marg{typographic ornament}
}
\strut
\gls{newabbreviation}\marg{tug}\marg{TUG}\marg{\cmd{TeX}\gls{cs.space}Users Group}
\strut
\cmd{renewcommand}\marg{\gls{glstextformat}}[1]\marg{\cmd{textcolor}\marg{violet}\marg{\gls{param}1}}
\strut
\cmd{begin}\marg{document}
A \gls{gls}\marg{duck}, a \gls{gls}\marg{fleuron} (\gls{glssymbol}\marg{fleuron}, 
\gls{glsentrydesc}\marg{fleuron}) and \gls{gls}\marg{tug}.
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}%
\renewcommand{\glstextformat}[1]{\textcolor{violet}{#1}}%
A \gls{ex1.duck}, a \gls{ex.fleuron} (\glssymbol{ex.fleuron}, 
\glsentrydesc{ex.fleuron}) and \gls{TUG}.
\end{result}
Note that this has affected \gls{gls} and \gls{glssymbol} but not
\gls{glsentrydesc}.

A distinction can be made between abbreviations (\idx{non-regular}
terms) and \idx{regular} terms (non-abbreviations or abbreviations
that are considered \idx{regular} entries). 
A \idx{regular} term is encapsulated with 
\nosecformatdef{glsxtrregularfont}
and an abbreviation is encapsulated with 
\nosecformatdef{glsxtrabbreviationfont}
For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{xcolor}\comment{provides colour}
\cmd{usepackage}\marg{pifont}\comment{provides \gls{ding}}
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{newglossaryentry}\marg{duck}\comment{label}
\marg{
   \field{name} = \marg{duck},
   \field{description} = \marg{a waterbird with webbed feet}
}
\strut
\gls{newglossaryentry}\marg{fleuron}\comment{label}
\marg{
  \field{name} = \marg{fleuron},
  \field{symbol} = \marg{\gls{ding}\marg{167}},
  \field{category} = \marg{ornament},
  \field{description} = \marg{typographic ornament}
}
\strut
\gls{newabbreviation}\marg{tug}\marg{TUG}\marg{\cmd{TeX}\gls{cs.space}Users Group}
\gls{newacronym}\marg{ascii}\marg{ASCII}\marg{American Standard Code for 
Information Interchange}
\strut
\cmd{renewcommand}\marg{\gls{glstextformat}}[1]\marg{\cmd{textcolor}\marg{violet}\marg{\gls{param}1}}
\cmd{renewcommand}\marg{\gls{glsxtrregularfont}}[1]\marg{\cmd{underline}\marg{\gls{param}1}}
\cmd{renewcommand}\marg{\gls{glsxtrabbreviationfont}}[1]\marg{\gls{emph}\marg{\gls{param}1}}
\strut
\cmd{begin}\marg{document}
Two \gls{glspl}\marg{duck}, a \gls{gls}\marg{fleuron} (\gls{glssymbol}\marg{fleuron}, 
\gls{glsentrydesc}\marg{fleuron}), \gls{gls}\marg{tug} and \gls{gls}\marg{ascii}.
\cmd{end}\marg{document}
\end{codeenv}
This now produces:
\begin{result}%
\renewcommand{\glstextformat}[1]{\textcolor{violet}{#1}}%
\renewcommand{\glsxtrregularfont}[1]{\underline{#1}}%
\renewcommand{\glsxtrabbreviationfont}[1]{\emph{#1}}%
Two \glspl{ex1.duck}, a \gls{ex.fleuron} (\glssymbol{ex.fleuron}, 
\glsentrydesc{ex.fleuron}), \gls{TUG} and \gls{ASCII}.
\end{result}
Note the difference between the abbreviation defined with
\gls{newabbreviation} and the one defined with \gls{newacronym}.
The above example document is using the default styles, which is
\abbrstyle{long-short} for the \code{abbreviation} category
and \abbrstyle{short-nolong} for the \code{acronym} category.
The \abbrstyle{short-nolong} style makes the abbreviation behave
like a \idx{regular} entry and so it's governed by \gls{glsxtrregularfont}
not by \gls{glsxtrabbreviationfont}.

The \gls{glstextformat} command is overridden by the
\catattr{textformat} attribute. The value of this attribute must be
the name (without the leading backslash) of a command that takes a
single argument, which will be used instead of \gls{glstextformat}
for any entry that has this attribute set for its category.
For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{xcolor}\comment{provides colour}
\cmd{usepackage}\marg{pifont}\comment{provides \gls{ding}}
\cmd{usepackage}\marg{glossaries-extra}
\strut
\cmd{newcommand}\marg{\cmd{ornamentfmt}}[1]\marg{\cmd{textcolor}\marg{cyan}\marg{\gls{param}1}}
\strut
\gls{glssetcategoryattribute}\marg{ornament}\marg{\catattr{textformat}}\marg{ornamentfmt}
\strut
\gls{setabbreviationstyle}\marg{\abbrstyle[noindex=false]{long-short-em}}
\gls{setabbreviationstyle}\oarg[acronym]\marg{short-sc-nolong}
\strut
\gls{newglossaryentry}\marg{duck}\comment{label}
\marg{
   \field{name} = \marg{duck},
   \field{description} = \marg{a waterbird with webbed feet}
}
\strut
\gls{newglossaryentry}\marg{fleuron}\comment{label}
\marg{
  \field{name} = \marg{fleuron},
  \field{symbol} = \marg{\gls{ding}\marg{167}},
  \field{category} = \marg{ornament},
  \field{description} = \marg{typographic ornament}
}
\strut
\gls{newabbreviation}\marg{tug}\marg{TUG}\marg{\cmd{TeX}\gls{cs.space}Users Group}
\gls{newacronym}\marg{ascii}\comment{label}
\marg{ascii}\comment{short form needs to be in lower case with sc styles}
\marg{American Standard Code for Information Interchange}
\strut
\cmd{renewcommand}\marg{\gls{glstextformat}}[1]\marg{\cmd{textcolor}\marg{violet}\marg{\gls{param}1}}
\cmd{renewcommand}\marg{\gls{glsxtrregularfont}}[1]\marg{\cmd{underline}\marg{\gls{param}1}}
\cmd{renewcommand}\marg{\gls{glsxtrabbreviationfont}}[1]\marg{\gls{textbf}\marg{\gls{param}1}}
\strut
\cmd{begin}\marg{document}
Two \gls{glspl}\marg{duck}, a \gls{gls}\marg{fleuron} (\gls{glssymbol}\marg{fleuron}, 
\gls{glsentrydesc}\marg{fleuron}), \gls{gls}\marg{tug} and \gls{gls}\marg{ascii}.
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
\renewcommand{\glstextformat}[1]{\textcolor{violet}{#1}}%
\renewcommand{\glsxtrregularfont}[1]{\underline{#1}}%
\renewcommand{\glsxtrabbreviationfont}[1]{\textbf{#1}}%
\newcommand{\ornamentfmt}[1]{\textcolor{cyan}{#1}}%
\glssetcategoryattribute{ornament}{textformat}{ornamentfmt}%
Two \glspl{ex1.duck}, a \gls{ex.fleuron} (\glssymbol{ex.fleuron}, 
\glsentrydesc{ex.fleuron}), \gls{ex.tug} and \gls{ex.ascii}.
\end{result}
So \code{\gls{gls}\marg{fleuron}} and \code{\gls{glssymbol}\marg{fleuron}} are now
formatted according to the custom command \csfmt{ornamentfmt} (cyan)
not by \gls{glstextformat} (violet), but they are still affected by
\gls{glsxtrregularfont} (underline).

The \code{tug} abbreviation has been assigned the
\abbrstyle{long-short-em} style which encapsulates the short form
with \gls{emph}, but it also obeys \gls{glsxtrabbreviationfont}
(bold) and it's encapsulated by \gls{glstextformat} (violet), so the
full form on \idx{firstuse} is all violet and bold with the short
form in italics.

The \code{ascii} entry (which has the \field{category} set to
\code{acronym}) has been assigned the \abbrstyle{short-sc-nolong}
style, which encapsulates the short form with \gls{textsc} (so the
short form must be converted to \idx{lowercase}) and identifies the
entry as a \idx{regular} term, so it obeys \gls{glsxtrregularfont}
(underline). Again, the \idx{link-text} is encapsulated with
\gls{glstextformat} (violet) so the abbreviation is violet,
underlined and in small-caps.

You can override a specific instance with the \glsopt{textformat}
setting in the first optional argument of commands like \gls{gls}.
For example, if the above is modified to:
\begin{codeenv}
Two \gls{glspl}\marg{duck}, a \gls{gls}\oarg{\glsopt{textformat}=textbf}\marg{fleuron} 
(\gls{glssymbol}\marg{fleuron}, \gls{glsentrydesc}\marg{fleuron}), \gls{gls}\marg{tug} 
and \gls{gls}\marg{ascii}.
\end{codeenv}
then the result is now:
\begin{result}
\renewcommand{\glstextformat}[1]{\textcolor{violet}{#1}}%
\renewcommand{\glsxtrregularfont}[1]{\underline{#1}}%
\renewcommand{\glsxtrabbreviationfont}[1]{\textbf{#1}}%
\newcommand{\ornamentfmt}[1]{\textcolor{cyan}{#1}}%
\glssetcategoryattribute{ornament}{textformat}{ornamentfmt}%
Two \glspl{ex1.duck}, a \gls[textformat=textbf]{ex.fleuron} 
(\glssymbol{ex.fleuron}, \glsentrydesc{ex.fleuron}),
\gls{ex.tug} and \gls{ex.ascii}.
\end{result}
In this case, only that specific instance is changed.

Take care if the formatting command needs to parse its argument as
the argument won't be the actual text but consists of intermediary commands
that determine the required text and any inner formatting, such as
the formatting applied by abbreviation styles. See
\sectionref{sec:expandedfmt} for further details.

\section{Post-Link Category Hooks}
\label{sec:postlinkhooks}

Extra information can be appended after commands such as \gls{gls}
by defining a \pidx{postlinkhook} for the given category. You can
obtain the label of the entry that's just been referenced with:
\nosecformatdef{glslabel}
The \idx{postlinkhook} is a command in the form
\nosecformatdef{glsxtrpostlinkcategory}
where \meta{category} is the category label. This hook is
implemented after any instances of commands such as \gls{gls} or
\gls{glssymbol} (but not after commands like \gls{glsentryname},
\gls{glsentrydesc} or \gls{glsentryname}, which may be used in the
hook).

Consider the following document:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{pifont}\comment{provides \gls{ding}}
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{newglossaryentry}\marg{fleuron}\comment{label}
\marg{
  \field{name} = \marg{fleuron},
  \field{symbol} = \marg{\gls{ding}\marg{167}},
  \field{description} = \marg{typographic ornament}
}
\strut
\gls{newglossaryentry}\marg{pi}\comment{label}
\marg{
  \field{name} = \marg{Archimedes' constant},
  \field{symbol} = \marg{\gls{ensuremath}\marg{\cmd{pi}}},
  \field{category} = \marg{constant},
  \field{description} = \marg{Archimedes' constant}
}
\strut
\comment{post-link hook for 'constant' category:}
\cmd{newcommand}\marg{\csfmt{glsxtrpostlinkconstant}}\marg{\comment{} 
 \cmd{space} (\gls{glsentrysymbol}\marg{\gls{glslabel}})}
\strut
\cmd{begin}\marg{document}
A \gls{gls}\marg{fleuron} and \gls{gls}\marg{pi}.
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
\newcommand{\glsxtrpostlinkconstant}{\space (\glsentrysymbol{\glslabel})}%
A \gls{ex.fleuron} and \gls{ex.pi}.
\end{result}
The \code{fleuron} entry doesn't have the \field{category} key
explicitly set, so it defaults to \code{general}, but the \code{pi}
entry has the \field{category} set to \code{constant}, so it's
affected by the \idx{postlinkhook} for that category, which in this
case is given by \csfmt{glsxtrpostlinkconstant}. This hook is
defined to use \gls{glsentrysymbol} where the entry label is obtained
from \gls{glslabel}, which is set by \gls{gls} and similar commands.

\begin{important}
If \code{\gls{glssymbol}\marg{\gls{glslabel}}} had been used instead of
\code{\gls{glsentrysymbol}\marg{\gls{glslabel}}} it would've caused infinite
recursion! Don't use commands like \gls{glssymbol}, \gls{glsdesc} or
\gls{gls} in \idxpl{postlinkhook}.
\end{important}

This means that \code{\gls{gls}\marg{pi}} is automatically followed by the
symbol in parentheses, but \code{\gls{gls}\marg{fleuron}} isn't because it's
governed by the \code{general} \idx{postlinkhook} instead. Note that
the above is a simple example to demonstrate one of the uses of the
\field{category} field.

Here's a minor modification that sets the category for the
\code{fleuron} entry to \code{ornament} and creates another hook for
that.
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{pifont}\comment{provides \gls{ding}}
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{newglossaryentry}\marg{fleuron}\comment{label}
\marg{
  \field{name} = \marg{fleuron},
  \field{symbol} = \marg{\gls{ding}\marg{167}},
  \field{category} = \marg{ornament},
  \field{description} = \marg{typographic ornament}
}
\strut
\gls{newglossaryentry}\marg{pi}\comment{label}
\marg{
  \field{name} = \marg{pi},
  \field{symbol} = \marg{\gls{ensuremath}\marg{\cmd{pi}}},
  \field{category} = \marg{constant},
  \field{description} = \marg{Archimedes' constant}
}
\strut
\comment{post-link hook for 'ornament' category:}
\cmd{newcommand}\marg{\csfmt{glsxtrpostlinkornament}}\marg{\comment{}
 \cmd{space} (\gls{glsentrydesc}\marg{\gls{glslabel}})}
\strut
\comment{post-link hook for 'constant' category:}
\cmd{newcommand}\marg{\csfmt{glsxtrpostlinkconstant}}{\comment{}
 \cmd{space} (\gls{glsentrysymbol}\marg{\gls{glslabel}})}
\strut
\cmd{begin}\marg{document}
A \gls{gls}\marg{fleuron} and \gls{gls}\marg{pi}. Another \gls{gls}\marg{fleuron} and 
\gls{gls}\marg{pi}. Symbols: \gls{glssymbol}\marg{fleuron} and \gls{glssymbol}\marg{pi}.
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
\newcommand{\glsxtrpostlinkornament}{\space (\glsentrydesc{\glslabel})}%
\newcommand{\glsxtrpostlinkconstant}{\space (\glsentrysymbol{\glslabel})}%
A \gls{ex.fleuron} and \gls{ex.pi}. Another \gls{ex.fleuron} and 
\gls{ex.pi}. Symbols: \glssymbol{ex.fleuron} and \glssymbol{ex.pi}.
\end{result}
The \idx{postlinkhook} is repeated after every instance of \gls{gls}
or \gls{glssymbol} etc. In the case of the \code{ornament} category,
the description is appended in parentheses and in the case of the
\code{constant} category the symbol is appended. This results in
redundant repetition, especially with \verb|\glssymbol{pi}| which
displays the symbol followed by the symbol in parentheses.

It's more likely that the information only needs to be appended
after the \idx{firstuse}. You can determine if the
\idx{postlinkhook} follows the \idx{firstuse} of the entry using:
\nosecformatdef{glsxtrifwasfirstuse}
For example:
\begin{codeenv}
\cmd{newcommand}\marg{\csfmt{glsxtrpostlinkconstant}}\marg{\comment{}
 \gls{glsxtrifwasfirstuse}\marg{\cmd{space} (\gls{glsentrysymbol}\marg{\gls{glslabel}})}\marg{}\comment{}
}
\end{codeenv}
Commands that don't check or modify the \idx{firstuseflag}, such as
\gls{glssymbol}, always set \gls{glsxtrifwasfirstuse} so that it
expands to \meta{false}. This means that even if
\code{\gls{glssymbol}\marg{pi}}
is placed before the first instance of \code{\gls{gls}\marg{pi}} it still
won't be treated as the first use of that entry.

For convenience, there's a shortcut command:
\nosecformatdef{glsxtrpostlinkAddSymbolOnFirstUse}
So an alternative definition is:
\begin{codeenv}
\cmd{newcommand}\marg{\csfmt{glsxtrpostlinkconstant}}\marg{\comment{}
  \gls{glsxtrpostlinkAddSymbolOnFirstUse}
}
\end{codeenv}
This does nothing if the \field{symbol} field hasn't been set.

Similarly, there's a shortcut command for the description:
\nosecformatdef{glsxtrpostlinkAddDescOnFirstUse}
Version 1.31+ provides a combination:
\nosecformatdef{glsxtrpostlinkAddSymbolDescOnFirstUse}
If the \field{symbol} field is set, this displays the symbol
followed by a comma and space. The description is always displayed
at the end of the parenthetical material

Also from \sty{glossaries-extra} v1.31, there's a shortcut
command that you can use to define the \idx{postlinkhook}:
\nosecformatdef{glsdefpostlink} 
This is just a shortcut for:
\begin{codeenv}
\csfmt{csdef}\marg{glsxtrpostlink\meta{category}}\margm{definition}
\end{codeenv}
So the above document can be changed to:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{pifont}\comment{provides \gls{ding}}
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{newglossaryentry}\marg{fleuron}\comment{label}
\marg{
  \field{name} = \marg{fleuron},
  \field{symbol} = \marg{\gls{ding}\marg{167}},
  \field{category} = \marg{ornament},
  \field{description} = \marg{typographic ornament}
}
\strut
\gls{newglossaryentry}\marg{pi}\comment{label}
\marg{
  \field{name} = \marg{pi},
  \field{symbol} = \marg{\gls{ensuremath}\marg{\cmd{pi}}},
  \field{category} = \marg{constant},
  \field{description} = \marg{Archimedes' constant}
}
\strut
\comment{post-link hook for 'ornament' category:}
\gls{glsdefpostlink}\marg{ornament}\marg{\comment{}
  \gls{glsxtrpostlinkAddSymbolDescOnFirstUse}
}
\strut
\comment{post-link hook for 'constant' category:}
\gls{glsdefpostlink}\marg{constant}\marg{\comment{}
  \gls{glsxtrpostlinkAddSymbolOnFirstUse}
}
\strut
\cmd{begin}\marg{document}
Symbols: \gls{glssymbol}\marg{fleuron} and \gls{glssymbol}\marg{pi}.
A \gls{gls}\marg{fleuron} and \gls{gls}\marg{pi}. Another \gls{gls}\marg{fleuron} and 
\gls{gls}\marg{pi}.
\cmd{end}\marg{document}
\end{codeenv}
The result is now:
\begin{result}%
\glsdefpostlink{ornament}{\glsxtrpostlinkAddSymbolDescOnFirstUse}%
\glsdefpostlink{constant}{\glsxtrpostlinkAddSymbolOnFirstUse}%
Symbols: \glssymbol{ex.fleuron} and \glssymbol{ex.pi}.
A \gls{ex.fleuron} and \gls{ex.pi}. Another \gls{ex.fleuron} and
\gls{ex.pi}.
\end{result}

\section{Glossary Name and Description Formatting}
\label{sec:glossname}

When an entry's definition is displayed within
\gls{printunsrtglossary} or \gls{glsxtrglossentry} (see
\sectionref{sec:displaygloss}), the value of the \field{name} field
is encapsulated by
\nosecformatdef{glsnamefont}
This may be overridden with the \catattr{glossnamefont} attribute
whose value must be the name (without the leading backslash) of a
control sequence that takes a single argument. If set, this control
sequence is used instead of \gls{glsnamefont}.

By default \gls{glsnamefont} simply does its argument, but the
glossary style may apply additional formatting. For example, the
\glostyle{list} styles place the name in the optional argument of
\csfmt{item} within the \envfmt{description} environment. With the
standard document classes, this renders the name in bold, but other
classes may apply different formatting.

The \glostyle{tree} styles encapsulate the name within:
\nosecformatdef{glstreenamefmt}
which does \code{\gls{textbf}\margm{text}} by default. So, for
example, if \gls{glsnamefont} is redefined to use \gls{emph} and
the \glostyle{tree} style is used, then the name will appear in
italic bold (assuming the surrounding font is upright).
The letter group headings are encapsulated within:
\nosecformatdef{glstreegroupheaderfmt}
which defaults to \code{\gls{glstreenamefmt}\margm{text}}, so if you
need to redefine \gls{glstreenamefmt} you may also need to redefine
\gls{glstreegroupheaderfmt} if the headers should have different formatting.

Case-changing can be automatically applied to the name with the
\catattr{glossname} attribute, which may take one of the values:
\code{firstuc} (convert the first letter to \idx{uppercase}), \code{title}
(convert to title case) or \code{uc} (convert to all capitals).
Alternatively, if you're using \bibgls, you can use the
\csopt{name-case-change} resource option.

The description is similarly governed by the
\catattr{glossdescfont}, which again should have the name (without
the leading backslash) of a control sequence that takes a single
argument. There's no equivalent of \gls{glsnamefont} for the
description but the glossary or abbreviation style may apply
particular formatting, which will be in addition to the formatting
command given by \catattr{glossdescfont} (if set).

Case-changing is also available for descriptions with the
\catattr{glossdesc} attribute, but this only has two allowed values:
\code{firstuc} (convert the first letter to \idx{uppercase}) and
\code{title} (convert to title case). 
Alternatively, if you're using \bibgls, you can use the
\csopt{description-case-change} resource option.

\section{Post-Name and Post-Description Hooks}
\label{sec:postfieldhooks}

Punctuation can automatically be appended to the description in the
glossary with the \styopt{postpunc} option.  (Note that the
unstarred form of \gls{longnewglossaryentry} interferes with this
option. Use the starred form \gls{longnewglossaryentry*} instead.)
The post-description punctuation (if set) is placed after the
\glslink{postdescriptionhook}{post-description category hook} (if
provided). Both the post-description category hook and the
post-description punctuation are implemented by
\nosecformatdef{glspostdescription}
The \sty{glossaries-extra-stylemods}
package (which can be loaded with the \styopt{stylemods} option)
patches the predefined styles provided with the base
\sty{glossaries} package to ensure that the styles all use
\gls{glspostdescription}.


\chapter{Problematic Areas}
\label{sec:problems}

There are some places where the use of commands like \gls{gls} can
cause problems. These are listed below, with workarounds provided.

\section{Headings and Captions}
\label{sec:headings}

\section{Nesting}
\label{sec:nested}

\section{Formatting Commands that Need Direct Access to the Text}
\label{sec:expandedfmt}

If you want to redefine any of the formatting commands
\gls{glstextformat}, \gls{glsxtrregularfont} or
\gls{glsxtrabbreviationfont}, remember that their argument isn't the
actual text but consists of intermediary commands
that determine the required text and any inner formatting, such as
the formatting applied by abbreviation styles.

With the \glsopt{hyperoutside} setting on, the outermost level
will be the command to apply the hyperlink with \gls{glstextformat}
(or the equivalent provided by \catattr{textformat}) 
inside the hyperlink text. (If hyperlinks aren't enabled the outer
command simply does the hyperlink text.)

With \glsopt[false]{hyperoutside}, the outermost level will be
\gls{glstextformat} (or equivalent) with the command that applies
the hyperlink inside the formatting argument.

The next level down sets up the abbreviation styles for the given
category (if appropriate). If the entry isn't an abbreviation or is
an abbreviation classified as regular then
\gls{glsxtrregularfont} is applied to the command that governs how
regular entries are formatted. Otherwise \gls{glsxtrabbreviationfont}
is applied to the command that governs how abbreviations are
formatted.

Finally, there are tests applied to determine if this is the
\idx{firstuse}, if the plural is required, if any case-changing is
required, if the final optional argument has been given, or if a
command such as \gls{glssymbol} has been used.  These tests
determine which field to obtain the \idx{link-text} from. With
abbreviations, any formatting required by the abbreviation style is
finally performed.

This makes it very difficult to apply a formatting command that
needs direct access to the actual text that needs to be displayed.
One possible method is to use:
\nosecformatdef{GlsXtrExpandedFmt}
which first (protected) fully expands \meta{text} and then performs
\meta{cs}\margm{expanded text} where \meta{cs} is a control
sequence. For example, the \isty{soul} package provides the command
\gls{ul} to underline text, but it needs to be able to parse its
argument to work. If I simply try to change the standard
\gls{underline} to \gls{ul} in the earlier example from
\sectionref{sec:glsformats}:
\begin{codeenv}
\cmd{renewcommand}\marg{\gls{glsxtrregularfont}}[1]\marg{\cmd{ul}\marg{\gls{param}1}}
\end{codeenv}
then this causes the error:
\begin{verbatim}
! Package soul Error: Reconstruction failed.
\end{verbatim}
Instead I need:
\begin{codeenv}
\cmd{renewcommand}\marg{\gls{glsxtrregularfont}}[1]\marg{\gls{GlsXtrExpandedFmt}\cmd{ul}\marg{\gls{param}1}}
\end{codeenv}
\emph{and also} \gls{ding} now needs protection:
\begin{codeenv}
\gls{newglossaryentry}\marg{fleuron}\comment{label}
\marg{
  \field{name} = \marg{fleuron},
  \field{symbol} = \marg{\gls{protect}\gls{ding}\marg{167}},
  \field{category} = \marg{ornament},
  \field{description} = \marg{typographic ornament}
}
\end{codeenv}

\section{Buffering Changes to the First Use Flag}
\label{sec:buffering}

The \sty{soul} commands, described above, also have problems if the
\idx{firstuseflag} is switched off within the argument. This can be
demonstrated with the following:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\cmd{usepackage}\marg{soul}
\cmd{usepackage}\marg{glossaries-extra}
\gls{newabbreviation}\marg{ssl}\marg{SSL}\marg{Secure Sockets Layer}
\cmd{begin}\marg{document}
\cmd{ul}\marg{Some text about \gls{gls}\marg{ssl}.}
\cmd{end}\marg{document}
\end{codeenv}
This produces the somewhat confusing error message:
\begin{verbatim}
Glossary entry `{ssl}' has not been defined.
\end{verbatim}
Enclosing \code{\gls{gls}\marg{ssl}} inside the argument of \csfmt{mbox} 
changes the error message to:
\begin{verbatim}
! Package soul Error: Reconstruction failed.
\end{verbatim}
The only way to avoid an error is to switch on the \gls{glsunset}
buffering, which modifies the internal command that normally changes
the \idx{firstuseflag}. Instead, the entry label is simply stored in
an internal list. The buffering is switched on with:
\nosecformatdef{GlsXtrStartUnsetBuffering}
The unstarred form of this command may result in multiple
occurrences of an entry in the buffer's internal list. The starred form,
which only adds an entry's label to the list if not already present,
is better if the list needs to contain unique items.

The current buffer can be iterated over using;
\nosecformatdef{GlsXtrForUnsetBufferedList}
where \meta{cs} is a command that takes a single argument (the
entry's label). Finally, entries in the buffer can be unset and the
buffer cleared with:
\nosecformatdef{GlsXtrStopUnsetBuffering}

The above example will work if it's changed to:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\cmd{usepackage}\marg{soul}
\cmd{usepackage}\marg{glossaries-extra}
\gls{newabbreviation}\marg{ssl}\marg{SSL}\marg{Secure Sockets Layer}
\cmd{begin}\marg{document}
\gls{GlsXtrStartUnsetBuffering}
\cmd{ul}\marg{Some text about \cmd{mbox}\marg{\gls{gls}\marg{ssl}}.}
\gls{GlsXtrStopUnsetBuffering}
\cmd{end}\marg{document}
\end{codeenv}
Note the need for \csfmt{mbox}, which can cause a problem with
line-breaking. Another problem is that if the entry is referenced
multiple times within the same buffer, each use of \gls{gls} (or its
\idxpl{variant}) will be treated as the \idx{firstuse}.

Another workaround is to use \glsopt{textformat} with a command that
uses \gls{GlsXtrExpandedFmt} (see \sectionref{sec:expandedfmt}). For
example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\cmd{usepackage}\marg{soul}
\cmd{usepackage}\marg{glossaries-extra}
\strut
\cmd{newrobustcmd}\marg{\cmd{gul}}[1]\marg{\comment{}
  \marg{\comment{}
   \cmd{def}\gls{glsxtrabbreviationfont}\gls{param}\gls{param}1\marg{\gls{GlsXtrExpandedFmt}\marg{\cmd{ul}}\marg{\gls{param}\gls{param}1}}\comment{}
   \cmd{def}\gls{glsxtrregularfont}\gls{param}\gls{param}1\marg{\gls{GlsXtrExpandedFmt}\marg{\cmd{ul}}\marg{\gls{param}\gls{param}1}}\comment{}
   \gls{param}1\comment{}
  }%
}
\strut
\gls{newabbreviation}\marg{ssl}\marg{SSL}\marg{Secure Sockets Layer}
\cmd{begin}\marg{document}
\cmd{ul}\marg{Some text about }\gls{gls}\oarg{\glsopt{textformat}=gul}\marg{ssl}.
\cmd{end}\marg{document}
\end{codeenv}

\chapter{Incorporating \bibgls}
\label{sec:bib2gls}

\bibliographystyle{plain}
\bibliography{bib2gls-cite}

\printunsrtglossary*
 [style=treegroup,title={Command Summary},nonumberlist]
{%
 \renewcommand*{\printunsrtglossaryentryprocesshook}[1]{%
   \glsifcategory{#1}{command}{}{\printunsrtglossaryskipentry}%
 }%
 \glssetcategoryattribute{command}{glossdesc}{firstuc}%
 \renewcommand*{\csfmtfont}[1]{\texttt{\color{cs}#1}}%
 \renewcommand{\glstreenamefmt}{\texttt}%
 \renewcommand{\glstreegroupheaderfmt}{\textbf}%
 \renewcommand{\glstreesubitem}{\glspar\parindent=2em\hangindent2em}%
 \renewcommand{\glstreepredesc}{\glsadd{\glscurrententrylabel}%
   \nopagebreak\glstreesubitem}%
 \glsdefpostname{command}{\glsentryuseri{\glscurrententrylabel}}%
 \glsdefpostdesc{command}{.\nopagebreak\glstreesubitem
  \Glsentryuserii{\glscurrententrylabel}.%
  \glspar\medskip}%
}

\renewcommand*{\glstarget}[2]{%
 \glsifcategory{#1}{command}{#2}%
 {%
   \glsifcategory{#1}{standalone}{#2}%
   {\glsdohypertarget{\glolinkprefix#1}{#2}}%
 }%
}
\renewcommand{\glstreeitem}{\par\parindent0pt}
\renewcommand*{\glsxtrbookindexprelocation}[1]{%
  \glsxtrifhasfield{location}{#1}%
  {\enspace
   \textcolor{lightgray}{\nolinebreak\cleaders\hbox to .5em{\hss.\hss}\hfill}%
   \enspace}%
  {}%
}
\renewcommand*{\printunsrtglossaryentryprocesshook}[1]{%
  \glsxtriflabelinlist{\glscategory{#1}}{standalone,hierarchical,homograph}%
  {\printunsrtglossaryskipentry}{}%
}%
\printunsrtglossary[style=bookindex,title=Index,subentrycounter=false]
\end{document}
