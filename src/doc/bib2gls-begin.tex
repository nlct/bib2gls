% arara: xelatex
% arara: bib2gls: {group: on}
% arara: bibtex
% arara: xelatex
% arara: xelatex if found ("log", "Rerun")
\documentclass[titlepage=false,fontsize=12pt,captions=tableheading]{scrreprt}

\usepackage[no-math]{fontspec}
\setmainfont{Linux Libertine O}

\newfontface\cyrillicmono{FreeMono}[Scale=MatchLowercase]
\newcommand{\textcyrillicmono}[1]{{\cyrillicmono #1}}

\usepackage[x11names]{xcolor}
\usepackage{upquote}
\usepackage{hologo}
\usepackage{pifont}
\usepackage{graphicx}
\usepackage{datetime2}
\usepackage{siunitx}

\usepackage{xr-hyper}
\usepackage[hidelinks]{hyperref}
\usepackage[record,nostyles,stylemods={bookindex},style=index]{glossaries-extra}

\definecolor{field}{named}{DarkSlateGray4}
\definecolor{cs}{named}{DarkSeaGreen4}
\definecolor{styopt}{named}{DarkOrchid4}
\definecolor{entry}{named}{SteelBlue4}
\definecolor{comment}{named}{gray}
\definecolor{attribute}{named}{Purple4}
\definecolor{style}{named}{Blue4}

\newcommand{\dhyphen}{%
 \texorpdfstring
 {\discretionary{}{}{}\texttt{-}}%
 {-}%
}

\renewrobustcmd{\-}{%
 \discretionary
 {{\rmfamily\char\ifnum\hyphenchar\font<0
  \defaulthyphenchar\else\hyphenchar\font\fi
 }}%
 {}{}%
}

\setabbreviationstyle[common]{short-nolong}
\setabbreviationstyle[markwordsexample]{long-hyphen-short-hyphen}
\glssetcategoryattribute{markwordsexample}{markwords}{true}
\GlsXtrEnableInitialTagging{taggingexample}{\itag}
\glssetcategoryattribute{discardperiodexample}{discardperiod}{true}
\glssetcategoryattribute{initialism}{insertdots}{true}
\glssetcategoryattribute{initialism}{discardperiod}{true}
\glssetcategoryattribute{initialism}{retainfirstuseperiod}{true}
\setabbreviationstyle[initialism]{short-long}
\setabbreviationstyle[abbrvtrans]{long-short-user}

\newcommand{\bibglspassim}{}
\newcommand{\bibglsseealsosep}{\par\hangindent .75em\parindent .75em\relax}

\GlsXtrLoadResources[
 src={bib2gls},
 max-loc-diff=3,
 entry-type-aliases={dualindexentry=entry},
 field-aliases={note=user2},
 symbol-sort-fallback={name},
 break-at={none},
 sort-replace={{,? +}{|},{\glshex2423}{ },
  {([a-zA-Z])\string\.}{\glscapturedgroup1}}
]

\DTMsavetimestamp{creation}{2017-01-20T15:39:00Z}

\IfFileExists{../java/Bib2Gls.java}
{
  \DTMsavefilemoddate{moddate}{../java/Bib2Gls.java}
}
{
  \DTMsavenow{moddate}
}

\newcommand{\bibgls}{\appfmt{bib2gls}}

\newcommand*{\BibTeX}{\hologo{BibTeX}}
\newcommand*{\eTeX}{\hologo{eTeX}}
\newcommand*{\XeLaTeX}{\hologo{XeLaTeX}}
\newcommand*{\LuaLaTeX}{\hologo{LuaLaTeX}}
\newcommand*{\pdfLaTeX}{\hologo{pdfLaTeX}}

\newcommand*{\ctanfile}[2]{%
 \href{http://mirrors.ctan.org/macros/latex/contrib/#1/#2}{\nolinkurl{#2}}%
}

\newcommand{\qt}[1]{``#1''}

\newcommand{\qtt}[1]{\qt{\,\texttt{#1}\,}}

\newcommand{\incorrect}{\marginpar{\textcolor{red}{\ding{55}}}}
\newcommand{\correct}{\marginpar{\textcolor{green}{\ding{52}}}}

\newenvironment{result}%
{%
 \renewcommand{\glslinkpresetkeys}{\setkeys{glslink}{hyper=false,local}}%
 \begin{quotation}%
 \marginpar
  [\raisebox{-2.5ex}{\ding{43}}]%
  {\raisebox{-2.5ex}{\reflectbox{\ding{43}}}}%
 \ignorespaces
}
{\end{quotation}\ignorespacesafterend}

\newcommand{\dequals}{%
 \texorpdfstring
 {\discretionary{}{}{}\texttt{=}\discretionary{}{}{}}%
 {=}%
}

\newcommand{\dcomma}{%
 \texorpdfstring
 {\texttt{,}\discretionary{}{}{}}%
 {,}%
}

\newcommand{\dcolon}{%
 \texorpdfstring
 {\texttt{:}\discretionary{}{}{}}%
 {:}%
}

\pdfstringdefDisableCommands{%
  \def\dhyphen{-}%
  \def\dcolon{:}%
  \def\dcomma{,}%
  \def\dequals{,}%
  \let\-\empty
}

\newcommand*{\csfmtfont}[1]{\texttt{#1}}

\newcommand*{\csfmt}[1]{%
 \texorpdfstring
 {\csfmtfont{\char`\\ #1}}%
 {\string\\#1}%
}

\newcommand*{\appfmt}[1]{\texorpdfstring{\texttt{#1}}{#1}}
\newcommand*{\styfmt}[1]{\texorpdfstring{\textsf{#1}}{#1}}
\newcommand*{\envfmt}[1]{\texorpdfstring{\textsf{#1}}{#1}}
\newcommand*{\optfmt}[1]{\texorpdfstring{\texttt{#1}}{#1}}
\newcommand*{\csoptfmt}[1]{\texorpdfstring{\textcolor{cs}{\optfmt{#1}}}{#1}}
\newcommand*{\styoptfmt}[1]{\texorpdfstring{\textcolor{styopt}{\optfmt{#1}}}{#1}}
\newcommand*{\fieldfmt}[1]{\texorpdfstring{\texttt{\color{field}#1}}{#1}}
\newcommand*{\entryfmt}[1]{\texorpdfstring{\texttt{\color{entry}#1}}{#1}}
\newcommand*{\atentryfmt}[1]{\entryfmt{@#1}}
\newcommand*{\abbrstylefmt}[1]{\texorpdfstring{\textsf{\color{style}#1}}{#1}}
\newcommand*{\glostylefmt}[1]{\texorpdfstring{\textsf{#1}}{#1}}
\newcommand*{\catattrfmt}[1]{\texorpdfstring{\textsf{\color{attribute}#1}}{#1}}
\newcommand*{\counterfmt}[1]{\texorpdfstring{\textsf{#1}}{#1}}
\newcommand*{\filefmt}[1]{\texorpdfstring{\texttt{#1}}{#1}}
\newcommand*{\metafilefmt}[3]{%
  \filefmt{#1}\discretionary{}{}{}\meta{#2}\discretionary{}{}{}\filefmt{#3}%
}

\newcommand*{\extfmt}[1]{\filefmt{.#1}}%

\newcommand*{\argor}{\texorpdfstring{\protect\textbar}{|}}

\newrobustcmd*{\texmeta}[1]{{\normalfont\normalcolor$\langle$\emph{#1}$\rangle$}}

\newcommand*{\meta}[1]{%
 \texorpdfstring{\ifmmode\text{\texmeta{#1}}\else\texmeta{#1}\fi}{#1}%
}

\newcommand*{\oarg}[1]{\discretionary{}{}{}[#1]}
\newcommand*{\oargm}[1]{\oarg{\meta{#1}}}

\newcommand*{\marg}[1]{\texorpdfstring
 {\discretionary{}{}{}\char`\{#1\char`\} }%
 {\{#1\}}%
}

\newcommand*{\margm}[1]{\marg{\meta{#1}}}

\newcommand{\switcharg}{}
\newcommand{\switchalt}{}

\makeatletter
\newcommand{\code}[1]{\texorpdfstring{{\ttfamily\obeyspaces #1}}{#1}}
\newenvironment{codeenv}
 {%
 \renewcommand{\glslinkpresetkeys}{\setkeys{glslink}{noindex}}%
   \def\cmd{\char`\\}%
   \def\comment##1{\textcolor{comment}{\%\ ##1}}%
   \renewcommand*{\styfmt}[1]{##1}%
   \renewcommand*{\catattrfmt}[1]{\textcolor{attribute}{##1}}%
   \renewcommand*{\abbrstylefmt}[1]{\textcolor{style}{##1}}%
   \renewcommand*{\csfmtfont}[1]{\textcolor{cs}{##1}}%
    \begin{flushleft}\textcolor{lightgray}{\hrulefill}\par\nopagebreak
     \medskip\nopagebreak
     \ttfamily\obeylines\frenchspacing\@vobeyspaces}
 {\nopagebreak\textcolor{lightgray}{\hrulefill}%
  \end{flushleft}\ignorespacesafterend}
\makeatother

\newcommand{\primary}{\emph}
\newcommand{\primaryloc}{\hyperbf}

\newcommand{\pidx}[1][]{\gls[textformat=primary,format=primaryloc,#1]}
\newcommand{\pidxpl}[1][]{\glspl[textformat=primary,format=primaryloc,#1]}
\newcommand{\pIdx}[1][]{\Gls[textformat=primary,format=primaryloc,#1]}
\newcommand{\pIdxpl}[1][]{\Glspl[textformat=primary,format=primaryloc,#1]}

\newcommand{\idx}{\gls}
\newcommand{\idxpl}{\glspl}
\newcommand{\Idx}{\Gls}
\newcommand{\Idxpl}{\Glspl}

\newcommand{\ext}{\gls}

\newcommand*{\iext}[1]{%
 \glsxtrtitleorpdforheading{\idx{#1}}{.#1}{\extfmt{#1}}%
}

\newcommand{\sty}{\gls}

\newcommand*{\isty}[1]{%
  \texorpdfstring{\idx{#1}}{#1}%
}

\newcommand*{\env}[1]{%
  \texorpdfstring{\idx{env.#1}}{#1}%
}

\newcommand*{\abbrstyle}[1]{%
  \texorpdfstring{\idx{#1}}{#1}%
}

\newcommand*{\glostyle}[1]{%
  \texorpdfstring{\idx{glostyle.#1}}{#1}%
}

\newcommand*{\catattr}[1]{%
  \texorpdfstring{\idx{#1}}{#1}%
}

\newcommand*{\counter}[1]{%
  \texorpdfstring{\idx{ctr.#1}}{#1}%
}

\newcommand*{\styopt}[2][]{%
  \texorpdfstring%
  {%
    \gls{styopt.#2}\styoptfmt{\ifblank{#1}{}{\dequals\marg{#1}}}%
  }%
  {#2\ifblank{#1}{}{=#1}}%
}

\newcommand*{\keyvallist}{%
 \texorpdfstring
 {key\dequals value list}%
 {key=value list}%
}

\newcommand{\nosecformatdef}[1]{%
  \begin{definition}
   \gls[format=primaryloc]{#1}%
   \glsentryuseri{#1}%
  \end{definition}\ignorespaces
}

\newcommand*{\cs}{\gls}

\newcommand*{\ics}{\cs}

\newcommand*{\icswithargs}[2][]{\cs{#2}\glsentryuseri{#2}}

\newcommand*{\postdeschook}[2][]{%
 \glslink[#1]{idx.glsxtrpostdesccategory}{\csfmt{glsxtrpostdesc#2}}}

\newcommand*{\postlinkhook}[2][]{%
 \glslink[#1]{idx.glsxtrpostlinkcategory}{\csfmt{glsxtrpostlink#2}}}


\glsxtrnewgls{file.}{\exfile}

\newcommand*{\csopt}[2][]{\gencsopt{#1}{opt}{#2}}%
\newcommand*{\glsopt}[2][]{\gencsopt{#1}{gls}{#2}}%
\newcommand*{\glsaddopt}[2][]{\gencsopt{#1}{glsadd}{#2}}%

\newcommand*{\gencsopt}[3]{%
  \texorpdfstring%
  {%
    \gls{#2.#3}%
    \csoptfmt{\ifblank{#1}{}{\dequals\marg{#1}}}%
  }%
  {#3\ifblank{#1}{}{=#1}}%
}

\newcommand*{\field}[1]{%
 \texorpdfstring
 {\gls{field.#1}}%
 {#1}%
}

\newcommand*{\atentry}[2][]{%
 \texorpdfstring
 {\gls[#1]{entry.#2}}%
 {#2}%
}

\newrobustcmd{\longswitch}{\string-{}\string-}

\newcommand*{\longargfmt}[1]{%
 \texorpdfstring{\texttt{\longswitch #1}}%
 {\string-\string-#1}%
}

\newcommand*{\shortargfmt}[1]{%
 \texorpdfstring{\texttt{\string-#1}}%
 {\string-#1}%
}

\newcommand*{\longarg}[1]{%
  \texorpdfstring
  {\gls{switch.#1}}%
  {\string-\string-#1}%
}

\definecolor{defbackground}{rgb}{1,1,0.75}

\newsavebox\borderedboxcontents
\newlength\borderedboxwidth

\newenvironment{definition}%
{%
  \setlength{\fboxsep}{4pt}\setlength{\fboxrule}{1.25pt}%
  \begin{lrbox}{\borderedboxcontents}%
   \setlength\borderedboxwidth\linewidth
   \addtolength\borderedboxwidth{-2\fboxrule}%
   \addtolength\borderedboxwidth{-2\fboxsep}%
   \begin{minipage}{\borderedboxwidth}
   \flushleft\ttfamily\ignorespaces
}%
{%
   \end{minipage}%
  \end{lrbox}\par\medskip\noindent
  \fcolorbox{black}{defbackground}{\usebox\borderedboxcontents}%
  \medskip\par\noindent
  \ignorespacesafterend
}

\newenvironment{important}{%
  \setlength{\fboxrule}{4pt}%
  \setlength\borderedboxwidth{\linewidth}%
  \addtolength\borderedboxwidth{-2\fboxsep}%
  \addtolength\borderedboxwidth{-2\fboxrule}%
  \begin{lrbox}{\borderedboxcontents}%
    \begin{minipage}{\borderedboxwidth}%
    \raggedright
    \setlength\parindent{1em}%
    \noindent\ignorespaces
}%
{%
    \end{minipage}%
  \end{lrbox}%
  \par\vskip10pt\noindent
  \fcolorbox{red}{white}{\usebox{\borderedboxcontents}}\par\vskip10pt
  \noindent\ignorespacesafterend
}

\newcommand*{\sectionref}[1]{section~\ref{#1}}
\newcommand*{\Sectionref}[1]{Section~\ref{#1}}

\pagestyle{headings}

\newcommand{\glossarytitle}{Index}
\externaldocument{bib2gls}

\newcommand{\addr}[1]{\\\href{https://www.#1/}{\nolinkurl{#1}}}
\title{\bibgls\ and \styfmt{glossaries-extra}: A Guide for Beginners}
\author{Nicola Talbot\addr{dickimaw-books.com}}
\date{\DTMusedate{moddate}}

\makeatletter
\begingroup
 \renewcommand{\addr}[1]{}
 \let\texorpdfstring\@secondoftwo
 \DTMsetstyle{pdf}
 \protected@edef\x{\endgroup
   \noexpand\hypersetup{%
     pdfinfo={
       Title={\@title},
       Author={\@author},
       CreationDate={\DTMuse{creation}},
       ModDate={\DTMuse{moddate}},
     }%
   }%
 }\x

\makeatother

\begin{document}
\maketitle
\pagenumbering{alph}
\thispagestyle{empty}

\begin{abstract}
This document is an introductory guide to \bibgls\ and the
\sty{glossaries-extra} package to help you get started. For
further information, including more complex commands and settings,
see the main \bibgls\ user manual (\filefmt{bib2gls.pdf},
in the same directory as this document),
the \isty{glossaries-extra} user manual,
(distributed with the \sty{glossaries-extra}
package~\cite{glossaries-extra})
and the \isty{glossaries} user manual
(distributed with the \sty{glossaries} package~\cite{glossaries}).

The \sty{glossaries} package is the \emph{base} package. The 
\sty{glossaries-extra} package internally loads the \sty{glossaries} package 
and extends it, providing extra options or modifying the base
commands to increase flexibility. If you want to use \bibgls, you
must load \sty{glossaries-extra}, which provides the interface
required by \bibgls.
This document doesn't cover the other indexing methods described in
the base package.
\end{abstract}

\clearpage
\pagenumbering{roman}
\tableofcontents

\clearpage
\pagenumbering{arabic}

\chapter{Introduction}
\label{sec:beginintro}

The \sty{glossaries} package provides a way of defining terms,
notation or abbreviations that can then be used in the document.
This ensures consistent naming and formatting. (With the help of the
\sty{hyperref} package, it's also possible to create hyperlinks from
the reference to a place in the document that provides a definition
of the term, but more about that later.) Each entry (term,
notation or abbreviation) is defined using:
\nosecformatdef{newglossaryentry}
Here's a simple example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries}
\strut
\gls{newglossaryentry}\marg{duck}\comment{label}
\marg{\comment{ information about this term:}
  \field{name}=\marg{duck},\comment{ display name}
  \field{description}=\marg{a waterbird with webbed feet}\comment{description}
}
\strut
\gls{newglossaryentry}\marg{goose}\comment{ label}
\marg{\comment{information about this term:}
  \field{name}=\marg{goose},\comment{display name}
  \field{plural}=\marg{geese},\comment{plural form}
  \field{description}=\marg{a large waterbird with a long neck, short legs,
   webbed feet and a short broad bill}
}
\strut
\cmd{begin}\marg{document}
The pond contained a \gls{gls}\marg{duck} (\gls{glsentrydesc}\marg{duck}) and 
a \gls{gls}\marg{goose} (\gls{glsentrydesc}\marg{goose}). \gls{Glspl}\marg{duck} and 
\gls{glspl}\marg{goose} are fowl.
\cmd{end}\marg{document}
\end{codeenv}
The resulting text is:
\begin{result}
The pond contained a \gls{ex1.duck} (\glsentrydesc{ex1.duck}) and 
a \gls{ex1.goose} (\glsentrydesc{ex1.goose}). \Glspl{ex1.duck} and
\glspl{ex1.goose} are fowl.
\end{result}
For convenience, the text produced by commands such as \cs{gls} is called the 
\pidx{link-text} (even if there are no hyperlinks).

The first argument of \gls{newglossaryentry} is a label that
uniquely identifies the term (see \sectionref{sec:labels}). The
second argument is a comma-separated list of
\meta{setting}\dequals\meta{value} assignments.  Each \meta{setting}
is referred to as a \qt{key} in the \isty{glossaries} manual or as a
\qt{field} in the \bibgls\ manual. A list of the available base keys
can be found in the \isty{glossaries} user manual.  The
\isty{glossaries-extra} package provides some additional keys that
are described in the \sty{glossaries-extra} manual. The \bibgls\
user manual summarises all keys (fields) in \sectionref{sec:fields}.

\begin{important}
If the field value contains commas or equal signs the value must be grouped
to hide those characters from the \meta{key}\dequals\meta{value} parser.
\end{important}

The two main keys are \field{name} and \field{description}. The
\field{name} identifies how the term should be displayed in the
glossary (see \sectionref{sec:printgloss}). It also provides the
default singular term, if not explicitly given. The default plural
is obtained by appending \qt{s} to the singular form. If this isn't
correct (as with \qt{geese}), then the plural form can be specified
with the \field{plural} key.

The description (set with the \field{description} key) is usually
only displayed in the glossary, but you can display it in the text
using:
\nosecformatdef{glsentrydesc}
as in the above example. This simply expands to the value of the
\field{description} field (or does nothing if there's no entry
associated with the given label).

The main command used to reference a term is:
\nosecformatdef{gls}
In the above example, \gls{gls} just displays the singular form, but you
can provide alternative text to use the first time a term is
referenced (see \sectionref{sec:firstuse}). The plural form is obtained with
the \pidx{variant} command:
\nosecformatdef{glspl}
There are other \idxpl{variant} of \gls{gls} that perform
case-changing.
If you want to start a sentence with an entry then you can use:
\nosecformatdef{Gls}
for the singular form and
\nosecformatdef{Glspl}
for the plural form. For all capitals, use:
\nosecformatdef{GLS}
for the singular form and
\nosecformatdef{GLSpl}
for the plural form. Any mention of \gls{gls} and its
\idxpl{variant} in this guide or in the user manuals means that the
comments applied to \gls{gls} also apply to the plural and
case-changing versions.

The \meta{insert} optional argument is provided to insert additional material.
For example:
\begin{codeenv}
The \gls{gls}\marg{goose} liked the \gls{gls}\marg{duck}['s] hat.
\end{codeenv}
which produces (assuming the above definitions):
\begin{result}
The \gls{ex1.goose} liked the \gls{ex1.duck}['s] hat.
\end{result}
In some cases, there may not be a noticeable difference between the
above and the following:
\begin{codeenv}
The \gls{gls}\marg{goose} liked the \gls{gls}\marg{duck}'s hat.
\end{codeenv}
It depends on other settings, such as whether or not hyperlinks have
been enabled. (The inserted material is commonly moved inside the
hyperlink.) Take care if you need a literal open square bracket
following \code{\cs{gls}\margm{label}} as you need to prevent it from being
interpreted as the optional \meta{insert} argument. For example:
\begin{codeenv}
The \gls{gls}\marg{goose} liked the \gls{gls}\marg{duck}\marg{['s]} hat.
\end{codeenv}
which now produces:
\begin{result}
The \gls{ex1.goose} liked the \gls{ex1.duck}{['s]} hat.
\end{result}
An alternative in this case could be to define:
\begin{codeenv}
\cmd{newcommand}*\marg{\cmd{missing}}[1]\marg{[\gls*{param}1]}
\end{codeenv}
and then use:
\begin{codeenv}
The \gls{gls}\marg{goose} liked the \gls{gls}\marg{duck}\cmd{missing}\marg{'s} hat.
\end{codeenv}
This conveniently hides the open square bracket from \cs{gls}.

\begin{important}
Commands like \gls{gls} are \idx{robust}. Commands like
\gls{glsentrydesc} are \idx{expandable}. (See \sectionref{sec:robust}.)
If you want the entry to appear in a PDF bookmark, you need to use an 
expandable command to reference it.
\end{important}

There are some helper commands that internally use
\gls{newglossaryentry}, such as \cs{newabbreviation} (described in
\sectionref{sec:abbreviations}) and \cs{glsxtrnewsymbol} (described
in \sectionref{sec:symbols}). If the description contains explicit paragraph
breaks then:
\nosecformatdef{longnewglossaryentry}
is required instead.

\section{Labels}
\label{sec:labels}

The label used to identify the entry can't contain any special characters, such
as \gls{commentchar} (percent), \gls{ampchar} (ampersand), \gls{param} (hash),
\gls{mshiftchar} (dollar), or \gls{nbspchar} (tilde).  Be careful of packages
that make other characters active (such as \isty{babel} with its shortcuts). If
you are using \isty{inputenc}, this also includes extended Latin characters and
characters from other scripts. If you want to include UTF-8 characters in the
label then you must use a \TeX\ engine with native Unicode support (that is,
\XeLaTeX\ or \LuaLaTeX).

For example, with no UTF-8 support (not even \sty{inputenc}):
\begin{codeenv}
\gls{newglossaryentry}\marg{elite}\comment{label (no UTF-8 support)}
\marg{
  \field{name} = \marg{\marg{\gls{acute}e}lite},
  \field{description} = \marg{group of people regarded as
  the best of a particular society or organisation}
}
\end{codeenv}
or with \sty{inputenc}:
\begin{codeenv}
\gls{newglossaryentry}\marg{elite}\comment{label (UTF-8 not natively supported)}
\marg{
  \field{name} = \marg{élite},
  \field{description} = \marg{group of people regarded as
  the best of a particular society or organisation}
}
\end{codeenv}
Whereas with \XeLaTeX\ or \LuaLaTeX\ you can do:
\begin{codeenv}
\gls{newglossaryentry}\marg{élite}\comment{label (UTF-8 natively supported)}
\marg{
  \field{name} = \marg{élite},
  \field{description} = \marg{group of people regarded as
  the best of a particular society or organisation}
}
\end{codeenv}

You may have noticed the grouping of the initial (accented) letter
in the \gls{ASCII} example (\code{\marg{\gls{acute}e}lite}). This is
necessary to ensure that the first-letter case-changing commands,
such as \ics{Gls}, work. It also used to be required around the
\qtt{é} with \sty{inputenc}, but if you have up-to-date versions of
\sty{glossaries} and \sty{datatool} then it should no longer be
necessary. No special treatment is needed with \XeLaTeX\ or
\LuaLaTeX\ where \qtt{é} is a single token.

If you can't use extended characters in the label (because you're
not using \XeLaTeX\ or \LuaLaTeX), then simply stripping the accents
to create an \gls{ASCII} alternative may be sufficient, but take
care if this may cause a conflict. For example:
\begin{codeenv}
\gls{newglossaryentry}\marg{resume}\comment{label}
\marg{
  \field{name} = \marg{resume},
  \field{description} = \marg{continue after an interruption}
}
\strut
\gls{newglossaryentry}\marg{resumee}\comment{label}
\marg{
  \field{name} = \marg{r\gls{acute}esum\gls{acute}e},
  \field{description} = \marg{summary of something or curriculum vitae}
}
\end{codeenv}
For languages that use a non-Latin script, if you can't or don't
want to use \XeLaTeX\ or \LuaLaTeX, then you need to decide the most
appropriate \gls{ASCII} naming scheme.
For example:
\begin{codeenv}
\gls{newglossaryentry}\marg{goose}\comment{using translation for label}
\marg{
  \field{name} = \marg{\textcyrillicmono{гусь}},
  \field{plural} = \marg{\textcyrillicmono{гуси}},
  \field{description} = \marg{\textnormal{\ldots}}
}
\end{codeenv}
or
\begin{codeenv}
\gls{newglossaryentry}\marg{hus}\comment{using closest ASCII match for label}
\marg{
  \field{name} = \marg{\textcyrillicmono{гусь}},
  \field{plural} = \marg{\textcyrillicmono{гуси}},
  \field{description} = \marg{\textnormal{\ldots}}
}
\end{codeenv}

In addition to labels identifying entries, there are also labels
that identify other things, such as a glossary, category or letter
group. The same restrictions apply to those labels.

\section{First Use}
\label{sec:firstuse}

Each entry has a \pidx{firstuseflag} (boolean variable) that
determines whether or not the entry has been referenced in the
document.  Commands like \gls{gls} and \gls{glspl} change the flag
to indicate that the entry has been used. Commands like
\gls{glsentrydesc} don't. Here's a modification of the earlier
example document that provides different versions depending on 
whether or not the entry has already been referenced:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries}
\strut
\gls{newglossaryentry}\marg{duck}\comment{label}
\marg{\comment{information about this term:}
  \field{name}   = \marg{Duck (noun)},\comment{display name}
  \field{first}  = \marg{duck (quack, quack)},\comment{first use singular}
  \field{firstplural} = \marg{ducks (quack, quack)},\comment{first use plural}
  \field{text}   = \marg{duck},\comment{subsequent use singular}
  \field{description} = \marg{a waterbird with webbed feet}\comment{description}
}
\strut
\gls{newglossaryentry}\marg{goose}\comment{label}
\marg{\comment{information about this term:}
  \field{name}   = \marg{Goose (noun, pl.\ geese)},\comment{display name}
  \field{first}  = \marg{goose (honk, honk)},\comment{first use singular}
  \field{firstplural} = \marg{geese (honk, honk)},\comment{first use plural}
  \field{text}   = \marg{goose},\comment{subsequent use singular}
  \field{plural} = \marg{geese},\comment{subsequent use plural}
  \field{description}=\marg{a large waterbird with a long neck, short legs,
   webbed feet and a short broad bill}
}
\strut
\cmd{begin}\marg{document}
The pond contained a \gls{gls}\marg{duck}\cmd{footnote}\marg{\gls{glsentryname}\marg{duck}:
\gls{glsentrydesc}\marg{duck}} and two 
\gls{glspl}\marg{goose}\cmd{footnote}\marg{\gls{glsentryname}\marg{goose}: 
\gls{glsentrydesc}\marg{goose}}. \gls{Glspl}\marg{duck} and \gls{glspl}\marg{goose} are fowl.
\cmd{end}\marg{document}
\end{codeenv}
This now produces:
\begin{result}
The pond contained a \gls{ex2.duck}\footnote{\glsentryname{ex2.duck}:
\glsentrydesc{ex2.duck}} and two
\glspl{ex2.goose}\footnote{\glsentryname{ex2.goose}: 
\glsentrydesc{ex2.goose}}. \Glspl{ex2.duck} and \glspl{ex2.goose} are fowl.
\end{result}
This uses:
\nosecformatdef{glsentryname}
which works in a similar way to \gls{glsentrydesc}. In this case,
\gls{glsentryname} simply expands to the value of the \field{name}
key. There's also a case-changing version:
\nosecformatdef{Glsentryname}
which changes the initial character to upper case,
but (unlike \cs{glsentryname}) this command isn't expandable. If,
for example, I had instead set the duck's \field{name} key using:
\begin{codeenv}
\field{name} = \marg{duck (noun)}
\end{codeenv}
then I would need to use \code{\gls{Glsentryname}\marg{duck}}
instead.

So on \pidx{firstuse}, \cs{gls} uses the value of the \field{first} key
and \cs{glspl} uses the value of the \field{firstplural} key. On
\pidx{subsequentuse}, \cs{gls} uses the value of the \field{text} key and
\cs{glspl} uses the value of the \field{plural} key. \pIdx{regular}
abbreviations also follow this usage. \pIdx{non-regular}
abbreviations follow a different behaviour for \gls{gls} (and its
\idxpl{variant}) that's determined by the abbreviation style.

If the first use for a particular group of terms always has the
same pattern (such as following the term with a brief description or
alternative representation), then it's simpler to use one of the
automated methods provided, such as the abbreviation mechanism
(\sectionref{sec:abbreviations}) or changing the formatting
(\sectionref{sec:glsformats}).

\section{Categories}
\label{sec:categories}

The \isty{glossaries-extra} extension package provides the
\field{category} key, which isn't available with just the base
\sty{glossaries} package. The value of this key must be a
label as it's used to construct command names. You can choose
whatever label you like (as long as it conforms to the valid
labelling scheme, described in \sectionref{sec:labels}). If you
don't specify a category, then \gls{newglossaryentry} and
\gls{longnewglossaryentry} assume \code{general}. The helper
commands, such as \gls{newabbreviation}, have different defaults.

The category allows you to apply certain types of formatting, such
as the \idx{postlinkhook} (\sectionref{sec:postlinkhooks}).
For abbreviations, the category also governs the abbreviation style (see
\sectionref{sec:abbreviations}) and can be used for filtering.
Categories may be assigned \pidxpl{attribute} that can also be used
to modify formatting or styles. 

Unlike the \idx{postlinkhook}, which
needs to be defined before an entry is \emph{used} (with commands like
\gls{gls}), some \idxpl{attribute} need to be set before the entry
is \emph{defined}, so it's best to set them up as soon as possible in the
preamble (after loading \sty{glossaries-extra}).

\section{Adding Extra Information}
\label{sec:userkeys}

In addition to the \field{name} and \field{description} keys,
there's also a \field{symbol} key which allows you to store an
associated symbol. The value can be obtained with:
\nosecformatdef{glssymbol}
(which is robust and recognises the \idx{postlinkhook}) or with:
\nosecformatdef{glsentrysymbol}
(which behaves like \gls{glsentrydesc} and \gls{glsentryname}).
Neither of the above commands affect the \idx{firstuseflag}.
For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}[hidelinks]\marg{hyperref}
\cmd{usepackage}\marg{glossaries}
\strut
\gls{newglossaryentry}\marg{pi}\comment{label}
\marg{\comment{settings:}
   \field{name}   = \marg{Archimedes' constant},
   \field{symbol} = \marg{\gls[noindex=false]{ensuremath}\marg{\cmd{pi}}},
   \field{description} = \marg{ratio of a circle's circumference to its 
diameter}
}
\strut
\gls{newglossaryentry}\marg{thetai}\comment{label}
\marg{\comment{settings:}
   \field{name}   = \marg{theta parameter},
   \field{symbol} = \marg{\gls{ensuremath}\marg{\cmd{theta}\gls{sbchar}i}},
   \field{description} = \marg{one of the model parameters}
}
\strut
\cmd{begin}\marg{document}
\gls{gls}\marg{pi} (\gls{glssymbol}\marg{pi}). Compare \gls{mshiftchar}\gls{glssymbol}\marg{thetai}\gls[noindex=false]{spchar}2\gls{mshiftchar}
with \gls{mshiftchar}\gls{glssymbol}\marg{thetai}[\gls{spchar}2]\gls{mshiftchar}.
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
\gls{ex.pi} (\glssymbol{ex.pi}). Compare $\glssymbol{ex.thetai}^2$
with $\glssymbol{ex.thetai}[^2]$.
\end{result}
Note that in this case there is now a difference between using the
final optional \meta{insert} argument and simply appending the extra
material. This is a result of the hyperlink that causes an
interruption between the subscript \code{\gls{sbchar}i} and the following
superscript \code{\gls{spchar}2}. (In this case, there's no target for the
hyperlinks. That's covered in \sectionref{sec:printgloss}.)

If you have additional information, such as a translation,
associated image or citation, then you can supply this with the six
user keys:
\field{user1}\glsaddeach{field.user2,field.user3,field.user4,field.user5}, 
\ldots, \field{user6}. The value of the
first field can be obtained with:
\nosecformatdef{glsuseri}
(which behaves like \gls{glssymbol}) or with:
\nosecformatdef{glsentryuseri}
(which behaves like \gls{glsentrysymbol}).
\glsaddeach{glsuserii,glsuseriii,glsuseriv,glsuserv,%
glsentryuserii,glsentryuseriii,glsentryuseriv,glsentryuserv}%
The other fields are similarly obtained using lowercase Roman
numerals, so the sixth field can be obtained with:
\nosecformatdef{glsuservi}
(which behaves like \gls{glssymbol}) or with:
\nosecformatdef{glsentryuservi}
(which behaves like \gls{glsentrysymbol}).
For example:
\begin{codeenv}
\gls{newglossaryentry}\marg{polly.parrot}\comment{label}
\marg{\comment{}
   \field{name} = \marg{Polly Parrot},
   \field{description} = \marg{Senior assistant at the International Society 
of Duck and Geese},
   \field{user1} = \marg{British},\comment{nationality}
   \field{user2} = \marg{1970-12-31},\comment{date of birth}
   \field{user3} = \marg{female},\comment{gender}
   \field{user4} = \marg{43 The Lane, Some Town, Noshire AB1 2XY},\comment{address}
   \field{user5} = \marg{polly.parrot@example.com}\comment{email}
}
\end{codeenv}

Alternatively you can define your own custom keys. If you don't need
commands equivalent to \gls{glssymbol}, then you can use:
\nosecformatdef{glsaddstoragekey}
where \meta{key} is the name of the new key, \meta{default value} is
the default value if the key isn't explicitly set and \meta{no link
cs} is the name of the command to access the field value (equivalent
to \gls{glsentrysymbol}). If you want commands equivalent to
\gls{glssymbol} that have the \meta{options} and \meta{insert}
optional arguments and obey the \idx{postlinkhook}, then use
\nosecformatdef{glsaddkey}
The first three arguments are as for \gls{glsaddstoragekey}.
The next argument \meta{no link ucfirst cs} is like \meta{no link
cs} but converts the first letter to upper case (analogous to
\gls{Glsentryname}). The final three commands behave like
\gls{glssymbol}, but \meta{link ucfirst cs} converts the first
letter to upper case and \meta{link allcaps cs} converts the entire
value to upper case.

The new keys must be defined before the entries are defined (and
the key definitions must come before the first \idx{resourceset}
if you use \bibgls). For example:
\begin{codeenv}
\gls{glsaddstoragekey}\marg{\fieldfmt{nationality}}\marg{}\marg{\cmd{Nationality}}
\gls{glsaddstoragekey}\marg{\fieldfmt{dateofbirth}}\marg{}\marg{\cmd{DateOfBirth}}
\gls{glsaddstoragekey}\marg{\fieldfmt{gender}}\marg{}\marg{\cmd{Gender}}
\gls{glsaddstoragekey}\marg{\fieldfmt{address}}\marg{}\marg{\cmd{Address}}
\gls{glsaddstoragekey}\marg{\fieldfmt{email}}\marg{}\marg{\cmd{Email}}
\gls{newglossaryentry}\marg{polly.parrot}\comment{label}
\marg{\comment{}
   \field{name} = \marg{Polly Parrot},
   \field{description} = \marg{Senior assistant at the International Society 
of Duck and Geese},
   \fieldfmt{nationality} = \marg{British},\comment{nationality}
   \fieldfmt{dateofbirth} = \marg{1970-12-31},\comment{date of birth}
   \fieldfmt{gender}  = \marg{female},\comment{gender}
   \fieldfmt{address} = \marg{43 The Lane, Some Town, Noshire AB1 2XY},\comment{address}
   \fieldfmt{email}   = \marg{polly.parrot@example.com}\comment{email}
}
\end{codeenv}

In addition to the commands like \gls{glssymbol} and
\gls{glsentrysymbol}, there are other ways of accessing the field
value or checking if the field has been set. In the commands listed
below, the field label is the \emph{internal} label. In some cases,
this is the same as the key, but there are a few that have a
different internal label. See Table~\ref*{tab:internalfields} in the
\bibgls\ user manual or Table~4.1 in the \sty{glossaries} user
manual. Custom fields provided with \gls{glsaddkey} or \gls{glsaddstoragekey}
have matching key and internal field labels.

The base \sty{glossaries} package provides:
\nosecformatdef{ifglshassymbol}
which tests if the \field{symbol} field has been assigned. There are similar 
commands for other common fields. For a more general purpose test, you 
can use:
\nosecformatdef{ifglshasfield}
which checks if the given entry (identified by \meta{entry label}, 
which must be defined) has the field identified by \meta{field label}
set to a non-empty value. Within \meta{true}, you can access the
field value with:
\nosecformatdef{glscurrentfieldvalue}
The \sty{glossaries-extra} package provides a similar command:
\nosecformatdef{glsxtrifhasfield}
which doesn't test if the entry exists. The unstarred form adds
implicit grouping around \meta{true} or \meta{false} (allowing
nested use). The starred form \gls{glsxtrifhasfield*} doesn't. 
You can compare the field value with a string using:
\nosecformatdef{GlsXtrIfFieldEqStr}
If you need the string to be (protected) fully expanded before
comparison, you need:
\nosecformatdef{GlsXtrIfFieldEqXpStr}
If you additionally need the field value (protected) fully expanded
before comparison, use:
\nosecformatdef{GlsXtrIfXpFieldEqXpStr}
For a complete list of field commands, see the
\sty{glossaries-extra} user manual.

The earlier \code{duck} and \code{goose} examples from 
\sectionref{sec:firstuse} can be rewritten to move the parenthetical
material into separate keys:
\begin{codeenv}
\gls{newglossaryentry}\marg{duck}\comment{label}
\marg{\comment{information about this term:}
  \field{name}   = \marg{duck},
  \field{user1}  = \marg{noun},
  \field{user2}  = \marg{quack, quack},
  description = {a waterbird with webbed feet}
}
\strut
\gls{newglossaryentry}\marg{goose}\comment{label}
\marg{\comment{information about this term:}
  \field{name}   = \marg{goose},
  \field{plural} = \marg{geese},
  \field{user1}  = \marg{noun},
  \field{user2}  = \marg{honk, honk},
  \field{description}=\marg{a large waterbird with a long neck, short legs,
   webbed feet and a short broad bill}
}
\end{codeenv}
The \idx{postlinkhook} and glossary style can then be modified to 
include the additional information.  For example:
\begin{codeenv}
\gls[noindex=false]{glsdefpostlink}\marg{general}\marg{\comment{}
 \gls[noindex=false]{glsxtrifwasfirstuse}\marg{\cmd{space}(\gls{glsentryuserii}\marg{\gls{glslabel}})}{}\comment{}
}
\strut
\gls[noindex=false]{glssetcategoryattribute}\marg{general}\marg{glossname}\marg{firstuc}
\strut
\gls[noindex=false]{glsdefpostname}\marg{general}\marg{\comment{}
 \cmd{space}
 (\gls{glsentryuseri}\marg{\gls[noindex=false]{glscurrententrylabel}}\comment{}
  \gls{GlsXtrIfXpFieldEqXpStr}\marg{plural}\marg{\gls{glscurrententrylabel}}\comment{}
  \marg{\gls[noindex=false]{glsentrytext}\marg{\gls{glscurrententrylabel}}s}\marg{}\comment{}
  \marg{, pl.\gls{cs.space}\gls[noindex=false]{glsentryplural}{\gls{glscurrententrylabel}}}\comment{}
 )\comment{}
}
\end{codeenv}
The \idx{postlinkhook} appends the value of the \field{user2} field
after the \idx{firstuse} of \gls{gls} (or its \idxpl{variant}).
The \catattr{glossname} attribute converts the first letter of the
\field{name} field to upper case when it's displayed in the
glossary.  The \idx{postnamehook} appends (in parentheses) the value
of the \field{user1} field and then checks if the plural form is the
same as the singular form with \qt{s} appended, and only displays
the plural if they are different. See \sectionref{sec:glsformats}
and \sectionref{sec:printgloss} for further details.

\section{Spaces}
\label{sec:spaces}

With \LaTeX\ in general, spaces are sometimes significant and
sometimes ignored. When defining entries, any spaces around the
equal sign or comma are ignored. For example, if an entry is defined
as
\begin{codeenv}
\gls{newglossaryentry}\marg{sample}
\marg{
  \field{name} = \marg{sample} , \field{description} = \marg{an example}
}
\end{codeenv}
then
\begin{codeenv}
/\gls{gls}\marg{sample}/
\end{codeenv}
will produce
\begin{result}
/sample/
\end{result}
(no spaces). Similarly with:
\begin{codeenv}
\gls{newglossaryentry}\marg{sample}
\marg{
  \field{name} = sample , \field{description} = \marg{an example}
}
\end{codeenv}
However, spaces at the start or end of the value if it's been
enclosed in braces aren't ignored. For example, if the entry is now
defined as:
\begin{codeenv}
\gls{newglossaryentry}\marg{sample}
\marg{
  \field{name} = \marg{ sample } , \field{description} = {an example}\incorrect
}
\end{codeenv}
then:
\begin{codeenv}
/\gls{gls}\marg{sample}/
\end{codeenv}
produces:
\begin{result}
/ sample /
\end{result}
The spaces in this case have been retained. The unstarred version of
\gls{longnewglossaryentry} appends extra code to the end of the
description, which removes any trailing spaces (and also the 
\gls{postdescriptionhook}). The starred version
\gls{longnewglossaryentry*} (only available with \sty{glossaries-extra}) 
doesn't. In both cases any leading spaces are retained. For example,
if the entry is defined as:
\begin{codeenv}
\gls{longnewglossaryentry}\marg{sample}\marg{name=\marg{sample}}\marg{ an example }\incorrect
\end{codeenv}
then:
\begin{codeenv}
/\gls{glsentrydesc}\marg{sample}/
\end{codeenv}
produces:
\begin{result}
/ an example/
\end{result}
(trailing space removed), whereas if the entry is defined as:
\begin{codeenv}
\gls{longnewglossaryentry*}\marg{sample}\marg{name=\marg{sample}}\marg{ an example }\incorrect
\end{codeenv}
then:
\begin{codeenv}
/\gls{glsentrydesc}\marg{sample}/
\end{codeenv}
produces:
\begin{result}
/ an example /
\end{result}
(leading and trailing spaces retained).

Spaces in labels are significant. For example, in \verb|\gls{ duck }|
the spaces are considered part of the label. If the entry was
actually defined without spaces in the label then the entry
referenced in \verb|\gls{ duck }| won't be found.

\section{Undefined References}
\label{sec:undefaction}

If an entry that hasn't been defined is referenced with \gls{gls},
by default an error is triggered. For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries}
\strut
\cmd{begin}\marg{document}
A \gls{gls}\marg{duck}.
\cmd{end}\marg{document}
\end{codeenv}
This produces the error:
\begin{verbatim}
Glossary entry `duck' has not been defined.
\end{verbatim}
If you instruct \LaTeX\ to ignore the error and continue, the result
is
\begin{result}
A .
\end{result}
The \sty{glossaries-extra} package provides the option
\styopt[warn]{undefaction}, which will convert the error to a
warning. For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}[\styopt{undefaction}=warn]\marg{glossaries-extra}
\strut
\cmd{begin}\marg{document}
A \gls{gls}\marg{duck}.
\cmd{end}\marg{document}
\end{codeenv}
This now produces the warning:
\begin{verbatim}
Glossary entry `duck' has not been defined on input line 6
\end{verbatim}
(There are also other warnings about an empty \code{main} glossary.)
The result is now:
\begin{result}
A ??.
\end{result}
This replaces the undefined reference with two question marks, just like 
undefined cross-references.
Notice the difference between using \gls{ifglshasfield}:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}[\styopt{undefaction}=warn]\marg{glossaries-extra}
\strut
\cmd{begin}\marg{document}
A \gls{gls}\marg{duck} 
(\gls{ifglshasfield}\marg{\gls[noindex=false]{field.useri}}\marg{duck}\marg{\gls{glscurrentfieldvalue}}\marg{not set}).
\cmd{end}\marg{document}
\end{codeenv}
which produces:
\begin{result}
A ?? (??).
\end{result}
(and has two undefined warnings) and using \gls{glsxtrifhasfield}:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}[\styopt{undefaction}=warn]\marg{glossaries-extra}
\strut
\cmd{begin}\marg{document}
A \gls{gls}\marg{duck}
(\gls{glsxtrifhasfield}\marg{\field{useri}}\marg{duck}\marg{\gls{glscurrentfieldvalue}}\marg{not set}).
\cmd{end}\marg{document}
\end{codeenv}
which only has one undefined warning and produces:
\begin{result}
A ?? (not set).
\end{result}

When you incorporate \bibgls\ into the build process (see
\sectionref{sec:bib2gls}), the first \LaTeX\ run doesn't have any 
entries defined. One of the actions that the \styopt{record} option 
automatically performs is to switch on \styopt[warn]{undefaction}, which avoids
undefined errors on the first \LaTeX\ run. For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}[\styopt{record}]\marg{glossaries-extra}
\strut
\cmd{begin}\marg{document}
A \gls{gls}\marg{duck}
(\gls{glsxtrifhasfield}\marg{\field{useri}}\marg{duck}\marg{\gls{glscurrentfieldvalue}}\marg{not set}).
\cmd{end}\marg{document}
\end{codeenv}
This produces the same result as the previous example, but there's
only the one warning (about an undefined reference) and no warning
about the empty \code{main} glossary.

\section{Robust, Fragile and Expandable Commands}
\label{sec:robust}

Commands like \gls{gls} are \pidx{robust}. This protects them from
premature expansion in situations that would otherwise break the
command. If content containing a \idx{robust} command is written to
an external file, the \idx{robust} command itself is written instead of its
definition. For example, consider the following document:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\cmd{newcommand}\marg{\csfmt{test}}\marg{some sample text}
\cmd{begin}\marg{document}
\cmd{tableofcontents}
\gls[noindex=false]{section}\marg{\csfmt{test}}
\cmd{end}\marg{document}
\end{codeenv}
In this case, \csfmt{test} is expandable. Its definition doesn't
contain anything complicated. The \ext{toc} file (which is input by
\csfmt{tableofcontents}) contains the line:
\begin{codeenv}
\cmd{contentsline} \marg{section}\marg{\cmd{numberline} \marg{1}some sample text}\marg{1}
\end{codeenv}
So \csfmt{test} has been expanded to its definition when it was
written to the \ext{toc} file. If \csfmt{test} is defined in terms
of another command, that will also be expanded. For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\cmd{newcommand}\marg{\csfmt{sample}}\marg{\gls{emph}\marg{sample}}
\cmd{newcommand}\marg{\csfmt{test}}\marg{some \csfmt{sample}\gls{cs.space}text}
\cmd{begin}\marg{document}
\cmd{tableofcontents}
\gls{section}\marg{\csfmt{test}}
\cmd{end}\marg{document}
\end{codeenv}
The \ext{toc} file now contains:
\begin{codeenv}
\cmd{contentsline} \marg{section}\marg{\cmd{numberline} \marg{1}some \gls{emph} \marg{sample}\gls{cs.space}text}\marg{1}
\end{codeenv}
So \csfmt{sample} has also been expanded but neither
\gls{emph} nor \idx{cs.space} (backslash space) have
been expanded. \Idx{robust} commands don't expand. For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries}
\strut
\gls{newglossaryentry}\marg{duck}
\marg{
  \field{name}=\marg{duck},
  \field{description}=\marg{a waterbird with webbed feet}
}
\strut
\cmd{begin}\marg{document}
\cmd{tableofcontents}
\gls{section}\marg{\gls{Gls}\marg{duck}: \gls{glsentrydesc}\marg{duck}}
\cmd{end}\marg{document}
\end{codeenv}
The \ext{toc} file now contains:
\begin{codeenv}
\cmd{contentsline} \marg{section}\marg{\cmd{numberline} \marg{1}\gls{Gls} \marg{duck}: a waterbird with 
webbed feet}\marg{1}
\end{codeenv}
So \gls{Gls} doesn't expand, and the command itself is written to the
\ext{toc} file, but \gls{glsentrydesc} does expand.

A \pidx{fragile} command is one that breaks (causes an error) when
it's expanded in this type of context. One such command is \gls{footnote}.
For example, the following won't work:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries}
\strut
\gls{newglossaryentry}\marg{duck}
\marg{
  \field{name}=\marg{duck},
  \field{description}=\marg{a waterbird with webbed feet}
}
\strut
\cmd{begin}\marg{document}
\cmd{tableofcontents}
\gls{section}\marg{\gls{Gls}\marg{duck}\gls{footnote}\marg{\gls{glsentrydesc}\marg{duck}}}\incorrect
\cmd{end}\marg{document}
\end{codeenv}
This causes the error:
\begin{verbatim}
! Argument of \@sect has an extra }.
\end{verbatim}
Inserting \gls{protect} before the command prevents the attempted
expansion, which makes the command behave as though it was robust:
\begin{codeenv}
\gls{section}\marg{\gls{Gls}\marg{duck}\gls{protect}\gls{footnote}\marg{\gls{glsentrydesc}\marg{duck}}}
\end{codeenv}
In this case, it's unlikely that you'd want the footnote to appear
in the table of contents, so it would be better to use the optional
argument:
\begin{codeenv}
\gls{section}\oarg{Duck}\marg{\gls{Gls}\marg{duck}\gls{footnote}\marg{\gls{glsentrydesc}\marg{duck}}}\correct
\end{codeenv}
Now the \ext{toc} file is just:
\begin{codeenv}
\cmd{contentsline} \marg{section}\marg{\cmd{numberline} \marg{1}Duck}\marg{1}
\end{codeenv}
If the \field{description} field contains a \idx{fragile} command
then \gls{glsentrydesc} will break in expandable contexts. For
example, the following doesn't work:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries}
\strut
\gls{newglossaryentry}\marg{duck}
\marg{
  \field{name}=\marg{duck},
  \field{description}=\marg{a waterbird\gls{footnote}\marg{a bird that lives on or 
   near water} with webbed feet}
}
\strut
\cmd{begin}\marg{document}
\cmd{tableofcontents}
\gls{section}\marg{\gls{Gls}\marg{duck}: \gls{glsentrydesc}\marg{duck}}\incorrect
\cmd{end}\marg{document}
\end{codeenv}
This is a contrived example. In this case, it would be better to
also define the term \qt{waterbird}: 
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries}
\strut
\gls{newglossaryentry}\marg{waterbird}
\marg{
  \field{name}=\marg{waterbird},
  \field{description}=\marg{a bird that lives on or near water}
}
\strut
\gls{newglossaryentry}\marg{duck}
\marg{
  \field{name}=\marg{duck},
  \field{description}=\marg{a \gls{gls}\marg{waterbird} with webbed feet}
}
\strut
\cmd{begin}\marg{document}
\cmd{tableofcontents}
\gls{section}\marg{\gls{Gls}\marg{duck}: \gls{glsentrydesc}\marg{duck}}
\cmd{end}\marg{document}
\end{codeenv}
The \ext{toc} file now contains:
\begin{codeenv}
\cmd{contentsline} \marg{section}\marg{\cmd{numberline} \marg{1}\gls{Gls} \marg{duck}: a \gls{gls} \marg{waterbird} with webbed feet}\marg{1}
\end{codeenv}

\begin{important}
The examples in this section are used to illustrate the differences
between \idx{robust}, \idx{fragile} and \idx{expandable} commands.
In general, it's better not to use commands like \gls{gls} in
headings or captions (see \sectionref{sec:headings}) and using
commands like \gls{gls} in field values can be problematic (see
\sectionref{sec:nested}).
\end{important}

By default, most of the field values are expanded when the entry is
defined. This allows for defining entries programmatically, but it
can cause a problem if the value contains any \idx{fragile} commands.
For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries}
\strut
\gls{newglossaryentry}\marg{duck}\comment{label}
\marg{
  \field{name} = \marg{duck},
  \field{first} = \marg{duck\gls{footnote}\marg{quack, quack}},\incorrect
  \field{description} = \marg{a waterbird with webbed feet}
}
\strut
\cmd{begin}\marg{document}
A \gls{gls}\marg{duck}.
\cmd{end}\marg{document}
\end{codeenv}
This causes the confusing error:
\begin{verbatim}
! Undefined control sequence.
\in@ #1#2->\begingroup \def \in@@ 
\end{verbatim}
In order for this example to work, the \idx{fragile} command must either be
protected:
\begin{codeenv}
\gls{newglossaryentry}\marg{duck}\comment{label}
\marg{
  \field{name} = \marg{duck},
  \field{first} = \marg{duck\gls{protect}\gls{footnote}\marg{quack, quack}},\correct
  \field{description} = \marg{a waterbird with webbed feet}
}
\end{codeenv}
or the expansion must first be switched off:
\begin{codeenv}
\gls{glsnoexpandfields} \correct
\gls{newglossaryentry}\marg{duck}\comment{label}
\marg{
  \field{name} = \marg{duck},
  \field{first} = \marg{duck\gls{footnote}\marg{quack, quack}},
  \field{description} = \marg{a waterbird with webbed feet}
}
\end{codeenv}
Since it's not possible to programmatically define entries with
\bibgls, the expansion is automatically switched off as \bibgls\
writes \gls{glsnoexpandfields} to the \ext{glstex} file (although
you can switch this feature off with \longarg{expand-fields}).

The reason why \gls{footnote} didn't cause a problem in the
\field{description} field \emph{when the entry was defined} is that, by
default, expansion isn't performed on the \field{name},
\field{description} and \field{symbol} fields, regardless of whether
or not \gls{glsnoexpandfields} has been used. This only applies to
the point when the entries are being defined. Unprotected
\idx{fragile} commands can still cause a problem if the value is
later used in a problematic context (such as the earlier example
where \gls{glsentrydesc} was used in a section heading).

\chapter{Abbreviations}
\label{sec:abbreviations}

The abbreviation handling provided by the base \isty{glossaries}
package is quite restrictive and only one abbreviation style can be
used for all abbreviations. The \isty{glossaries-extra} package
internally loads the \sty{glossaries} package and extends it,
providing new options and a better abbreviation mechanism that
allows different styles per category.

The base \sty{glossaries} package provides:
\nosecformatdef{newacronym}
The extension package \sty{glossaries-extra} provides:
\nosecformatdef{newabbreviation}
and redefines \gls{newacronym} in terms of \gls{newabbreviation} so
that it effectively behaves like:
\begin{codeenv}
\gls{newabbreviation}\oarg{\gls[noindex=false]{field.type}=\gls{acronymtype},\field{category}=acronym,\meta{\keyvallist}}
\margm{label}\margm{short}\margm{long}
\end{codeenv}
This makes it easier to transfer over from the base \sty{glossaries}
package, but if you use \gls{newacronym} remember that the category 
is set to \code{acronym} instead of \code{abbreviation}, which is
the usual default for \gls{newabbreviation}.

In both cases, \meta{label} is the entry's label used to identify
the abbreviation in commands like \gls{gls}, \meta{short} is the
short form and \meta{long} is the long form. Any additional
settings, such as the \field{category} or \field{description} 
can be set in the optional argument.

The style must always be set before the abbreviations are defined
using:
\nosecformatdef{setabbreviationstyle}
where \meta{category} is the category label and \meta{style-name} is
the name of the style. If the optional argument is omitted,
\code{abbreviation} is assumed. The \sty{glossaries-extra} package
automatically sets the default styles:
\begin{codeenv}
\gls{setabbreviationstyle}\marg{\abbrstyle{long-short}}
\gls{setabbreviationstyle}\oarg{acronym}\marg{\abbrstyle{short-nolong}}
\end{codeenv}
This means that if you don't explicitly set the style then any
abbreviation defined with \gls{newacronym} will use the
\abbrstyle{short-nolong} style (unless you change the category in
the optional argument) and other abbreviations will use the
\abbrstyle{long-short} style.

If these styles aren't suitable, then you need to change them. Any
abbreviation that's defined with a category that hasn't been
assigned a style will fallback on the style for the default
\code{abbreviation} category. There are many predefined styles to
choose from and they come with commands to help adjust the
formatting. See the \sty{glossaries-extra} user manual for the
complete list. The \sty{glossaries-extra} package also comes with a
sample document
\ctanfile{glossaries-extra/samples}{sample-abbr-styles.pdf}
demonstrating all the predefined styles.

The style determines whether the abbreviation is treated as a
\idx{regular} term.  There are also some \idxpl{categoryattribute} that govern
abbreviations (see later).  These should be also set before the
abbreviation is defined.

Some of the styles set the \field{description} field (typically to
the \meta{long} form). The styles that end with \code{-desc} don't,
and so that key must be set explicitly in the \meta{\keyvallist} optional part.

Here's a simple example that uses both \gls{newabbreviation} and
\gls{newacronym} to illustrate the difference:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{newabbreviation}\marg{tug}\marg{TUG}\marg{\cmd{TeX}\gls{cs.space}Users Group}
\gls{newabbreviation}\marg{cldr}\marg{CLDR}\marg{Unicode Common Locale Data 
Repository}
\strut
\gls{newacronym}\marg{SIunit}\marg{SI unit}\marg{International System of Units}
\gls{newacronym}\marg{ascii}\marg{ASCII}\marg{American Standard Code for 
Information Interchange}
\strut
\cmd{begin}\marg{document}
First use: \gls{gls}\marg{tug}, \gls{gls}\marg{cldr}, \gls{gls}\marg{SIunit}, \gls{gls}\marg{ascii}.
Next use: \gls{gls}\marg{tug}, \gls{gls}\marg{cldr}, \gls{gls}\marg{SIunit}, \gls{gls}\marg{ascii}.
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
First use: \gls{TUG}, \gls{CLDR}, \gls{SIunit}, \gls{ASCII}.
Next use: \gls{TUG}, \gls{CLDR}, \gls{SIunit}, \gls{ASCII}.
\end{result}
Note that the \idx{firstuse} of \code{SIunit} and \code{ascii} only
show the short form. This is because the default style for the
\code{acronym} category is the \abbrstyle{short-nolong} style, which
doesn't show the long form with \gls{gls} (and its \idxpl{variant}).

If you only want \gls{gls} to show the short form but not the long
form, use one of the \code{-nolong} styles (such as
\abbrstyle{short-nolong}). If you only want the
long form and not the short form, use one of the \code{-noshort}
styles (such as \abbrstyle{long-noshort}). If you want only the long
form on \idx{firstuse} and only the short form on subsequent use
then use one of the \code{-only} styles, such as
\abbrstyle{long-only-short-only}.

If you want a specific instance to show only the short form, without
modifying the \idx{firstuseflag}, then use
\nosecformatdef{glsxtrshort}
If you want a specific instance to show only the long form, without
modifying the \idx{firstuseflag}, then use
\nosecformatdef{glsxtrlong}
If you want a specific instance to show both the long and short form, without
modifying the \idx{firstuseflag}, then use
\nosecformatdef{glsxtrfull}
Depending on the style, this may not exactly match the format
produced by the \idx{firstuse} of \gls{gls}.

If you find these commands quite long-winded, there are some
shortcuts available with the \styopt{shortcuts} option, but as these
may interfere with other packages, you might want to consider
investigating your text editor settings as the more sophisticated
ones provide ways of inserting commonly-used commands to save typing.

The final optional \meta{insert} argument of commands like \gls{gls}
is typically moved inside, depending on the style. For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{newabbreviation}\marg{svm}\marg{SVM}\marg{support vector machine}
\strut
\cmd{begin}\marg{document}
The \gls{gls}\marg{svm}\oarg{'s} parameters are\cmd{ldots}
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
The \gls{ex.svm}['s] parameters are\ldots
\end{result}
Compare this with:
\begin{codeenv}
The \gls{gls}\marg{svm}'s parameters are\cmd{ldots}
\end{codeenv}
which produces:
\begin{result}
The \gls{ex.svm}'s parameters are\ldots
\end{result}

\section{Plural Abbreviations}
If the abbreviation represents something countable then the plural
form can again be obtained with \gls{glspl}:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{newabbreviation}\marg{svm}\marg{SVM}\marg{support vector machine}
\strut
\cmd{begin}\marg{document}
First use: \gls{glspl}\marg{svm}. Next use: \gls{glspl}\marg{svm}.
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
First use: \glspl{ex.svm}. Next use: \glspl{ex.svm}.
\end{result}
The default plural short and long forms are obtained by
appending the letter \qt{s} after the singular form. These can be
changed on an individual basis with the \field{shortplural} and
\field{longplural} keys. For example:
\begin{codeenv}
\gls{newabbreviation}
 [\field{longplural}=\marg{lower triangular matrices}]
 \marg{ltm}\marg{LTM}\marg{lower triangular matrix}
\end{codeenv}

It may be that you prefer to keep the short plural form the same as
the short singular value for all abbreviations within a particular
category. You can implement this with the
\catattr{noshortplural} attribute, which must be set to \code{true}
before the abbreviations for that category are defined. For example:
\begin{codeenv}
\gls{glssetcategoryattribute}\marg{abbreviation}\marg{\catattr{noshortplural}}\marg{true}
\gls{newabbreviation}\marg{svm}\marg{SVM}\marg{support vector machine}
\end{codeenv}
Now:
\begin{codeenv}
First use: \gls{glspl}\marg{svm}. Next use: \gls{glspl}\marg{svm}.
\end{codeenv}
produces:
\begin{result}
First use: support vector machines (SVM). Next use: SVM.
\end{result}
A related attribute is \catattr{aposplural} which inserts \qtt{'s}
(apostrophe followed by \qt{s}) to form the default short plural to
help avoid ambiguity with lower case abbreviations where it might
not be obvious that the \qt{s} indicates a plural (rather than
another letter in the abbreviation). Again, this needs to be set
before the abbreviations for the given category (or categories) are defined.

\section{Abbreviation Markup}

The \catattr{markwords} attribute can be set to \code{true} to
indicate that \gls{newabbreviation} should parse the long form and
markup the words using:
\nosecformatdef{glsxtrword}
The words are separated with
\nosecformatdef{glsxtrwordsep}
For example:
\begin{codeenv}
\gls{glssetcategoryattribute}\marg{abbreviation}\marg{\catattr{markwords}}\marg{true}
\gls{newabbreviation}\marg{ssl}\marg{SSL}\marg{Secure Sockets Layer}
\end{codeenv}
This is essentially the same as
\begin{codeenv}
\gls{newabbreviation}\marg{ssl}\marg{SSL}\marg{\gls{glsxtrword}\marg{Secure}\gls{glsxtrwordsep}
\gls{glsxtrword}\marg{Sockets}\gls{glsxtrwordsep}\gls{glsxtrword}\marg{Layer}}
\end{codeenv}
This is typically used with the \code{-hyphen} abbreviation styles.
If the final optional \meta{insert} argument of commands like
\gls{gls} starts with a hyphen, \gls{glsxtrwordsep} is locally
changed to a hyphen.

For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{setabbreviationstyle}\marg{\gls[noindex=false]{long-hyphen-short-hyphen}}
\strut
\gls{glssetcategoryattribute}\marg{abbreviation}\marg{\catattr{markwords}}\marg{true}
\strut
\gls{newabbreviation}\marg{ssl}\marg{SSL}\marg{Secure Sockets Layer}
\strut
\cmd{begin}\marg{document}
First use: \gls{gls}\marg{ssl}\oarg{-enabled}. Next use: \gls{gls}\marg{ssl}\oarg{-enabled}.
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
First use: \gls{ex.ssl}[-enabled]. Next use: \gls{ex.ssl}[-enabled].
\end{result}
Compare this with:
\begin{codeenv}
First use: \gls{gls}\marg{ssl}-enabled. Next use: \gls{gls}\marg{ssl}-enabled.
\end{codeenv}
which instead produces:
\begin{result}
First use: \gls{ex.ssl}-enabled. Next use: \gls{ex.ssl}-enabled.
\end{result}
Whereas:
\begin{codeenv}
First use: \gls{gls}\marg{ssl}\oarg{ enabled}. Next use: \gls{gls}\marg{ssl}\oarg{ enabled}.
\end{codeenv}
produces:
\begin{result}
First use: \gls{ex.ssl}[ enabled]. Next use: \gls{ex.ssl}[ enabled].
\end{result}

There's a related attribute \catattr{markshortwords} which applies
to the short form instead. This is only useful if the short form contains
spaces.

Another markup-related attribute is \catattr{tagging}. In general,
you don't need to explicitly set this attribute. Instead, you need
to define a tagging command using:
\nosecformatdef{GlsXtrEnableInitialTagging}
This (robustly) defines \meta{cs} (a control sequence) to accept a
single argument, which should be used in the \meta{long} part of the 
abbreviation definition. This command automatically sets the
\catattr{tagging} attribute to \code{true} for each of the listed
categories, which ensures that \meta{cs} uses
\nosecformatdef{glsxtrtagfont}
within the glossary (see \sectionref{sec:printgloss}). Within the
main text the command simply does its argument.
For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{GlsXtrEnableInitialTagging}\marg{abbreviation}\marg{\cmd{itag}}
\strut
\gls{newabbreviation}\marg{xml}\marg{XML}\marg{e\cmd{itag}\marg{x}tensible \cmd{itag}\marg{m}arkup
\cmd{itag}\marg{l}anguage}
\strut
\cmd{begin}\marg{document}
First use: \gls{gls}\marg{xml}. Next use: \gls{gls}\marg{xml}.
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
First use: \gls{ex.xml}. Next use: \gls{ex.xml}.
\end{result}
This doesn't show the markup as the tagging command (\csfmt{itag} in
this example) simply expands to its argument in the main document
text. The difference is only evident in the glossary.

\section{Dotted Abbreviations}

If an abbreviation ends with a \idx{full-stop}, it can be awkward
when it appears at the end of a sentence, as you can end up with two
dots by mistake. For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{newabbreviation}\marg{dante}\marg{DANTE e.V.}
\marg{Deutschsprachige Anwendervereinigung \cmd{TeX}\gls{cs.space}e.V.}
\strut
\gls{newabbreviation}\marg{gp}\marg{G.P.}\marg{General Practitioner}
\strut
\cmd{begin}\marg{document}
\gls{gls}\marg{dante} is a local \cmd{TeX}\gls{cs.space}user group.
The German-speaking local \cmd{TeX}\gls{cs.space}user group is \gls{gls}\marg{dante}.
\strut
A \gls{gls}\marg{gp} is a medical doctor.
I went to my surgery to see the \gls{gls}\marg{gp}.
\cmd{end}\marg{document}
\end{codeenv}
This results in:
\begin{result}
\gls{ex.dante} is a local \TeX\ user group.
The German-speaking local \TeX\ user group is \gls{ex.dante}\relax.

A \gls{ex.gp} is a medical doctor.
I went to my surgery to see the \gls{ex.gp}\relax.
\end{result}
The awkward double-dot at the end is caused by the final dot in the
short form followed by the sentence terminating \idx{full-stop}.

If the \catattr{discardperiod} attribute is set to \code{true}, the
\idx{postlinkhook} will look ahead for a \idx{full-stop}. If it
finds one, it will be discarded. For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{glssetcategoryattribute}\marg{abbreviationdot}\marg{\catattr{discardperiod}}\marg{true}
\strut
\gls{newabbreviation}\oarg{\field{category}=abbreviationdot}
 \marg{dante}\marg{DANTE e.V.}\marg{Deutschsprachige Anwendervereinigung \cmd{TeX}\gls{cs.space}e.V.}
\strut
\gls{newabbreviation}\oarg{\field{category}=abbreviationdot}
 \marg{gp}\marg{G.P.}\marg{General Practitioner}
\strut
\cmd{begin}\marg{document}
\gls{gls}\marg{dante} is a local \cmd{TeX}\gls{cs.space}user group.
The German-speaking local \cmd{TeX}\gls{cs.space}user group is \gls{gls}\marg{dante}.
\strut
A \gls{gls}\marg{gp} is a medical doctor.
I went to my surgery to see the \gls{gls}\marg{gp}.
\cmd{end}\marg{document}
\end{codeenv}
This now results in:
\begin{result}
\gls{ex.dante} is a local \TeX\ user group.
The German-speaking local \TeX\ user group is \gls{ex.dante}.

A \gls{ex.gp} is a medical doctor.
I went to my surgery to see the \gls{ex.gp}.
\end{result}
This attribute only affects the \emph{non-plural} commands, such as
\gls{gls} and \gls{glsxtrshort}. If the last paragraph in the above 
example is changed to:
\begin{codeenv}
A \gls{gls}\marg{gp} is a medical doctor.
I went to my surgery to see the \gls{glspl}\marg{gp}.
\end{codeenv}
then the result is:
\begin{result}
A \gls{ex.gp} is a medical doctor.
I went to my surgery to see the \glspl{ex.gp}.
\end{result}
In this case there's no need to discard the terminating
\idx{full-stop} as the plural form doesn't end with one. If the
plural form also ends with a \idx{full-stop} (for example, if the
\catattr{noshortplural} attribute is also set) then you additionally
need to set the \catattr{pluraldiscardperiod} attribute.

The \idx{postlinkhook} is also applied to other commands, such as 
\gls{glsxtrfull}, \gls{glsxtrlong}, \gls{glsxtrshort} and \gls{glssymbol}.
For example:
\begin{codeenv}
I went to my surgery to see the \gls{glsxtrshort}\marg{gp}.
\end{codeenv}
results in:
\begin{result}
I went to my surgery to see the \glsxtrshort{ex.gp}.
\end{result}
In some cases, this may be inappropriate, for example:
\begin{codeenv}
I went to my surgery to see the \gls{glsxtrlong}\marg{gp}.
\end{codeenv}
results in:
\begin{result}
I went to my surgery to see the \glsxtrlong{ex.gp}.
\end{result}
In this case the terminating \idx{full-stop} shouldn't be discarded.
There are several ways to prevent it. For example, moving the
\idx{full-stop} into the \meta{insert} argument:
\begin{codeenv}
I went to my surgery to see the \gls{glsxtrlong}\marg{gp}\oarg{.}
\end{codeenv}
This results in:
\begin{result}
I went to my surgery to see the \glsxtrlong{ex.gp}[.]
\end{result}
Alternatively, insert \csfmt{relax} before the \idx{full-stop}:
\begin{codeenv}
I went to my surgery to see the \gls{glsxtrlong}\marg{gp}\cmd{relax}.
\end{codeenv}

Depending on the abbreviation style, it may be inappropriate for the
\idx{firstuse} to discard the \idx{full-stop}. In this case, it's a
bit of a nuisance to keep track of whether the term is being
referenced for the first time. Instead, set the
\catattr{retainfirstuseperiod} attribute to \code{true}.

If you have many abbreviations defined without dots and then you
later decide to insert them, you may prefer an automated approach.
This can be done by setting the \catattr{insertdots} attribute to \code{true}.
For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{glssetcategoryattribute}\marg{initialism}\marg{\catattr{insertdots}}\marg{true}
\gls{glssetcategoryattribute}\marg{initialism}\marg{\catattr{discardperiod}}\marg{true}
\gls{glssetcategoryattribute}\marg{initialism}\marg{\catattr{retainfirstuseperiod}}\marg{true}
\strut
\gls{setabbreviationstyle}\oarg{initialism}\marg{\gls[noindex=false]{short-long}}
\strut
\gls{newabbreviation}\oarg{\field{category}=initialism}
 \marg{gp}\marg{GP}\marg{General Practitioner}
\strut
\cmd{begin}\marg{document}
Today I went to my surgery to see the \gls{gls}\marg{gp}.
Tomorrow I'm going to my surgery to see the \gls{gls}\marg{gp}.
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
Today I went to my surgery to see the \gls{ex2.gp}.
Tomorrow I'm going to my surgery to see the \gls{ex2.gp}.
\end{result}

\section{Translations}
\label{sec:abbrvtrans}

If an abbreviation needs to be accompanied by a translation, then
you can use a custom field or one of the supplied user fields
described in \sectionref{sec:userkeys} to store the translation. The
\code{-user} abbreviation styles can be used to include the extra
information if the field is set. The \field{user1} field
is the default, but you can change this by redefining
\nosecformatdef{glsxtruserfield}
to the \emph{internal} field name. (For example, \field{userii} for
\field{user2}.) In the sample document below, the translation is
supplied in the default \field{user1} field:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{setabbreviationstyle}\marg{\abbrstyle{long-short-user}}
\strut
\gls{newabbreviation}\oarg{\field{user1}=\marg{ribonucleic acid}}
 \marg{rna}\marg{RNA}\marg{ribonukleins\gls[noindex=false]{umlaut}aure}
\strut
\cmd{begin}\marg{document}
First use: \gls{gls}\marg{rna}.  Next use: \gls{gls}\marg{rna}.
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
First use: \gls{ex.rna}.  Next use: \gls{ex.rna}.
\end{result}
If the field is empty, \abbrstyle{long-short-user} behaves like
\abbrstyle{long-short}.

\chapter{Symbols}
\label{sec:symbols}

\Sectionref{sec:userkeys} described the \field{symbol} key, which can
be used to additionally provide a symbol. For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{\gls[noindex=false]{siunitx}}\comment{provides \gls{si}}
\cmd{usepackage}\marg{glossaries}
\strut
\gls{newglossaryentry}\marg{length}\comment{label}
\marg{\comment{settings:}
   \field{name}   = \marg{length},
   \field{symbol} = \marg{\gls{si}\marg{\cmd{metre}}},
   \field{description} = \marg{measurement between two points}
}
\strut
\gls{newglossaryentry}\marg{area}\comment{label}
\marg{\comment{settings:}
   \field{name}   = \marg{area},
   \field{symbol} = \marg{\gls[noindex=false]{si}\marg{\cmd{metre}\cmd{squared}}},
   \field{description} = \marg{measurement of a surface}
}
\strut
\cmd{begin}\marg{document}
Measurements: \gls{gls}\marg{length} (\gls{glssymbol}\marg{length}) and
\gls{gls}\marg{area} (\gls{glssymbol}\marg{area}).
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
Measurements: \gls{ex.length} (\glssymbol{ex.length}) and
\gls{ex.area} (\glssymbol{ex.area}).
\end{result}

It may be that you prefer to have the symbol in the \field{name}
field instead. The example document below is a modification of the
above and uses the \idx{postlinkhook} to append the description on
\idx{firstuse} (see \sectionref{sec:postlinkhooks}).
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{siunitx}
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls[noindex=false]{glsnoexpandfields} \comment{name field contains \gls{si}}
\strut
\gls{glsdefpostlink}\marg{symbol}\marg{\gls{glsxtrpostlinkAddDescOnFirstUse}}
\strut
\gls{newglossaryentry}\marg{length}\comment{label}
\marg{\comment{settings:}
  \field{name} = \marg{\gls{si}\marg{\cmd{metre}}},
  \field{description} = \marg{length},
  \field{category} = \marg{symbol}
}
\strut
\gls{newglossaryentry}\marg{area}\comment{label}
\marg{\comment{settings:}
  \field{name} = \marg{\gls{si}\marg{\cmd{metre}\cmd{squared}}},
  \field{description} = \marg{area},
  \field{category} = \marg{symbol}
}
\strut
\cmd{begin}\marg{document}
First use: \gls{gls}\marg{length} and \gls{gls}\marg{area}.
Next use: \gls{gls}\marg{length} and \gls{gls}\marg{area}.
\cmd{end}\marg{document}
\end{codeenv}
Note the need for \gls{glsnoexpandfields} (described in
\sectionref{sec:robust}). This wasn't required in the previous
example because the \sty{siunitx} commands were in the
\field{symbol} field, which isn't expanded by default. The
\field{name} field also isn't expanded by default, but its value is
copied to the \field{text} and \field{first} fields, which are
expanded by default. If \gls{glsnoexpandfields} is omitted from the
above document, the following error would occur:
\begin{verbatim}
! Undefined control sequence.
\@glo@name ->\si {\metre 
                         }
\end{verbatim}
Although \gls{si} is robust, commands like \csfmt{metre} and
\csfmt{squared} aren't.
With \gls{glsnoexpandfields}, the document compiles correctly and
produces:
\begin{result}
\glsdefpostlink{symbol}{\glsxtrpostlinkAddDescOnFirstUse}%
First use: \gls{ex2.length} and \gls{ex2.area}.
Next use: \gls{ex2.length} and \gls{ex2.area}.
\end{result}

The \sty{glossaries-extra}['s] \styopt{symbols} package option
provides the command
\nosecformatdef{glsxtrnewsymbol}
which is a shortcut for
\begin{codeenv}
\gls{newglossaryentry}\margm{label}\marg{\field{name}=\margm{symbol},\field{category}=\marg{symbol},\gls[noindex=false]{field.sort}=\margm{label},
\gls[noindex=false]{field.type}=\marg{symbols},\meta{\keyvallist}}
\end{codeenv}
So the above document can be changed to:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{siunitx}
\cmd{usepackage}[\styopt{symbols}]\marg{glossaries-extra}
\strut
\gls{glsnoexpandfields}
\strut
\gls{glsdefpostlink}\marg{symbol}\marg{\gls{glsxtrpostlinkAddDescOnFirstUse}}
\strut
\gls{glsxtrnewsymbol}\oarg{\field{description} = \marg{length}}\marg{length}\marg{\gls{si}\marg{\cmd{metre}}}
\strut
\gls{glsxtrnewsymbol}\oarg{\field{description} = \marg{area}}\marg{area}\marg{\gls{si}\marg{\cmd{metre}\cmd{squared}}}
\strut
\cmd{begin}{document}
First use: \gls{gls}\marg{length} and \gls{gls}\marg{area}.
Next use: \gls{gls}\marg{length} and \gls{gls}\marg{area}.
\cmd{end}\marg{document}
\end{codeenv}
The result is the same.

\section{Functions}
\label{sec:functions}

Some symbols may represent functions. For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}[\styopt{symbols}]\marg{glossaries-extra}
\strut
\gls{glsnoexpandfields}
\strut
\gls{glsxtrnewsymbol}
 \oarg{\field{description} = \marg{derivative}}
 \marg{deriv}\comment{label}
 \marg{\gls{ensuremath}\marg{f'(x)}}\comment{symbol}
\strut
\cmd{begin}\marg{document}
The derivative is denoted \gls{gls}\marg{deriv}.
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
The derivative is denoted \gls{ex.deriv}.
\end{result}
What if I need to change the variable for a specific instance, for
example, if I want $f'(x_i)$ instead of $f'(x)$? I can just use:
\begin{codeenv}
The gradient at \gls{mshiftchar}x\gls{sbchar}i\gls{mshiftchar} is \gls{mshiftchar}f'(x\gls{sbchar}i)\gls{mshiftchar}.
\end{codeenv}
So far, none of the example documents have a glossary or list of
terms. The ultimate aim when using the \styfmt{glossaries} package
is to ensure consistent formatting and notation, and, where
applicable, include a list of all terms referenced in the document.
The use of commands like \gls{gls} helps to achieve this. If the
notation needs to be changed, only the entry definition (and
associated formatting commands) should need to be redefined without
having to go through the whole document changing the code. Using
commands like \gls{gls} also identifies which entries need to be
included in the list of terms and, if \sty{hyperref} is loaded, can
be hyperlinked to the relevant place in that list.

So explicitly using \verb|f'(x_i)| won't index the \code{deriv} entry 
or mark it has having been used or create a hyperlink. One
possibility is to use one of the following commands:
\nosecformatdef{glslink}
\nosecformatdef{glsdisp}
They both work in much the same way, indexing the entry and
displaying \meta{text} as the \idx{link-text}. The only difference is
that \gls{glsdisp} also unsets the \idx{firstuseflag}, which marks the entry
as having been used. For example:
\begin{codeenv}
The gradient at \gls{mshiftchar}x\gls{sbchar}i\gls{mshiftchar} is \gls{glslink}\marg{deriv}\marg{\gls{mshiftchar}f'(x\gls{sbchar}i)\gls{mshiftchar}}.
\end{codeenv}
This solves the problem of ensuring that the \code{deriv} entry is
indexed and, if \sty{hyperref} is loaded, that the
\idx{link-text} has a hyperlink to the relevant place in the list of
notation, but it doesn't solve the problem of consistent formatting.

One way of ensuring consistent formatting is to define a semantic
command. For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}[\styopt{symbols}]\marg{glossaries-extra}
\strut
\gls{glsnoexpandfields}
\strut
\cmd{newcommand}\marg{\cmd{derivfn}}[1]\marg{f'(\gls{param}1)}
\strut
\gls{glsxtrnewsymbol}
 \oarg{\field{description} = \marg{derivative}}
 \marg{deriv}\comment{label}
 \marg{\gls{ensuremath}\marg{\cmd{derivfn}\marg{x}}}\comment{symbol}
\strut
\cmd{begin}\marg{document}
The derivative is denoted \gls{gls}\marg{deriv}.
The gradient at \gls{mshiftchar}x\gls{sbchar}i\gls{mshiftchar} is \gls{glslink}\marg{deriv}\marg{\gls{mshiftchar}\cmd{derivfn}\marg{x\gls{sbchar}i}\gls{mshiftchar}}.
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
\providecommand{\derivfn}[1]{f'(#1)}
The derivative is denoted \gls{ex.deriv}.
The gradient at $x_i$ is \glslink{ex.deriv}{$\derivfn{x_i}$}.
\end{result}
Now only \csfmt{derivfn} needs modifying if the notation must change.
This requires remembering both the entry label (\code{deriv} in this
case) and the associated formatting command (\csfmt{derivfn} in this
case). The \sty{glossaries-extra} package provides a way of storing
the associated formatting command in one of the additional keys (see
\sectionref{sec:userkeys}). The field is identified by:
\nosecformatdef{GlsXtrFmtField}
which defaults to \field{useri} (the internal representation of the
\field{user1} key). The value must be the name (without the leading
backslash) of a control sequence that takes a \emph{single}
mandatory argument. The above custom command \code{derivfn}
satisfies this requirement, so the entry can be defined as:
\begin{codeenv}
\gls{glsxtrnewsymbol}
 \oarg{\comment{settings:}
   \field{description} = \marg{derivative},
   \field{user1} = \marg{derivfn}
 }
 \marg{deriv}\comment{label}
 \marg{\gls{ensuremath}\marg{\cmd{derivfn}\marg{x}}}\comment{symbol}
\end{codeenv}
The formatting command can now be applied using one of the
following:
\nosecformatdef{glsxtrfmt}
\nosecformatdef{glsxtrfmt*}
which internally use \gls{glslink} or:
\nosecformatdef{glsxtrentryfmt}
which doesn't (as so is more like using \gls{glsentryname}).

So an alternative approach is:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}[\styopt{symbols}]\marg{glossaries-extra}
\strut
\gls{glsnoexpandfields}
\strut
\cmd{newcommand}\marg{\cmd{derivfn}}[1]\marg{f'(\gls{param}1)}
\strut
\gls{glsxtrnewsymbol}
 \oarg{\comment{settings:}
   \field{description} = \marg{derivative},
   \field{user1} = \marg{derivfn}
 }
 \marg{deriv}\comment{label}
 \marg{\gls{ensuremath}\marg{\cmd{derivfn}\marg{x}}}\comment{symbol}
\strut
\cmd{begin}\marg{document}
The derivative is denoted \gls{gls}\marg{deriv}.
The gradient at \gls{mshiftchar}x\gls{sbchar}i\gls{mshiftchar} is \gls{mshiftchar}\gls{glsxtrfmt}\marg{deriv}\marg{x\gls{sbchar}i}\gls{mshiftchar}.
\cmd{end}\marg{document}
\end{codeenv}
This again produces:
\begin{result}
The derivative is denoted \gls{ex.deriv}.
The gradient at $x_i$ is $\glsxtrfmt{ex.deriv}{x_i}$.
\end{result}

Both the starred \gls{glsxtrfmt*} and unstarred \gls{glsxtrfmt}
format the \meta{text} argument using:
\nosecformatdef{glsxtrfmtdisplay}
where \meta{cs-name} is the control sequence name stored in the
field identified by \gls{GlsXtrFmtField} and the \meta{insert} part
is empty for the unstarred \gls{glsxtrfmt} and the final optional
argument for the starred \gls{glsxtrfmt*}. If the command identified
by \meta{cs-name} doesn't exist (or if the field providing it isn't
set) then just \meta{text}\meta{insert} is done.

\begin{important}
Nested \idx{link-text} causes problems so don't use \gls{glsxtrfmt}
in the optional part of commands like \gls{gls} or \gls{glssymbol}
or in field values that are used by those types of command. Also
don't use \gls{glsxtrfmt} within the \meta{text} or \meta{insert}
part of another instance of \gls{glsxtrfmt} or in \gls{glslink} or
\gls{glsdisp}. Use \gls{glsxtrentryfmt} instead.
\end{important}

If more than one argument is required, then a helper macro is
needed. For example:
\begin{verbatim}
\newcommand{\iderivfn}[2][f]{#1'(#2)}
\newcommand{\derivfn}[1]{\iderivfn#1}
\end{verbatim}
Now to obtain $g'(x_i)$:
\begin{codeenv}
\gls{mshiftchar}\gls{glsxtrfmt}\marg{deriv}\marg{[g]\marg{x\gls{sbchar}i}}\gls{mshiftchar}
\end{codeenv}

\section{Dealing with Automated Case-Changing}
\label{sec:symfirstuc}

\chapter{Displaying the Definition}
\label{sec:printgloss}

\section{Standalone}

\section{Listing the Terms (Glossary)}

\chapter{Changing the Formatting}
\label{sec:glsformats}

All commands like \gls{gls} and \gls{glssymbol} by default
encapsulate the \idx{link-text} within the argument of
\nosecformatdef{glstextformat}
For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{xcolor}\comment{provides colour}
\cmd{usepackage}\marg{pifont}\comment{provides \gls{ding}}
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{newglossaryentry}\marg{duck}\comment{label}
\marg{
   \field{name} = \marg{duck},
   \field{description} = \marg{a waterbird with webbed feet}
}
\strut
\gls{newglossaryentry}\marg{fleuron}\comment{label}
\marg{
  \field{name} = \marg{fleuron},
  \field{symbol} = \marg{\gls[noindex=false]{ding}\marg{167}},
  \field{category} = \marg{ornament},
  \field{description} = \marg{typographic ornament}
}
\strut
\gls{newabbreviation}\marg{tug}\marg{TUG}\marg{\cmd{TeX}\gls{cs.space}Users Group}
\strut
\cmd{renewcommand}\marg{\gls{glstextformat}}[1]\marg{\cmd{textcolor}\marg{violet}\marg{\gls{param}1}}
\strut
\cmd{begin}\marg{document}
A \gls{gls}\marg{duck}, a \gls{gls}\marg{fleuron} (\gls{glssymbol}\marg{fleuron}, 
\gls{glsentrydesc}\marg{fleuron}) and \gls{gls}\marg{tug}.
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}%
\renewcommand{\glstextformat}[1]{\textcolor{violet}{#1}}%
A \gls{ex1.duck}, a \gls{ex.fleuron} (\glssymbol{ex.fleuron}, 
\glsentrydesc{ex.fleuron}) and \gls{TUG}.
\end{result}
Note that this has affected \gls{gls} and \gls{glssymbol} but not
\gls{glsentrydesc}.

A distinction can be made between abbreviations (\idx{non-regular}
terms) and \idx{regular} terms (non-abbreviations or abbreviations
that are considered \idx{regular} entries). 
A \idx{regular} term is encapsulated with 
\nosecformatdef{glsxtrregularfont}
and an abbreviation is encapsulated with 
\nosecformatdef{glsxtrabbreviationfont}
For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{xcolor}\comment{provides colour}
\cmd{usepackage}\marg{pifont}\comment{provides \gls{ding}}
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{newglossaryentry}\marg{duck}\comment{label}
\marg{
   \field{name} = \marg{duck},
   \field{description} = \marg{a waterbird with webbed feet}
}
\strut
\gls{newglossaryentry}\marg{fleuron}\comment{label}
\marg{
  \field{name} = \marg{fleuron},
  \field{symbol} = \marg{\gls{ding}\marg{167}},
  \field{category} = \marg{ornament},
  \field{description} = \marg{typographic ornament}
}
\strut
\gls{newabbreviation}\marg{tug}\marg{TUG}\marg{\cmd{TeX}\gls{cs.space}Users Group}
\gls{newacronym}\marg{ascii}\marg{ASCII}\marg{American Standard Code for 
Information Interchange}
\strut
\cmd{renewcommand}\marg{\gls{glstextformat}}[1]\marg{\cmd{textcolor}\marg{violet}\marg{\gls{param}1}}
\cmd{renewcommand}\marg{\gls{glsxtrregularfont}}[1]\marg{\cmd{underline}\marg{\gls{param}1}}
\cmd{renewcommand}\marg{\gls{glsxtrabbreviationfont}}[1]\marg{\gls{emph}\marg{\gls{param}1}}
\strut
\cmd{begin}\marg{document}
Two \gls{glspl}\marg{duck}, a \gls{gls}\marg{fleuron} (\gls{glssymbol}\marg{fleuron}, 
\gls{glsentrydesc}\marg{fleuron}), \gls{gls}\marg{tug} and \gls{gls}\marg{ascii}.
\cmd{end}\marg{document}
\end{codeenv}
This now produces:
\begin{result}%
\renewcommand{\glstextformat}[1]{\textcolor{violet}{#1}}%
\renewcommand{\glsxtrregularfont}[1]{\underline{#1}}%
\renewcommand{\glsxtrabbreviationfont}[1]{\emph{#1}}%
Two \glspl{ex1.duck}, a \gls{ex.fleuron} (\glssymbol{ex.fleuron}, 
\glsentrydesc{ex.fleuron}), \gls{TUG} and \gls{ASCII}.
\end{result}
Note the difference between the abbreviation defined with
\gls{newabbreviation} and the one defined with \gls{newacronym}.
This document is using the default styles, which is
\abbrstyle{long-short} for the \code{abbreviation} category
and \abbrstyle{short-nolong} for the \code{acronym} category.
The \abbrstyle{short-nolong} style makes the abbreviation behave
like a \idx{regular} entry and so it's governed by \gls{glsxtrregularfont}
not by \gls{glsxtrabbreviationfont}.

The \gls{glstextformat} command is overridden by the
\catattr{textformat} attribute. The value of this attribute must be
the name (without the leading backslash) of a command that takes a
single argument, which will be used instead of \gls{glstextformat}
for any entry that has this attribute set for its category.
For example:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{xcolor}\comment{provides colour}
\cmd{usepackage}\marg{pifont}\comment{provides \gls{ding}}
\cmd{usepackage}\marg{glossaries-extra}
\strut
\cmd{newcommand}\marg{\cmd{ornamentfmt}}[1]\marg{\cmd{textcolor}\marg{cyan}\marg{\gls{param}1}}
\strut
\gls{glssetcategoryattribute}\marg{ornament}\marg{\catattr{textformat}}\marg{ornamentfmt}
\strut
\gls{newglossaryentry}\marg{duck}\comment{label}
\marg{
   \field{name} = \marg{duck},
   \field{description} = \marg{a waterbird with webbed feet}
}
\strut
\gls{newglossaryentry}\marg{fleuron}\comment{label}
\marg{
  \field{name} = \marg{fleuron},
  \field{symbol} = \marg{\gls{ding}\marg{167}},
  \field{category} = \marg{ornament},
  \field{description} = \marg{typographic ornament}
}
\strut
\gls{newabbreviation}\marg{tug}\marg{TUG}\marg{\cmd{TeX}\gls{cs.space}Users Group}
\gls{newacronym}\marg{ascii}\marg{ASCII}\marg{American Standard Code for 
Information Interchange}
\strut
\cmd{renewcommand}\marg{\gls{glstextformat}}[1]\marg{\cmd{textcolor}\marg{violet}\marg{\gls{param}1}}
\cmd{renewcommand}\marg{\gls{glsxtrregularfont}}[1]\marg{\cmd{underline}\marg{\gls{param}1}}
\cmd{renewcommand}\marg{\gls{glsxtrabbreviationfont}}[1]\marg{\gls{emph}\marg{\gls{param}1}}
\strut
\cmd{begin}\marg{document}
Two \gls{glspl}\marg{duck}, a \gls{gls}\marg{fleuron} (\gls{glssymbol}\marg{fleuron}, 
\gls{glsentrydesc}\marg{fleuron}), \gls{gls}\marg{tug} and \gls{gls}\marg{ascii}.
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
\renewcommand{\glstextformat}[1]{\textcolor{violet}{#1}}%
\renewcommand{\glsxtrregularfont}[1]{\underline{#1}}%
\renewcommand{\glsxtrabbreviationfont}[1]{\emph{#1}}%
\newcommand{\ornamentfmt}[1]{\textcolor{cyan}{#1}}%
\glssetcategoryattribute{ornament}{textformat}{ornamentfmt}%
Two \glspl{ex1.duck}, a \gls{ex.fleuron} (\glssymbol{ex.fleuron}, 
\glsentrydesc{ex.fleuron}), \gls{TUG} and \gls{ASCII}.
\end{result}
So \code{\gls{gls}\marg{fleuron}} and \code{\gls{glssymbol}\marg{fleuron}} are now
formatted according to the custom command \csfmt{ornamentfmt}
not by \gls{glstextformat}, but they are still affected by
\gls{glsxtrregularfont}.

You can override a specific instance with the \glsopt{textformat}
setting in the first optional argument of commands like \gls{gls}.
For example, if the above is modified to:
\begin{codeenv}
Two \gls{glspl}\marg{duck}, a \gls{gls}\oarg{\glsopt{textformat}=textbf}\marg{fleuron} 
(\gls{glssymbol}\marg{fleuron}, \gls{glsentrydesc}\marg{fleuron}), \gls{gls}\marg{tug} 
and \gls{gls}\marg{ascii}.
\end{codeenv}
then the result is now:
\begin{result}
\renewcommand{\glstextformat}[1]{\textcolor{violet}{#1}}%
\renewcommand{\glsxtrregularfont}[1]{\underline{#1}}%
\renewcommand{\glsxtrabbreviationfont}[1]{\emph{#1}}%
\newcommand{\ornamentfmt}[1]{\textcolor{cyan}{#1}}%
\glssetcategoryattribute{ornament}{textformat}{ornamentfmt}%
Two \glspl{ex1.duck}, a \gls[textformat=textbf]{ex.fleuron} 
(\glssymbol{ex.fleuron}, \glsentrydesc{ex.fleuron}), 
\gls{TUG} and \gls{ASCII}.
\end{result}
In this case, only that specific instance is changed.

Take care if the formatting command needs to parse its argument as
the argument won't be the actual text but consists of intermediary commands
that determine the required text and any inner formatting, such as
the formatting applied by abbreviation styles. See
\sectionref{sec:expandedfmt} for further details.

\section{Post-Link Category Hooks}
\label{sec:postlinkhooks}

Extra information can be appended after commands such as \gls{gls}
by defining a \pidx{postlinkhook} for the given category. You can
obtain the label of the entry that's just been referenced with:
\nosecformatdef{glslabel}
The \idx{postlinkhook} is a command in the form
\nosecformatdef{glsxtrpostlinkcategory}
where \meta{category} is the category label. This hook is
implemented after any instances of commands such as \gls{gls} or
\gls{glssymbol} (but not after commands like \gls{glsentryname},
\gls{glsentrydesc} or \gls{glsentryname}, which may be used in the
hook).

Consider the following document:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{pifont}\comment{provides \gls{ding}}
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{newglossaryentry}\marg{fleuron}\comment{label}
\marg{
  \field{name} = \marg{fleuron},
  \field{symbol} = \marg{\gls{ding}\marg{167}},
  \field{description} = \marg{typographic ornament}
}
\strut
\gls{newglossaryentry}\marg{pi}\comment{label}
\marg{
  \field{name} = \marg{Archimedes' constant},
  \field{symbol} = \marg{\gls{ensuremath}\marg{\cmd{pi}}},
  \field{category} = \marg{constant},
  \field{description} = \marg{Archimedes' constant}
}
\strut
\comment{post-link hook for 'constant' category:}
\cmd{newcommand}\marg{\csfmt{glsxtrpostlinkconstant}}\marg{\comment{} 
 \cmd{space} (\gls{glsentrysymbol}\marg{\gls{glslabel}})}
\strut
\cmd{begin}\marg{document}
A \gls{gls}\marg{fleuron} and \gls{gls}\marg{pi}.
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
\newcommand{\glsxtrpostlinkconstant}{\space (\glsentrysymbol{\glslabel})}%
A \gls{ex.fleuron} and \gls{ex.pi}.
\end{result}
The \code{fleuron} entry doesn't have the \field{category} key
explicitly set, so it defaults to \code{general}, but the \code{pi}
entry has the \field{category} set to \code{constant}, so it's
affected by the \idx{postlinkhook} for that category, which in this
case is given by \csfmt{glsxtrpostlinkconstant}. This hook is
defined to use \gls{glsentrysymbol} where the entry label is obtained
from \gls{glslabel}, which is set by \gls{gls} and similar commands.

\begin{important}
If \code{\gls{glssymbol}\marg{\gls{glslabel}}} had been used instead of
\code{\gls{glsentrysymbol}\marg{\gls{glslabel}}} it would've caused infinite
recursion! Don't use commands like \gls{glssymbol}, \gls{glsdesc} or
\gls{gls} in \idxpl{postlinkhook}.
\end{important}

This means that \code{\gls{gls}\marg{pi}} is automatically followed by the
symbol in parentheses, but \code{\gls{gls}\marg{fleuron}} isn't because it's
governed by the \code{general} \idx{postlinkhook} instead. Note that
the above is a simple example to demonstrate one of the uses of the
\field{category} field.

Here's a minor modification that sets the category for the
\code{fleuron} entry to \code{ornament} and creates another hook for
that.
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{pifont}\comment{provides \gls{ding}}
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{newglossaryentry}\marg{fleuron}\comment{label}
\marg{
  \field{name} = \marg{fleuron},
  \field{symbol} = \marg{\gls{ding}\marg{167}},
  \field{category} = \marg{ornament},
  \field{description} = \marg{typographic ornament}
}
\strut
\gls{newglossaryentry}\marg{pi}\comment{label}
\marg{
  \field{name} = \marg{pi},
  \field{symbol} = \marg{\gls{ensuremath}\marg{\cmd{pi}}},
  \field{category} = \marg{constant},
  \field{description} = \marg{Archimedes' constant}
}
\strut
\comment{post-link hook for 'ornament' category:}
\cmd{newcommand}\marg{\csfmt{glsxtrpostlinkornament}}\marg{\comment{}
 \cmd{space} (\gls{glsentrydesc}\marg{\gls{glslabel}})}
\strut
\comment{post-link hook for 'constant' category:}
\cmd{newcommand}\marg{\csfmt{glsxtrpostlinkconstant}}{\comment{}
 \cmd{space} (\gls{glsentrysymbol}\marg{\gls{glslabel}})}
\strut
\cmd{begin}\marg{document}
A \gls{gls}\marg{fleuron} and \gls{gls}\marg{pi}. Another \gls{gls}\marg{fleuron} and 
\gls{gls}\marg{pi}. Symbols: \gls{glssymbol}\marg{fleuron} and \gls{glssymbol}\marg{pi}.
\cmd{end}\marg{document}
\end{codeenv}
This produces:
\begin{result}
\newcommand{\glsxtrpostlinkornament}{\space (\glsentrydesc{\glslabel})}%
\newcommand{\glsxtrpostlinkconstant}{\space (\glsentrysymbol{\glslabel})}%
A \gls{ex.fleuron} and \gls{ex.pi}. Another \gls{ex.fleuron} and 
\gls{ex.pi}. Symbols: \glssymbol{ex.fleuron} and \glssymbol{ex.pi}.
\end{result}
The \idx{postlinkhook} is repeated after every instance of \gls{gls}
or \gls{glssymbol} etc. In the case of the \code{ornament} category,
the description is appended in parentheses and in the case of the
\code{constant} category the symbol is appended. This results in
redundant repetition, especially with \verb|\glssymbol{pi}| which
displays the symbol followed by the symbol in parentheses.

It's more likely that the information only needs to be appended
after the \idx{firstuse}. You can determine if the
\idx{postlinkhook} follows the \idx{firstuse} of the entry using:
\nosecformatdef{glsxtrifwasfirstuse}
For example:
\begin{codeenv}
\cmd{newcommand}\marg{\csfmt{glsxtrpostlinkconstant}}\marg{\comment{}
 \gls{glsxtrifwasfirstuse}\marg{\cmd{space} (\gls{glsentrysymbol}\marg{\gls{glslabel}})}\marg{}\comment{}
}
\end{codeenv}
Commands that don't check or modify the \idx{firstuseflag}, such as
\gls{glssymbol}, always set \gls{glsxtrifwasfirstuse} so that it
expands to \meta{false}. This means that even if
\code{\gls{glssymbol}\marg{pi}}
is placed before the first instance of \code{\gls{gls}\marg{pi}} it still
won't be treated as the first use of that entry.

For convenience, there's a shortcut command:
\nosecformatdef{glsxtrpostlinkAddSymbolOnFirstUse}
So an alternative definition is:
\begin{codeenv}
\cmd{newcommand}\marg{\csfmt{glsxtrpostlinkconstant}}\marg{\comment{}
  \gls{glsxtrpostlinkAddSymbolOnFirstUse}
}
\end{codeenv}
This does nothing if the \field{symbol} field hasn't been set.

Similarly, there's a shortcut command for the description:
\nosecformatdef{glsxtrpostlinkAddDescOnFirstUse}
Version 1.31+ provides a combination:
\nosecformatdef{glsxtrpostlinkAddSymbolDescOnFirstUse}
If the \field{symbol} field is set, this displays the symbol
followed by a comma and space. The description is always displayed
at the end of the parenthetical material

Also from \sty{glossaries-extra} v1.31, there's a shortcut
command that you can use to define the \idx{postlinkhook}:
\nosecformatdef{glsdefpostlink} 
This is just a shortcut for:
\begin{codeenv}
\csfmt{csdef}\marg{glsxtrpostlink\meta{category}}\margm{definition}
\end{codeenv}
So the above document can be changed to:
\begin{codeenv}
\cmd{documentclass}\marg{article}
\strut
\cmd{usepackage}\marg{pifont}\comment{provides \gls{ding}}
\cmd{usepackage}\marg{glossaries-extra}
\strut
\gls{newglossaryentry}\marg{fleuron}\comment{label}
\marg{
  \field{name} = \marg{fleuron},
  \field{symbol} = \marg{\gls{ding}\marg{167}},
  \field{category} = \marg{ornament},
  \field{description} = \marg{typographic ornament}
}
\strut
\gls{newglossaryentry}\marg{pi}\comment{label}
\marg{
  \field{name} = \marg{pi},
  \field{symbol} = \marg{\gls{ensuremath}\marg{\cmd{pi}}},
  \field{category} = \marg{constant},
  \field{description} = \marg{Archimedes' constant}
}
\strut
\comment{post-link hook for 'ornament' category:}
\gls{glsdefpostlink}\marg{ornament}\marg{\comment{}
  \gls{glsxtrpostlinkAddSymbolDescOnFirstUse}
}
\strut
\comment{post-link hook for 'constant' category:}
\gls{glsdefpostlink}\marg{constant}\marg{\comment{}
  \gls{glsxtrpostlinkAddSymbolOnFirstUse}
}
\strut
\cmd{begin}\marg{document}
Symbols: \gls{glssymbol}\marg{fleuron} and \gls{glssymbol}\marg{pi}.
A \gls{gls}\marg{fleuron} and \gls{gls}\marg{pi}. Another \gls{gls}\marg{fleuron} and 
\gls{gls}\marg{pi}.
\cmd{end}\marg{document}
\end{codeenv}
The result is now:
\begin{result}%
\glsdefpostlink{ornament}{\glsxtrpostlinkAddSymbolDescOnFirstUse}%
\glsdefpostlink{constant}{\glsxtrpostlinkAddSymbolOnFirstUse}%
Symbols: \glssymbol{ex.fleuron} and \glssymbol{ex.pi}.
A \gls{ex.fleuron} and \gls{ex.pi}. Another \gls{ex.fleuron} and
\gls{ex.pi}.
\end{result}

\section{Post-Name and Post-Description Hooks}
\label{sec:postfieldhooks}

\chapter{Problematic Areas}
\label{sec:problems}

There are some places where the use of commands like \gls{gls} can
cause problems. These are listed below, with workarounds provided.

\section{Headings and Captions}
\label{sec:headings}

\section{Nesting}
\label{sec:nested}

\section{Formatting Commands that Need Direct Access to the Text}
\label{sec:expandedfmt}

If you want to redefine any of the formatting commands
\gls{glstextformat}, \gls{glsxtrregularfont} or
\gls{glsxtrabbreviationfont}, remember that their argument isn't the
actual text but consists of intermediary commands
that determine the required text and any inner formatting, such as
the formatting applied by abbreviation styles.

With the \glsopt{hyperoutside} setting on, the outermost level
will be the command to apply the hyperlink with \gls{glstextformat}
(or the equivalent provided by \catattr{textformat}) 
inside the hyperlink text. (If hyperlinks aren't enabled the outer
command simply does the hyperlink text.)

With \glsopt[false]{hyperoutside}, the outermost level will be
\gls{glstextformat} (or equivalent) with the command that applies
the hyperlink inside the formatting argument.

The next level down sets up the abbreviation styles for the given
category (if appropriate). If the entry isn't an abbreviation or is
an abbreviation classified as regular then
\gls{glsxtrregularfont} is applied to the command that governs how
regular entries are formatted. Otherwise \gls{glsxtrabbreviationfont}
is applied to the command that governs how abbreviations are
formatted.

Finally, there are tests applied to determine if this is the
\idx{firstuse}, if the plural is required, if any case-changing is
required, if the final optional argument has been given, or if a
command such as \gls{glssymbol} has been used.  These tests
determine which field to obtain the \idx{link-text} from. With
abbreviations, any formatting required by the abbreviation style is
finally performed.

This makes it very difficult to apply a formatting command that
needs direct access to the actual text that needs to be displayed.
One possible method is to use:
\nosecformatdef{GlsXtrExpandedFmt}
which first (protected) fully expands \meta{text} and then performs
\meta{cs}\margm{expanded text} where \meta{cs} is a control
sequence. For example, the \isty{soul} package provides the command
\gls{ul} to underline text, but it needs to be able to parse its
argument to work. If I simply try to change the standard
\gls{underline} to \gls{ul} in the earlier example from
\sectionref{sec:glsformats}:
\begin{codeenv}
\cmd{renewcommand}\marg{\gls{glsxtrregularfont}}[1]\marg{\cmd{ul}\marg{\gls{param}1}}
\end{codeenv}
then this causes the error:
\begin{verbatim}
! Package soul Error: Reconstruction failed.
\end{verbatim}
Instead I need:
\begin{codeenv}
\cmd{renewcommand}\marg{\gls{glsxtrregularfont}}[1]\marg{\gls{GlsXtrExpandedFmt}\cmd{ul}\marg{\gls{param}1}}
\end{codeenv}
\emph{and also} \gls{ding} now needs protection:
\begin{codeenv}
\gls{newglossaryentry}\marg{fleuron}\comment{label}
\marg{
  \field{name} = \marg{fleuron},
  \field{symbol} = \marg{\gls{protect}\gls{ding}\marg{167}},
  \field{category} = \marg{ornament},
  \field{description} = \marg{typographic ornament}
}
\end{codeenv}

\chapter{Incorporating \bibgls}
\label{sec:bib2gls}

\bibliographystyle{plain}
\bibliography{bib2gls-cite}

\printunsrtglossary*
 [style=treegroup,title={Command Summary},nonumberlist]
{%
 \renewcommand*{\printunsrtglossaryentryprocesshook}[1]{%
   \glsifcategory{#1}{command}{}{\printunsrtglossaryskipentry}%
 }%
 \glssetcategoryattribute{command}{glossdesc}{firstuc}%
 \renewcommand*{\csfmtfont}[1]{\texttt{\color{cs}#1}}%
 \renewcommand{\glstreenamefmt}{\texttt}%
 \renewcommand{\glstreegroupheaderfmt}{\textbf}%
 \renewcommand{\glstreesubitem}{\glspar\parindent=2em\hangindent2em}%
 \renewcommand{\glstreepredesc}{\glsadd{\glscurrententrylabel}%
   \nopagebreak\glstreesubitem}%
 \glsdefpostname{command}{\glsentryuseri{\glscurrententrylabel}}%
 \glsdefpostdesc{command}{.\nopagebreak\glstreesubitem
  \Glsentryuserii{\glscurrententrylabel}.%
  \glspar\medskip}%
}

\renewcommand*{\glstarget}[2]{%
 \glsifcategory{#1}{command}{#2}{\glsdohypertarget{\glolinkprefix#1}{#2}}%
}
\renewcommand{\glstreeitem}{\par\parindent0pt}
\renewcommand*{\glsxtrbookindexprelocation}[1]{%
  \glsxtrifhasfield{location}{#1}%
  {\enspace
   \textcolor{lightgray}{\nolinebreak\cleaders\hbox to .5em{\hss.\hss}\hfill}%
   \enspace}%
  {}%
}
\printunsrtglossary[style=bookindex,title=Index]
\end{document}
